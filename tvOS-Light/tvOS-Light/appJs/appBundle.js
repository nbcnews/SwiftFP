/**
 * App version: 1.0.0
 * SDK version: 4.2.1
 * CLI version: 2.2.0
 *
 * Generated: Wed, 24 Mar 2021 21:08:57 GMT
 */

var APP_com_nbcnews_tvx = (function () {
  'use strict';

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const settings = {};
  const subscribers = {};

  const initSettings = (appSettings, platformSettings) => {
    settings['app'] = appSettings;
    settings['platform'] = platformSettings;
    settings['user'] = {};
  };

  const publish = (key, value) => {
    subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value));
  };

  const dotGrab = (obj = {}, key) => {
    const keys = key.split('.');
    for (let i = 0; i < keys.length; i++) {
      obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {};
    }
    return typeof obj === 'object' ? (Object.keys(obj).length ? obj : undefined) : obj
  };

  var Settings = {
    get(type, key, fallback = undefined) {
      const val = dotGrab(settings[type], key);
      return val !== undefined ? val : fallback
    },
    has(type, key) {
      return !!this.get(type, key)
    },
    set(key, value) {
      settings['user'][key] = value;
      publish(key, value);
    },
    subscribe(key, callback) {
      subscribers[key] = subscribers[key] || [];
      subscribers[key].push(callback);
    },
    unsubscribe(key, callback) {
      if (callback) {
        const index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback);
        index > -1 && subscribers[key].splice(index, 1);
      } else {
        if (key in subscribers) {
          subscribers[key] = [];
        }
      }
    },
    clearSubscribers() {
      for (const key of Object.getOwnPropertyNames(subscribers)) {
        delete subscribers[key];
      }
    },
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const prepLog = (type, args) => {
    const colors = {
      Info: 'green',
      Debug: 'gray',
      Warn: 'orange',
      Error: 'red',
    };

    args = Array.from(args);
    return [
//      '%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type),
//      'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px',
      args,
    ]
  };

  var Log = {
    info() {
      Settings.get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments));
    },
    debug() {
      Settings.get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments));
    },
    error() {
      Settings.get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments));
    },
    warn() {
      Settings.get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments));
    },
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let sendMetric = (type, event, params) => {
    Log.info('Sending metric', type, event, params);
  };

  const initMetrics = config => {
    sendMetric = config.sendMetric;
  };

  // available metric per category
  const metrics = {
    app: ['launch', 'loaded', 'ready', 'close'],
    page: ['view', 'leave'],
    user: ['click', 'input'],
    media: [
      'abort',
      'canplay',
      'ended',
      'pause',
      'play',
      // with some videos there occur almost constant suspend events ... should investigate
      // 'suspend',
      'volumechange',
      'waiting',
      'seeking',
      'seeked',
    ],
  };

  // error metric function (added to each category)
  const errorMetric = (type, message, code, visible, params = {}) => {
    params = { params, ...{ message, code, visible } };
    sendMetric(type, 'error', params);
  };

  const Metric = (type, events, options = {}) => {
    return events.reduce(
      (obj, event) => {
        obj[event] = (name, params = {}) => {
          params = { ...options, ...(name ? { name } : {}), ...params };
          sendMetric(type, event, params);
        };
        return obj
      },
      {
        error(message, code, params) {
          errorMetric(type, message, code, params);
        },
        event(name, params) {
          sendMetric(type, name, params);
        },
      }
    )
  };

  const Metrics = types => {
    return Object.keys(types).reduce(
      (obj, type) => {
        // media metric works a bit different!
        // it's a function that accepts a url and returns an object with the available metrics
        // url is automatically passed as a param in every metric
        type === 'media'
          ? (obj[type] = url => Metric(type, types[type], { url }))
          : (obj[type] = Metric(type, types[type]));
        return obj
      },
      { error: errorMetric, event: sendMetric }
    )
  };

  var Metrics$1 = Metrics(metrics);

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var events = {
    abort: 'Abort',
    canplay: 'CanPlay',
    canplaythrough: 'CanPlayThrough',
    durationchange: 'DurationChange',
    emptied: 'Emptied',
    encrypted: 'Encrypted',
    ended: 'Ended',
    error: 'Error',
    interruptbegin: 'InterruptBegin',
    interruptend: 'InterruptEnd',
    loadeddata: 'LoadedData',
    loadedmetadata: 'LoadedMetadata',
    loadstart: 'LoadStart',
    pause: 'Pause',
    play: 'Play',
    playing: 'Playing',
    progress: 'Progress',
    ratechange: 'Ratechange',
    seeked: 'Seeked',
    seeking: 'Seeking',
    stalled: 'Stalled',
    // suspend: 'Suspend', // this one is called a looooot for some videos
    timeupdate: 'TimeUpdate',
    volumechange: 'VolumeChange',
    waiting: 'Waiting',
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var autoSetupMixin = (sourceObject, setup = () => {}) => {
    let ready = false;

    const doSetup = () => {
      if (ready === false) {
        setup();
        ready = true;
      }
    };

    return Object.keys(sourceObject).reduce((obj, key) => {
      if (typeof sourceObject[key] === 'function') {
        obj[key] = function() {
          doSetup();
          return sourceObject[key].apply(sourceObject, arguments)
        };
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === 'function') {
        obj.__defineGetter__(key, function() {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject)
        });
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === 'function') {
        obj.__defineSetter__(key, function() {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(
            sourceObject,
            arguments
          )
        });
      } else {
        obj[key] = sourceObject[key];
      }
      return obj
    }, {})
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let timeout = null;

  var easeExecution = (cb, delay) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      cb();
    }, delay);
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let basePath;
  let proxyUrl;

  const initUtils = config => {
    basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config.path || '/'));
console.log('base path', basePath)
    if (config.proxyUrl) {
      proxyUrl = ensureUrlWithProtocol(config.proxyUrl);
    }
  };

  var Utils = {
    asset(relPath) {
        console.log('asset', basePath + relPath)
      return basePath + relPath
    },
    proxyUrl(url, options = {}) {
      return proxyUrl ? proxyUrl + '?' + makeQueryString(url, options) : url
    },
    makeQueryString() {
      return makeQueryString(...arguments)
    },
    // since imageworkers don't work without protocol
    ensureUrlWithProtocol() {
      return ensureUrlWithProtocol(...arguments)
    },
  };

  const ensureUrlWithProtocol = url => {
    if (/^\/\//.test(url)) {
      return window.location.protocol + url
    }
    if (!/^(?:https?:)/i.test(url)) {
      return window.location.origin + url
    }
    return url
  };

  const makeFullStaticPath = (pathname = '/', path) => {
    // ensure path has traling slash
    path = path.charAt(path.length - 1) !== '/' ? path + '/' : path;

    // if path is URL, we assume it's already the full static path, so we just return it
    if (/^(?:https?:)?(?:\/\/)/.test(path)) {
      return path
    }

    if (path.charAt(0) === '/') {
      return path
    } else {
      // cleanup the pathname (i.e. remove possible index.html)
      pathname = cleanUpPathName(pathname);

      // remove possible leading dot from path
      path = path.charAt(0) === '.' ? path.substr(1) : path;
      // ensure path has leading slash
      path = path.charAt(0) !== '/' ? '/' + path : path;
      return pathname + path
    }
  };

  const cleanUpPathName = pathname => {
    if (pathname.slice(-1) === '/') return pathname.slice(0, -1)
    const parts = pathname.split('/');
    if (parts[parts.length - 1].indexOf('.') > -1) parts.pop();
    return parts.join('/')
  };

  const makeQueryString = (url, options = {}, type = 'url') => {
    // add operator as an option
    options.operator = 'metrological'; // Todo: make this configurable (via url?)
    // add type (= url or qr) as an option, with url as the value
    options[type] = url;

    return Object.keys(options)
      .map(key => {
        return encodeURIComponent(key) + '=' + encodeURIComponent('' + options[key])
      })
      .join('&')
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const initProfile = config => {
    config.getInfo;
    config.setInfo;
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var lightning = createCommonjsModule(function (module, exports) {
  /**
   * Lightning v2.2.0
   *
   * https://github.com/rdkcentral/Lightning
   */

  (function (global, factory) {
       module.exports = factory() ;
  }(commonjsGlobal, (function () {
      class StageUtils {
          static mergeNumbers(v1, v2, p) {
              return v1 * p + v2 * (1 - p);
          };
          static rgb(r, g, b) {
              return (r << 16) + (g << 8) + b + (255 * 16777216);
          };
          static rgba(r, g, b, a) {
              return (r << 16) + (g << 8) + b + (((a * 255) | 0) * 16777216);
          };
          static getRgbString(color) {
              let r = ((color / 65536) | 0) % 256;
              let g = ((color / 256) | 0) % 256;
              let b = color % 256;
              return 'rgb(' + r + ',' + g + ',' + b + ')';
          };
          static getRgbaString(color) {
              let r = ((color / 65536) | 0) % 256;
              let g = ((color / 256) | 0) % 256;
              let b = color % 256;
              let a = ((color / 16777216) | 0) / 255;
              return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
          };
          static getRgbaStringFromArray(color) {
              let r = Math.floor(color[0] * 255);
              let g = Math.floor(color[1] * 255);
              let b = Math.floor(color[2] * 255);
              let a = Math.floor(color[3] * 255) / 255;
              return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
          };
          static getRgbaComponentsNormalized(argb) {
              let r = ((argb / 65536) | 0) % 256;
              let g = ((argb / 256) | 0) % 256;
              let b = argb % 256;
              let a = ((argb / 16777216) | 0);
              return [r / 255, g / 255, b / 255, a / 255];
          };
          static getRgbComponentsNormalized(argb) {
              let r = ((argb / 65536) | 0) % 256;
              let g = ((argb / 256) | 0) % 256;
              let b = argb % 256;
              return [r / 255, g / 255, b / 255];
          };
          static getRgbaComponents(argb) {
              let r = ((argb / 65536) | 0) % 256;
              let g = ((argb / 256) | 0) % 256;
              let b = argb % 256;
              let a = ((argb / 16777216) | 0);
              return [r, g, b, a];
          };
          static getArgbNumber(rgba) {
              rgba[0] = Math.max(0, Math.min(255, rgba[0]));
              rgba[1] = Math.max(0, Math.min(255, rgba[1]));
              rgba[2] = Math.max(0, Math.min(255, rgba[2]));
              rgba[3] = Math.max(0, Math.min(255, rgba[3]));
              let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
              if (v < 0) {
                  v = 0xFFFFFFFF + v + 1;
              }
              return v;
          };
          static mergeColors(c1, c2, p) {
              let r1 = ((c1 / 65536) | 0) % 256;
              let g1 = ((c1 / 256) | 0) % 256;
              let b1 = c1 % 256;
              let a1 = ((c1 / 16777216) | 0);
              let r2 = ((c2 / 65536) | 0) % 256;
              let g2 = ((c2 / 256) | 0) % 256;
              let b2 = c2 % 256;
              let a2 = ((c2 / 16777216) | 0);
              let r = r1 * p + r2 * (1 - p);
              let g = g1 * p + g2 * (1 - p);
              let b = b1 * p + b2 * (1 - p);
              let a = a1 * p + a2 * (1 - p);
              return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
          };
          static mergeMultiColors(c, p) {
              let r = 0, g = 0, b = 0, a = 0, t = 0;
              let n = c.length;
              for (let i = 0; i < n; i++) {
                  let r1 = ((c[i] / 65536) | 0) % 256;
                  let g1 = ((c[i] / 256) | 0) % 256;
                  let b1 = c[i] % 256;
                  let a1 = ((c[i] / 16777216) | 0);
                  r += r1 * p[i];
                  g += g1 * p[i];
                  b += b1 * p[i];
                  a += a1 * p[i];
                  t += p[i];
              }
              t = 1 / t;
              return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
          };
          static mergeMultiColorsEqual(c) {
              let r = 0, g = 0, b = 0, a = 0, t = 0;
              let n = c.length;
              for (let i = 0; i < n; i++) {
                  let r1 = ((c[i] / 65536) | 0) % 256;
                  let g1 = ((c[i] / 256) | 0) % 256;
                  let b1 = c[i] % 256;
                  let a1 = ((c[i] / 16777216) | 0);
                  r += r1;
                  g += g1;
                  b += b1;
                  a += a1;
                  t += 1.0;
              }
              t = 1 / t;
              return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
          };
          static mergeColorAlpha(c, alpha) {
              let a = ((c / 16777216 | 0) * alpha) | 0;
              return (((((c >> 16) & 0xff) * a) / 255) & 0xff) +
                  ((((c & 0xff00) * a) / 255) & 0xff00) +
                  (((((c & 0xff) << 16) * a) / 255) & 0xff0000) +
                  (a << 24);
          };
          static rad(deg) {
              return deg * (Math.PI / 180);
          };
          static getTimingBezier(a, b, c, d) {
              let xc = 3.0 * a;
              let xb = 3.0 * (c - a) - xc;
              let xa = 1.0 - xc - xb;
              let yc = 3.0 * b;
              let yb = 3.0 * (d - b) - yc;
              let ya = 1.0 - yc - yb;
              return function (time) {
                  if (time >= 1.0) {
                      return 1;
                  }
                  if (time <= 0) {
                      return 0;
                  }
                  let t = 0.5, cbx, cbxd, dx;
                  for (let it = 0; it < 20; it++) {
                      cbx = t * (t * (t * xa + xb) + xc);
                      dx = time - cbx;
                      if (dx > -1e-8 && dx < 1e-8) {
                          return t * (t * (t * ya + yb) + yc);
                      }
                      cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
                      if (cbxd > 1e-10 && cbxd < 1e-10) {
                          break;
                      }
                      t += dx / cbxd;
                  }
                  let minT = 0;
                  let maxT = 1;
                  for (let it = 0; it < 20; it++) {
                      t = 0.5 * (minT + maxT);
                      cbx = t * (t * (t * xa + xb) + xc);
                      dx = time - cbx;
                      if (dx > -1e-8 && dx < 1e-8) {
                          return t * (t * (t * ya + yb) + yc);
                      }
                      if (dx < 0) {
                          maxT = t;
                      } else {
                          minT = t;
                      }
                  }
              };
          };
          static getTimingFunction(str) {
              switch (str) {
                  case "linear":
                      return function (time) {
                          return time
                      };
                  case "ease":
                      return StageUtils.getTimingBezier(0.25, 0.1, 0.25, 1.0);
                  case "ease-in":
                      return StageUtils.getTimingBezier(0.42, 0, 1.0, 1.0);
                  case "ease-out":
                      return StageUtils.getTimingBezier(0, 0, 0.58, 1.0);
                  case "ease-in-out":
                      return StageUtils.getTimingBezier(0.42, 0, 0.58, 1.0);
                  case "step-start":
                      return function () {
                          return 1
                      };
                  case "step-end":
                      return function (time) {
                          return time === 1 ? 1 : 0;
                      };
                  default:
                      let s = "cubic-bezier(";
                      if (str && str.indexOf(s) === 0) {
                          let parts = str.substr(s.length, str.length - s.length - 1).split(",");
                          if (parts.length !== 4) {
                              console.warn("[Lightning] Unknown timing function: " + str);
                              return function (time) {
                                  return time
                              };
                          }
                          let a = parseFloat(parts[0]);
                          let b = parseFloat(parts[1]);
                          let c = parseFloat(parts[2]);
                          let d = parseFloat(parts[3]);
                          if (isNaN(a) || isNaN(b) || isNaN(c) || isNaN(d)) {
                              console.warn("[Lightning] Unknown timing function: " + str);
                              return function (time) {
                                  return time
                              };
                          }
                          return StageUtils.getTimingBezier(a, b, c, d);
                      } else {
                          console.warn("[Lightning] Unknown timing function: " + str);
                          return function (time) {
                              return time
                          };
                      }
              }
          };
      }

      class Utils {
          static isFunction(value) {
              return typeof value === 'function';
          }
          static isNumber(value) {
              return typeof value === 'number';
          }
          static isInteger(value) {
              return (typeof value === 'number' && (value % 1) === 0);
          }
          static isBoolean(value) {
              return value === true || value === false;
          }
          static isString(value) {
              return typeof value === 'string';
          }
          static clone(v) {
              if (Utils.isObjectLiteral(v) || Array.isArray(v)) {
                  return Utils.getDeepClone(v);
              } else {
                  return v;
              }
          }
          static cloneObjShallow(obj) {
              let keys = Object.keys(obj);
              let clone = {};
              for (let i = 0; i < keys.length; i++) {
                  clone[keys[i]] = obj[keys[i]];
              }
              return clone;
          }
          static merge(obj1, obj2) {
              let keys = Object.keys(obj2);
              for (let i = 0; i < keys.length; i++) {
                  obj1[keys[i]] = obj2[keys[i]];
              }
              return obj1;
          }
          static isObject(value) {
              let type = typeof value;
              return !!value && (type === 'object' || type === 'function');
          }
          static isPlainObject(value) {
              let type = typeof value;
              return !!value && (type === 'object');
          }
          static isObjectLiteral(value){
              return typeof value === 'object' && value && value.constructor === Object;
          }
          static getArrayIndex(index, arr) {
              return Utils.getModuloIndex(index, arr.length);
          }
          static getModuloIndex(index, len) {
              if (len === 0) return index;
              while (index < 0) {
                  index += Math.ceil(-index / len) * len;
              }
              index = index % len;
              return index;
          }
          static getDeepClone(obj) {
              let i, c;
              if (Utils.isFunction(obj)) {
                  return obj;
              }
              if (Array.isArray(obj)) {
                  c = [];
                  let keys = Object.keys(obj);
                  for (i = 0; i < keys.length; i++) {
                      c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
                  }
                  return c;
              } else if (Utils.isObject(obj)) {
                  c = {};
                  let keys = Object.keys(obj);
                  for (i = 0; i < keys.length; i++) {
                      c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
                  }
                  return c;
              } else {
                  return obj;
              }
          }
          static equalValues(v1, v2) {
              if ((typeof v1) !== (typeof v2)) return false;
              if (Utils.isObjectLiteral(v1)) {
                  return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2);
              } else if (Array.isArray(v1)) {
                  return Array.isArray(v2) && Utils.equalArrays(v1, v2);
              } else {
                  return v1 === v2;
              }
          }
          static equalObjectLiterals(obj1, obj2) {
              let keys1 = Object.keys(obj1);
              let keys2 = Object.keys(obj2);
              if (keys1.length !== keys2.length) {
                  return false;
              }
              for (let i = 0, n = keys1.length; i < n; i++) {
                  const k1 = keys1[i];
                  const k2 = keys2[i];
                  if (k1 !== k2) {
                      return false;
                  }
                  const v1 = obj1[k1];
                  const v2 = obj2[k2];
                  if (!Utils.equalValues(v1, v2)) {
                      return false;
                  }
              }
              return true;
          }
          static equalArrays(v1, v2) {
              if (v1.length !== v2.length) {
                  return false;
              }
              for (let i = 0, n = v1.length; i < n; i++) {
                  if (!this.equalValues(v1[i], v2[i])) {
                      return false;
                  }
              }
              return true;
          }
          static setToArray(s) {
              let result = [];
              s.forEach(function (value) {
                  result.push(value);
              });
              return result;
          }
          static iteratorToArray(iterator) {
              let result = [];
              let iteratorResult = iterator.next();
              while (!iteratorResult.done) {
                  result.push(iteratorResult.value);
                  iteratorResult = iterator.next();
              }
              return result;
          }
          static isUcChar(charcode) {
              return charcode >= 65 && charcode <= 90;
          }
      }
      Utils.isWeb = (typeof window !== "undefined") && (typeof sparkscene === "undefined");
      Utils.isWPE = Utils.isWeb && (navigator.userAgent.indexOf("WPE") !== -1);
      Utils.isSpark = (typeof sparkscene !== "undefined");
      Utils.isNode = (typeof window === "undefined") || Utils.isSpark;
      Utils.isPS4 = Utils.isWeb && (navigator.userAgent.indexOf("PlayStation 4") !== -1);

      class Base {
          static defaultSetter(obj, name, value) {
              obj[name] = value;
          }
          static patchObject(obj, settings) {
              if (!Utils.isObjectLiteral(settings)) {
                  console.error("[Lightning] Settings must be object literal");
              } else {
                  let names = Object.keys(settings);
                  for (let i = 0, n = names.length; i < n; i++) {
                      let name = names[i];
                      this.patchObjectProperty(obj, name, settings[name]);
                  }
              }
          }
          static patchObjectProperty(obj, name, value) {
              let setter = obj.setSetting || Base.defaultSetter;
              if (name.charAt(0) === "_") {
                  if (name !== "__create") {
                      console.error("[Lightning] Patch of private property '" + name + "' is not allowed");
                  }
              } else if (name !== "type") {
                  if (Utils.isFunction(value) && value.__local) {
                      value = value.__local(obj);
                  }
                  setter(obj, name, value);
              }
          }
          static local(func) {
              func.__local = true;
          }
      }

      class SpacingCalculator {
          static getSpacing(mode, numberOfItems, remainingSpace) {
              const itemGaps = (numberOfItems - 1);
              let spacePerGap;
              let spacingBefore, spacingBetween;
              switch(mode) {
                  case "flex-start":
                      spacingBefore = 0;
                      spacingBetween = 0;
                      break;
                  case "flex-end":
                      spacingBefore = remainingSpace;
                      spacingBetween = 0;
                      break;
                  case "center":
                      spacingBefore = remainingSpace / 2;
                      spacingBetween = 0;
                      break;
                  case "space-between":
                      spacingBefore = 0;
                      spacingBetween = Math.max(0, remainingSpace) / itemGaps;
                      break;
                  case "space-around":
                      if (remainingSpace < 0) {
                          return this.getSpacing("center", numberOfItems, remainingSpace);
                      } else {
                          spacePerGap = remainingSpace / (itemGaps + 1);
                          spacingBefore = 0.5 * spacePerGap;
                          spacingBetween = spacePerGap;
                      }
                      break;
                  case "space-evenly":
                      if (remainingSpace < 0) {
                          return this.getSpacing("center", numberOfItems, remainingSpace);
                      } else {
                          spacePerGap = remainingSpace / (itemGaps + 2);
                          spacingBefore = spacePerGap;
                          spacingBetween = spacePerGap;
                      }
                      break;
                  case "stretch":
                      spacingBefore = 0;
                      spacingBetween = 0;
                      break;
                  default:
                      throw new Error("Unknown mode: " + mode);
              }
              return {spacingBefore, spacingBetween}
          }
      }

      class ContentAligner {
          constructor(layout) {
              this._layout = layout;
              this._totalCrossAxisSize = 0;
          }
          get _lines() {
              return this._layout._lines;
          }
          init() {
              this._totalCrossAxisSize = this._getTotalCrossAxisSize();
          }
          align() {
              const crossAxisSize = this._layout.crossAxisSize;
              const remainingSpace = crossAxisSize - this._totalCrossAxisSize;
              const {spacingBefore, spacingBetween} = this._getSpacing(remainingSpace);
              const lines = this._lines;
              const mode = this._layout._flexContainer.alignContent;
              let growSize = 0;
              if (mode === "stretch" && lines.length && (remainingSpace > 0)) {
                  growSize = remainingSpace / lines.length;
              }
              let currentPos = spacingBefore;
              for (let i = 0, n = lines.length; i < n; i++) {
                  const crossAxisLayoutOffset = currentPos;
                  const aligner = lines[i].createItemAligner();
                  let finalCrossAxisLayoutSize = lines[i].crossAxisLayoutSize + growSize;
                  aligner.setCrossAxisLayoutSize(finalCrossAxisLayoutSize);
                  aligner.setCrossAxisLayoutOffset(crossAxisLayoutOffset);
                  aligner.align();
                  if (aligner.recursiveResizeOccured) {
                      lines[i].setItemPositions();
                  }
                  currentPos += finalCrossAxisLayoutSize;
                  currentPos += spacingBetween;
              }
          }
          get totalCrossAxisSize() {
              return this._totalCrossAxisSize;
          }
          _getTotalCrossAxisSize() {
              const lines = this._lines;
              let total = 0;
              for (let i = 0, n = lines.length; i < n; i++) {
                  const line = lines[i];
                  total += line.crossAxisLayoutSize;
              }
              return total;
          }
          _getSpacing(remainingSpace) {
              const mode = this._layout._flexContainer.alignContent;
              const numberOfItems = this._lines.length;
              return SpacingCalculator.getSpacing(mode, numberOfItems, remainingSpace);
          }
      }

      class FlexUtils {
          static getParentAxisSizeWithPadding(item, horizontal) {
              const target = item.target;
              const parent = target.getParent();
              if (!parent) {
                  return 0;
              } else {
                  const flexParent = item.flexParent;
                  if (flexParent) {
                      return this.getAxisLayoutSize(flexParent, horizontal) + this.getTotalPadding(flexParent, horizontal);
                  } else {
                      return horizontal ? parent.w : parent.h;
                  }
              }
          }
          static getRelAxisSize(item, horizontal) {
              if (horizontal) {
                  if (item.funcW) {
                      if (this._allowRelAxisSizeFunction(item, true)) {
                          return item.funcW(this.getParentAxisSizeWithPadding(item, true));
                      } else {
                          return 0;
                      }
                  } else {
                      return item.originalWidth;
                  }
              } else {
                  if (item.funcH) {
                      if (this._allowRelAxisSizeFunction(item, false)) {
                          return item.funcH(this.getParentAxisSizeWithPadding(item, false));
                      } else {
                          return 0;
                      }
                  } else {
                      return item.originalHeight;
                  }
              }
          }
          static _allowRelAxisSizeFunction(item, horizontal) {
              const flexParent = item.flexParent;
              if (flexParent && flexParent._flex._layout.isAxisFitToContents(horizontal)) {
                  return false;
              }
              return true;
          }
          static isZeroAxisSize(item, horizontal) {
              if (horizontal) {
                  return !item.originalWidth && !item.funcW;
              } else {
                  return !item.originalHeight && !item.funcH;
              }
          }
          static getAxisLayoutPos(item, horizontal) {
              return horizontal ? item.x : item.y;
          }
          static getAxisLayoutSize(item, horizontal) {
              return horizontal ? item.w : item.h;
          }
          static setAxisLayoutPos(item, horizontal, pos) {
              if (horizontal) {
                  item.x = pos;
              } else {
                  item.y = pos;
              }
          }
          static setAxisLayoutSize(item, horizontal, size) {
              if (horizontal) {
                  item.w = size;
              } else {
                  item.h = size;
              }
          }
          static getAxisMinSize(item, horizontal) {
              let minSize = this.getPlainAxisMinSize(item, horizontal);
              let flexItemMinSize = 0;
              if (item.isFlexItemEnabled()) {
                  flexItemMinSize = item._flexItem._getMinSizeSetting(horizontal);
              }
              const hasLimitedMinSize = (flexItemMinSize > 0);
              if (hasLimitedMinSize) {
                  minSize = Math.max(minSize, flexItemMinSize);
              }
              return minSize;
          }
          static getPlainAxisMinSize(item, horizontal) {
              if (item.isFlexEnabled()) {
                  return item._flex._layout.getAxisMinSize(horizontal);
              } else {
                  const isShrinkable = (item.flexItem.shrink !== 0);
                  if (isShrinkable) {
                      return 0;
                  } else {
                      return this.getRelAxisSize(item, horizontal);
                  }
              }
          }
          static resizeAxis(item, horizontal, size) {
              if (item.isFlexEnabled()) {
                  const isMainAxis = (item._flex._horizontal === horizontal);
                  if (isMainAxis) {
                      item._flex._layout.resizeMainAxis(size);
                  } else {
                      item._flex._layout.resizeCrossAxis(size);
                  }
              } else {
                  this.setAxisLayoutSize(item, horizontal, size);
              }
          }
          static getPaddingOffset(item, horizontal) {
              if (item.isFlexEnabled()) {
                  const flex = item._flex;
                  if (horizontal) {
                      return flex.paddingLeft;
                  } else {
                      return flex.paddingTop;
                  }
              } else {
                  return 0;
              }
          }
          static getTotalPadding(item, horizontal) {
              if (item.isFlexEnabled()) {
                  const flex = item._flex;
                  if (horizontal) {
                      return flex.paddingRight + flex.paddingLeft;
                  } else {
                      return flex.paddingTop + flex.paddingBottom;
                  }
              } else {
                  return 0;
              }
          }
          static getMarginOffset(item, horizontal) {
              const flexItem = item.flexItem;
              if (flexItem) {
                  if (horizontal) {
                      return flexItem.marginLeft;
                  } else {
                      return flexItem.marginTop;
                  }
              } else {
                  return 0;
              }
          }
          static getTotalMargin(item, horizontal) {
              const flexItem = item.flexItem;
              if (flexItem) {
                  if (horizontal) {
                      return flexItem.marginRight + flexItem.marginLeft;
                  } else {
                      return flexItem.marginTop + flexItem.marginBottom;
                  }
              } else {
                  return 0;
              }
          }
      }

      class SizeShrinker {
          constructor(line) {
              this._line = line;
              this._amountRemaining = 0;
              this._shrunkSize = 0;
          }
          shrink(amount) {
              this._shrunkSize = 0;
              this._amountRemaining = amount;
              let totalShrinkAmount = this._getTotalShrinkAmount();
              if (totalShrinkAmount) {
                  const items = this._line.items;
                  do {
                      let amountPerShrink = this._amountRemaining / totalShrinkAmount;
                      for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                          const item = items[i];
                          const flexItem = item.flexItem;
                          const shrinkAmount = flexItem.shrink;
                          const isShrinkableItem = (shrinkAmount > 0);
                          if (isShrinkableItem) {
                              let shrink = shrinkAmount * amountPerShrink;
                              const minSize = flexItem._getMainAxisMinSize();
                              const size = flexItem._getMainAxisLayoutSize();
                              if (size > minSize) {
                                  const maxShrink = size - minSize;
                                  const isFullyShrunk = (shrink >= maxShrink);
                                  if (isFullyShrunk) {
                                      shrink = maxShrink;
                                      totalShrinkAmount -= shrinkAmount;
                                  }
                                  const finalSize = size - shrink;
                                  flexItem._resizeMainAxis(finalSize);
                                  this._shrunkSize += shrink;
                                  this._amountRemaining -= shrink;
                                  if (Math.abs(this._amountRemaining) < 10e-6) {
                                      return;
                                  }
                              }
                          }
                      }
                  } while(totalShrinkAmount && (Math.abs(this._amountRemaining) > 10e-6));
              }
          }
          _getTotalShrinkAmount() {
              let total = 0;
              const items = this._line.items;
              for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                  const item = items[i];
                  const flexItem = item.flexItem;
                  if (flexItem.shrink) {
                      const minSize = flexItem._getMainAxisMinSize();
                      const size = flexItem._getMainAxisLayoutSize();
                      if (size > minSize) {
                          total += flexItem.shrink;
                      }
                  }
              }
              return total;
          }
          getShrunkSize() {
              return this._shrunkSize;
          }
      }

      class SizeGrower {
          constructor(line) {
              this._line = line;
              this._amountRemaining = 0;
              this._grownSize = 0;
          }
          grow(amount) {
              this._grownSize = 0;
              this._amountRemaining = amount;
              let totalGrowAmount = this._getTotalGrowAmount();
              if (totalGrowAmount) {
                  const items = this._line.items;
                  do {
                      let amountPerGrow = this._amountRemaining / totalGrowAmount;
                      for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                          const item = items[i];
                          const flexItem = item.flexItem;
                          const growAmount = flexItem.grow;
                          const isGrowableItem = (growAmount > 0);
                          if (isGrowableItem) {
                              let grow = growAmount * amountPerGrow;
                              const maxSize = flexItem._getMainAxisMaxSizeSetting();
                              const size = flexItem._getMainAxisLayoutSize();
                              if (maxSize > 0) {
                                  if (size >= maxSize) {
                                      grow = 0;
                                  } else {
                                      const maxGrow = maxSize - size;
                                      const isFullyGrown = (grow >= maxGrow);
                                      if (isFullyGrown) {
                                          grow = maxGrow;
                                          totalGrowAmount -= growAmount;
                                      }
                                  }
                              }
                              if (grow > 0) {
                                  const finalSize = size + grow;
                                  flexItem._resizeMainAxis(finalSize);
                                  this._grownSize += grow;
                                  this._amountRemaining -= grow;
                                  if (Math.abs(this._amountRemaining) < 10e-6) {
                                      return;
                                  }
                              }
                          }
                      }
                  } while(totalGrowAmount && (Math.abs(this._amountRemaining) > 10e-6));
              }
          }
          _getTotalGrowAmount() {
              let total = 0;
              const items = this._line.items;
              for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                  const item = items[i];
                  const flexItem = item.flexItem;
                  if (flexItem.grow) {
                      const maxSize = flexItem._getMainAxisMaxSizeSetting();
                      const size = flexItem._getMainAxisLayoutSize();
                      if (maxSize === 0 || size < maxSize) {
                          total += flexItem.grow;
                      }
                  }
              }
              return total;
          }
          getGrownSize() {
              return this._grownSize;
          }
      }

      class ItemPositioner {
          constructor(lineLayout) {
              this._line = lineLayout;
          }
          get _layout() {
              return this._line._layout;
          }
          position() {
              const {spacingBefore, spacingBetween} = this._getSpacing();
              let currentPos = spacingBefore;
              const items = this._line.items;
              for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                  const item = items[i];
                  item.flexItem._setMainAxisLayoutPos(currentPos);
                  currentPos += item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
                  currentPos += spacingBetween;
              }
          }
          _getSpacing() {
              const remainingSpace = this._line._availableSpace;
              let mode = this._layout._flexContainer.justifyContent;
              const numberOfItems = this._line.numberOfItems;
              return SpacingCalculator.getSpacing(mode, numberOfItems, remainingSpace);
          }
      }

      class ItemAligner {
          constructor(line) {
              this._line = line;
              this._crossAxisLayoutSize = 0;
              this._crossAxisLayoutOffset = 0;
              this._alignItemsSetting = null;
              this._recursiveResizeOccured = false;
              this._isCrossAxisFitToContents = false;
          }
          get _layout() {
              return this._line._layout;
          }
          get _flexContainer() {
              return this._layout._flexContainer;
          }
          setCrossAxisLayoutSize(size) {
              this._crossAxisLayoutSize = size;
          }
          setCrossAxisLayoutOffset(offset) {
              this._crossAxisLayoutOffset = offset;
          }
          align() {
              this._alignItemsSetting = this._flexContainer.alignItems;
              this._isCrossAxisFitToContents = this._layout.isAxisFitToContents(!this._flexContainer._horizontal);
              this._recursiveResizeOccured = false;
              const items = this._line.items;
              for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                  const item = items[i];
                  this._alignItem(item);
              }
          }
          get recursiveResizeOccured() {
              return this._recursiveResizeOccured;
          }
          _alignItem(item) {
              const flexItem = item.flexItem;
              let align = flexItem.alignSelf || this._alignItemsSetting;
              if (align === "stretch" && this._preventStretch(flexItem)) {
                  align = "flex-start";
              }
              if (align !== "stretch" && !this._isCrossAxisFitToContents) {
                  if (flexItem._hasRelCrossAxisSize()) {
                      flexItem._resetCrossAxisLayoutSize();
                  }
              }
              switch(align) {
                  case "flex-start":
                      this._alignItemFlexStart(flexItem);
                      break;
                  case "flex-end":
                      this._alignItemFlexEnd(flexItem);
                      break;
                  case "center":
                      this._alignItemFlexCenter(flexItem);
                      break;
                  case "stretch":
                      this._alignItemStretch(flexItem);
                      break;
              }
          }
          _alignItemFlexStart(flexItem) {
              flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
          }
          _alignItemFlexEnd(flexItem) {
              const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
              flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + (this._crossAxisLayoutSize - itemCrossAxisSize));
          }
          _alignItemFlexCenter(flexItem) {
              const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
              const center = (this._crossAxisLayoutSize - itemCrossAxisSize) / 2;
              flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + center);
          }
          _alignItemStretch(flexItem) {
              flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
              const mainAxisLayoutSizeBeforeResize = flexItem._getMainAxisLayoutSize();
              let size = this._crossAxisLayoutSize - flexItem._getCrossAxisMargin() - flexItem._getCrossAxisPadding();
              const crossAxisMinSizeSetting = flexItem._getCrossAxisMinSizeSetting();
              if (crossAxisMinSizeSetting > 0) {
                  size = Math.max(size, crossAxisMinSizeSetting);
              }
              const crossAxisMaxSizeSetting = flexItem._getCrossAxisMaxSizeSetting();
              const crossAxisMaxSizeSettingEnabled = (crossAxisMaxSizeSetting > 0);
              if (crossAxisMaxSizeSettingEnabled) {
                  size = Math.min(size, crossAxisMaxSizeSetting);
              }
              flexItem._resizeCrossAxis(size);
              const mainAxisLayoutSizeAfterResize = flexItem._getMainAxisLayoutSize();
              const recursiveResize = (mainAxisLayoutSizeAfterResize !== mainAxisLayoutSizeBeforeResize);
              if (recursiveResize) {
                  this._recursiveResizeOccured = true;
              }
          }
          _preventStretch(flexItem) {
              const hasFixedCrossAxisSize = flexItem._hasFixedCrossAxisSize();
              const forceStretch = (flexItem.alignSelf === "stretch");
              return hasFixedCrossAxisSize && !forceStretch;
          }
      }

      class LineLayout {
          constructor(layout, startIndex, endIndex, availableSpace) {
              this._layout = layout;
              this.items = layout.items;
              this.startIndex = startIndex;
              this.endIndex = endIndex;
              this._availableSpace = availableSpace;
          }
          performLayout() {
              this._setItemSizes();
              this.setItemPositions();
              this._calcLayoutInfo();
          }
          _setItemSizes() {
              if (this._availableSpace > 0) {
                  this._growItemSizes(this._availableSpace);
              } else if (this._availableSpace < 0) {
                  this._shrinkItemSizes(-this._availableSpace);
              }
          }
          _growItemSizes(amount) {
              const grower = new SizeGrower(this);
              grower.grow(amount);
              this._availableSpace -= grower.getGrownSize();
          }
          _shrinkItemSizes(amount) {
              const shrinker = new SizeShrinker(this);
              shrinker.shrink(amount);
              this._availableSpace += shrinker.getShrunkSize();
          }
          setItemPositions() {
              const positioner = new ItemPositioner(this);
              positioner.position();
          }
          createItemAligner() {
              return new ItemAligner(this);
          }
          _calcLayoutInfo() {
              this._calcCrossAxisMaxLayoutSize();
          }
          getMainAxisMinSize() {
              let mainAxisMinSize = 0;
              for (let i = this.startIndex; i <= this.endIndex; i++) {
                  const item = this.items[i];
                  mainAxisMinSize += item.flexItem._getMainAxisMinSizeWithPaddingAndMargin();
              }
              return mainAxisMinSize;
          }
          get numberOfItems() {
              return this.endIndex - this.startIndex + 1;
          }
          get crossAxisLayoutSize() {
              const noSpecifiedCrossAxisSize = (this._layout.isCrossAxisFitToContents() && !this._layout.resizingCrossAxis);
              const shouldFitToContents = (this._layout.isWrapping() || noSpecifiedCrossAxisSize);
              if (shouldFitToContents) {
                  return this._crossAxisMaxLayoutSize;
              } else {
                  return this._layout.crossAxisSize;
              }
          }
          _calcCrossAxisMaxLayoutSize() {
              this._crossAxisMaxLayoutSize = this._getCrossAxisMaxLayoutSize();
          }
          _getCrossAxisMaxLayoutSize() {
              let crossAxisMaxSize = 0;
              for (let i = this.startIndex; i <= this.endIndex; i++) {
                  const item = this.items[i];
                  crossAxisMaxSize = Math.max(crossAxisMaxSize, item.flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin());
              }
              return crossAxisMaxSize;
          }
      }

      class LineLayouter {
          constructor(layout) {
              this._layout = layout;
              this._mainAxisMinSize = -1;
              this._crossAxisMinSize = -1;
              this._mainAxisContentSize = 0;
          }
          get lines() {
              return this._lines;
          }
          get mainAxisMinSize() {
              if (this._mainAxisMinSize === -1) {
                  this._mainAxisMinSize = this._getMainAxisMinSize();
              }
              return this._mainAxisMinSize;
          }
          get crossAxisMinSize() {
              if (this._crossAxisMinSize === -1) {
                  this._crossAxisMinSize = this._getCrossAxisMinSize();
              }
              return this._crossAxisMinSize;
          }
          get mainAxisContentSize() {
              return this._mainAxisContentSize;
          }
          layoutLines() {
              this._setup();
              const items = this._layout.items;
              const wrap = this._layout.isWrapping();
              let startIndex = 0;
              let i;
              const n = items.length;
              for (i = 0; i < n; i++) {
                  const item = items[i];
                  this._layoutFlexItem(item);
                  const itemMainAxisSize = item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
                  if (wrap && (i > startIndex)) {
                      const isOverflowing = (this._curMainAxisPos + itemMainAxisSize > this._mainAxisSize);
                      if (isOverflowing) {
                          this._layoutLine(startIndex, i - 1);
                          this._curMainAxisPos = 0;
                          startIndex = i;
                      }
                  }
                  this._addToMainAxisPos(itemMainAxisSize);
              }
              if (startIndex < i) {
                  this._layoutLine(startIndex, i - 1);
              }
          }
          _layoutFlexItem(item) {
              if (item.isFlexEnabled()) {
                  item.flexLayout.updateTreeLayout();
              } else {
                  item.flexItem._resetLayoutSize();
              }
          }
          _setup() {
              this._mainAxisSize = this._layout.mainAxisSize;
              this._curMainAxisPos = 0;
              this._maxMainAxisPos = 0;
              this._lines = [];
              this._mainAxisMinSize = -1;
              this._crossAxisMinSize = -1;
              this._mainAxisContentSize = 0;
          }
          _addToMainAxisPos(itemMainAxisSize) {
              this._curMainAxisPos += itemMainAxisSize;
              if (this._curMainAxisPos > this._maxMainAxisPos) {
                  this._maxMainAxisPos = this._curMainAxisPos;
              }
          }
          _layoutLine(startIndex, endIndex) {
              const availableSpace = this._getAvailableMainAxisLayoutSpace();
              const line = new LineLayout(this._layout, startIndex, endIndex, availableSpace);
              line.performLayout();
              this._lines.push(line);
              if (this._mainAxisContentSize === 0 || (this._curMainAxisPos > this._mainAxisContentSize)) {
                  this._mainAxisContentSize = this._curMainAxisPos;
              }
          }
          _getAvailableMainAxisLayoutSpace() {
              if (!this._layout.resizingMainAxis && this._layout.isMainAxisFitToContents()) {
                  return 0;
              } else {
                  return this._mainAxisSize - this._curMainAxisPos;
              }
          }
          _getCrossAxisMinSize() {
              let crossAxisMinSize = 0;
              const items = this._layout.items;
              for (let i = 0, n = items.length; i < n; i++) {
                  const item = items[i];
                  const itemCrossAxisMinSize = item.flexItem._getCrossAxisMinSizeWithPaddingAndMargin();
                  crossAxisMinSize = Math.max(crossAxisMinSize, itemCrossAxisMinSize);
              }
              return crossAxisMinSize;
          }
          _getMainAxisMinSize() {
              if (this._lines.length === 1) {
                  return this._lines[0].getMainAxisMinSize();
              } else {
                  return this._layout.mainAxisSize;
              }
          }
      }

      class ItemCoordinatesUpdater {
          constructor(layout) {
              this._layout = layout;
              this._isReverse = this._flexContainer._reverse;
              this._horizontalPaddingOffset = this._layout._getHorizontalPaddingOffset();
              this._verticalPaddingOffset = this._layout._getVerticalPaddingOffset();
          }
          get _flexContainer() {
              return this._layout._flexContainer;
          }
          finalize() {
              const parentFlex = this._layout.getParentFlexContainer();
              if (parentFlex) {
                  const updater = new ItemCoordinatesUpdater(parentFlex._layout);
                  updater._finalizeItemAndChildren(this._flexContainer.item);
              } else {
                  this._finalizeRoot();
                  this._finalizeItems();
              }
          }
          _finalizeRoot() {
              const item = this._flexContainer.item;
              let x = FlexUtils.getAxisLayoutPos(item, true);
              let y = FlexUtils.getAxisLayoutPos(item, false);
              let w = FlexUtils.getAxisLayoutSize(item, true);
              let h = FlexUtils.getAxisLayoutSize(item, false);
              w += this._layout._getHorizontalPadding();
              h += this._layout._getVerticalPadding();
              item.clearRecalcFlag();
              item.setLayout(x, y, w, h);
          }
          _finalizeItems() {
              const items = this._layout.items;
              for (let i = 0, n = items.length; i < n; i++) {
                  const item = items[i];
                  const validCache = this._validateItemCache(item);
                  this._finalizeItem(item);
                  if (!validCache) {
                      this._finalizeItemChildren(item);
                  }
              }
          }
          _validateItemCache(item) {
              if (item.recalc === 0) {
                  if (item.isFlexEnabled()) {
                      const layout = item._flex._layout;
                      const dimensionsMatchPreviousResult = (item.w === item.target.w && item.h === item.target.h);
                      if (dimensionsMatchPreviousResult) {
                          return true;
                      } else {
                          const crossAxisSize = layout.crossAxisSize;
                          layout.performResizeMainAxis(layout.mainAxisSize);
                          layout.performResizeCrossAxis(crossAxisSize);
                      }
                  }
              }
              return false;
          }
          _finalizeItemAndChildren(item) {
              this._finalizeItem(item);
              this._finalizeItemChildren(item);
          }
          _finalizeItem(item) {
              if (this._isReverse) {
                  this._reverseMainAxisLayoutPos(item);
              }
              let x = FlexUtils.getAxisLayoutPos(item, true);
              let y = FlexUtils.getAxisLayoutPos(item, false);
              let w = FlexUtils.getAxisLayoutSize(item, true);
              let h = FlexUtils.getAxisLayoutSize(item, false);
              x += this._horizontalPaddingOffset;
              y += this._verticalPaddingOffset;
              const flex = item.flex;
              if (flex) {
                  w += item._flex._layout._getHorizontalPadding();
                  h += item._flex._layout._getVerticalPadding();
              }
              const flexItem = item.flexItem;
              if (flexItem) {
                  x += flexItem._getHorizontalMarginOffset();
                  y += flexItem._getVerticalMarginOffset();
              }
              item.clearRecalcFlag();
              item.setLayout(x, y, w, h);
          }
          _finalizeItemChildren(item) {
              const flex = item._flex;
              if (flex) {
                  const updater = new ItemCoordinatesUpdater(flex._layout);
                  updater._finalizeItems();
              }
          }
          _reverseMainAxisLayoutPos(item) {
              const endPos = (item.flexItem._getMainAxisLayoutPos() + item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin());
              const reversedPos = this._layout.mainAxisSize - endPos;
              item.flexItem._setMainAxisLayoutPos(reversedPos);
          }
      }

      class FlexLayout {
          constructor(flexContainer) {
              this._flexContainer = flexContainer;
              this._lineLayouter = new LineLayouter(this);
              this._resizingMainAxis = false;
              this._resizingCrossAxis = false;
              this._cachedMainAxisSizeAfterLayout = 0;
              this._cachedCrossAxisSizeAfterLayout = 0;
              this._shrunk = false;
          }
          get shrunk() {
              return this._shrunk;
          }
          get recalc() {
              return this.item.recalc;
          }
          layoutTree() {
              const isSubTree = (this.item.flexParent !== null);
              if (isSubTree) {
                  this._updateSubTreeLayout();
              } else {
                  this.updateTreeLayout();
              }
              this.updateItemCoords();
          }
          updateTreeLayout() {
              if (this.recalc) {
                  this._performUpdateLayoutTree();
              } else {
                  this._performUpdateLayoutTreeFromCache();
              }
          }
          _performUpdateLayoutTree() {
              this._setInitialAxisSizes();
              this._layoutAxes();
              this._refreshLayoutCache();
          }
          _refreshLayoutCache() {
              this._cachedMainAxisSizeAfterLayout = this.mainAxisSize;
              this._cachedCrossAxisSizeAfterLayout = this.crossAxisSize;
          }
          _performUpdateLayoutTreeFromCache() {
              const sizeMightHaveChanged = (this.item.funcW || this.item.funcH);
              if (sizeMightHaveChanged) {
                  this.item.enableLocalRecalcFlag();
                  this._performUpdateLayoutTree();
              } else {
                  this.mainAxisSize = this._cachedMainAxisSizeAfterLayout;
                  this.crossAxisSize = this._cachedCrossAxisSizeAfterLayout;
              }
          }
          updateItemCoords() {
              const updater = new ItemCoordinatesUpdater(this);
              updater.finalize();
          }
          _updateSubTreeLayout() {
              const crossAxisSize = this.crossAxisSize;
              this._layoutMainAxis();
              this.performResizeCrossAxis(crossAxisSize);
          }
          _setInitialAxisSizes() {
              if (this.item.isFlexItemEnabled()) {
                  this.item.flexItem._resetLayoutSize();
              } else {
                  this.mainAxisSize = this._getMainAxisBasis();
                  this.crossAxisSize = this._getCrossAxisBasis();
              }
              this._resizingMainAxis = false;
              this._resizingCrossAxis = false;
              this._shrunk = false;
          }
          _layoutAxes() {
              this._layoutMainAxis();
              this._layoutCrossAxis();
          }
          _layoutMainAxis() {
              this._layoutLines();
              this._fitMainAxisSizeToContents();
          }
          _layoutLines() {
              this._lineLayouter.layoutLines();
          }
          get _lines() {
              return this._lineLayouter.lines;
          }
          _fitMainAxisSizeToContents() {
              if (!this._resizingMainAxis) {
                  if (this.isMainAxisFitToContents()) {
                      this.mainAxisSize = this._lineLayouter.mainAxisContentSize;
                  }
              }
          }
          _layoutCrossAxis() {
              const aligner = new ContentAligner(this);
              aligner.init();
              this._totalCrossAxisSize = aligner.totalCrossAxisSize;
              this._fitCrossAxisSizeToContents();
              aligner.align();
          }
          _fitCrossAxisSizeToContents() {
              if (!this._resizingCrossAxis) {
                  if (this.isCrossAxisFitToContents()) {
                      this.crossAxisSize = this._totalCrossAxisSize;
                  }
              }
          }
          isWrapping() {
              return this._flexContainer.wrap;
          }
          isAxisFitToContents(horizontal) {
              if (this._horizontal === horizontal) {
                  return this.isMainAxisFitToContents();
              } else {
                  return this.isCrossAxisFitToContents();
              }
          }
          isMainAxisFitToContents() {
              return !this.isWrapping() && !this._hasFixedMainAxisBasis();
          }
          isCrossAxisFitToContents() {
              return !this._hasFixedCrossAxisBasis();
          }
          _hasFixedMainAxisBasis() {
              return !FlexUtils.isZeroAxisSize(this.item, this._horizontal);
          }
          _hasFixedCrossAxisBasis() {
              return !FlexUtils.isZeroAxisSize(this.item, !this._horizontal);
          }
          getAxisMinSize(horizontal) {
              if (this._horizontal === horizontal) {
                  return this._getMainAxisMinSize();
              } else {
                  return this._getCrossAxisMinSize();
              }
          }
          _getMainAxisMinSize() {
              return this._lineLayouter.mainAxisMinSize;
          }
          _getCrossAxisMinSize() {
              return this._lineLayouter.crossAxisMinSize;
          }
          resizeMainAxis(size) {
              if (this.mainAxisSize !== size) {
                  if (this.recalc > 0) {
                      this.performResizeMainAxis(size);
                  } else {
                      if (this._checkValidCacheMainAxisResize()) {
                          this.mainAxisSize = size;
                          this._fitCrossAxisSizeToContents();
                      } else {
                          this.item.enableLocalRecalcFlag();
                          this.performResizeMainAxis(size);
                      }
                  }
              }
          }
          _checkValidCacheMainAxisResize(size) {
              const isFinalMainAxisSize = (size === this.targetMainAxisSize);
              if (isFinalMainAxisSize) {
                  return true;
              }
              const canIgnoreCacheMiss = !this.isCrossAxisFitToContents();
              if (canIgnoreCacheMiss) {
                  return true;
              }
              return false;
          }
          performResizeMainAxis(size) {
              const isShrinking = (size < this.mainAxisSize);
              this._shrunk = isShrinking;
              this.mainAxisSize = size;
              this._resizingMainAxis = true;
              this._layoutAxes();
              this._resizingMainAxis = false;
          }
          resizeCrossAxis(size) {
              if (this.crossAxisSize !== size) {
                  if (this.recalc > 0) {
                      this.performResizeCrossAxis(size);
                  } else {
                      this.crossAxisSize = size;
                  }
              }
          }
          performResizeCrossAxis(size) {
              this.crossAxisSize = size;
              this._resizingCrossAxis = true;
              this._layoutCrossAxis();
              this._resizingCrossAxis = false;
          }
          get targetMainAxisSize() {
              return this._horizontal ? this.item.target.w : this.item.target.h;
          }
          get targetCrossAxisSize() {
              return this._horizontal ? this.item.target.h : this.item.target.w;
          }
          getParentFlexContainer() {
              return this.item.isFlexItemEnabled() ? this.item.flexItem.ctr : null;
          }
          _getHorizontalPadding() {
              return FlexUtils.getTotalPadding(this.item, true);
          }
          _getVerticalPadding() {
              return FlexUtils.getTotalPadding(this.item, false);
          }
          _getHorizontalPaddingOffset() {
              return FlexUtils.getPaddingOffset(this.item, true);
          }
          _getVerticalPaddingOffset() {
              return FlexUtils.getPaddingOffset(this.item, false);
          }
          _getMainAxisBasis() {
              return FlexUtils.getRelAxisSize(this.item, this._horizontal);
          }
          _getCrossAxisBasis() {
              return FlexUtils.getRelAxisSize(this.item, !this._horizontal);
          }
          get _horizontal() {
              return this._flexContainer._horizontal;
          }
          get _reverse() {
              return this._flexContainer._reverse;
          }
          get item() {
              return this._flexContainer.item;
          }
          get items() {
              return this.item.items;
          }
          get resizingMainAxis() {
              return this._resizingMainAxis;
          }
          get resizingCrossAxis() {
              return this._resizingCrossAxis;
          }
          get numberOfItems() {
              return this.items.length;
          }
          get mainAxisSize() {
              return FlexUtils.getAxisLayoutSize(this.item, this._horizontal);
          }
          get crossAxisSize() {
              return FlexUtils.getAxisLayoutSize(this.item, !this._horizontal);
          }
          set mainAxisSize(v) {
              FlexUtils.setAxisLayoutSize(this.item, this._horizontal, v);
          }
          set crossAxisSize(v) {
              FlexUtils.setAxisLayoutSize(this.item, !this._horizontal, v);
          }
      }

      class FlexContainer {
          constructor(item) {
              this._item = item;
              this._layout = new FlexLayout(this);
              this._horizontal = true;
              this._reverse = false;
              this._wrap = false;
              this._alignItems = 'stretch';
              this._justifyContent = 'flex-start';
              this._alignContent = 'flex-start';
              this._paddingLeft = 0;
              this._paddingTop = 0;
              this._paddingRight = 0;
              this._paddingBottom = 0;
          }
          get item() {
              return this._item;
          }
          _changedDimensions() {
              this._item.changedDimensions();
          }
          _changedContents() {
              this._item.changedContents();
          }
          get direction() {
              return (this._horizontal ? "row" : "column") + (this._reverse ? "-reverse" : "");
          }
          set direction(f) {
              if (this.direction === f) return;
              this._horizontal = (f === 'row' || f === 'row-reverse');
              this._reverse = (f === 'row-reverse' || f === 'column-reverse');
              this._changedContents();
          }
          set wrap(v) {
              this._wrap = v;
              this._changedContents();
          }
          get wrap() {
              return this._wrap;
          }
          get alignItems() {
              return this._alignItems;
          }
          set alignItems(v) {
              if (this._alignItems === v) return;
              if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
                  throw new Error("Unknown alignItems, options: " + FlexContainer.ALIGN_ITEMS.join(","));
              }
              this._alignItems = v;
              this._changedContents();
          }
          get alignContent() {
              return this._alignContent;
          }
          set alignContent(v) {
              if (this._alignContent === v) return;
              if (FlexContainer.ALIGN_CONTENT.indexOf(v) === -1) {
                  throw new Error("Unknown alignContent, options: " + FlexContainer.ALIGN_CONTENT.join(","));
              }
              this._alignContent = v;
              this._changedContents();
          }
          get justifyContent() {
              return this._justifyContent;
          }
          set justifyContent(v) {
              if (this._justifyContent === v) return;
              if (FlexContainer.JUSTIFY_CONTENT.indexOf(v) === -1) {
                  throw new Error("Unknown justifyContent, options: " + FlexContainer.JUSTIFY_CONTENT.join(","));
              }
              this._justifyContent = v;
              this._changedContents();
          }
          set padding(v) {
              this.paddingLeft = v;
              this.paddingTop = v;
              this.paddingRight = v;
              this.paddingBottom = v;
          }
          get padding() {
              return this.paddingLeft;
          }
          set paddingLeft(v) {
              this._paddingLeft = v;
              this._changedDimensions();
          }
          get paddingLeft() {
              return this._paddingLeft;
          }
          set paddingTop(v) {
              this._paddingTop = v;
              this._changedDimensions();
          }
          get paddingTop() {
              return this._paddingTop;
          }
          set paddingRight(v) {
              this._paddingRight = v;
              this._changedDimensions();
          }
          get paddingRight() {
              return this._paddingRight;
          }
          set paddingBottom(v) {
              this._paddingBottom = v;
              this._changedDimensions();
          }
          get paddingBottom() {
              return this._paddingBottom;
          }
          patch(settings) {
              Base.patchObject(this, settings);
          }
      }
      FlexContainer.ALIGN_ITEMS = ["flex-start", "flex-end", "center", "stretch"];
      FlexContainer.ALIGN_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly", "stretch"];
      FlexContainer.JUSTIFY_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly"];

      class FlexItem {
          constructor(item) {
              this._ctr = null;
              this._item = item;
              this._grow = 0;
              this._shrink = FlexItem.SHRINK_AUTO;
              this._alignSelf = undefined;
              this._minWidth = 0;
              this._minHeight = 0;
              this._maxWidth = 0;
              this._maxHeight = 0;
              this._marginLeft = 0;
              this._marginTop = 0;
              this._marginRight = 0;
              this._marginBottom = 0;
          }
          get item() {
              return this._item;
          }
          get grow() {
              return this._grow;
          }
          set grow(v) {
              if (this._grow === v) return;
              this._grow = parseInt(v) || 0;
              this._changed();
          }
          get shrink() {
              if (this._shrink === FlexItem.SHRINK_AUTO) {
                  return this._getDefaultShrink();
              }
              return this._shrink;
          }
          _getDefaultShrink() {
              if (this.item.isFlexEnabled()) {
                  return 1;
              } else {
                  return 0;
              }
          }
          set shrink(v) {
              if (this._shrink === v) return;
              this._shrink = parseInt(v) || 0;
              this._changed();
          }
          get alignSelf() {
              return this._alignSelf;
          }
          set alignSelf(v) {
              if (this._alignSelf === v) return;
              if (v === undefined) {
                  this._alignSelf = undefined;
              } else {
                  if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
                      throw new Error("Unknown alignSelf, options: " + FlexContainer.ALIGN_ITEMS.join(","));
                  }
                  this._alignSelf = v;
              }
              this._changed();
          }
          get minWidth() {
              return this._minWidth;
          }
          set minWidth(v) {
              this._minWidth = Math.max(0, v);
              this._item.changedDimensions(true, false);
          }
          get minHeight() {
              return this._minHeight;
          }
          set minHeight(v) {
              this._minHeight = Math.max(0, v);
              this._item.changedDimensions(false, true);
          }
          get maxWidth() {
              return this._maxWidth;
          }
          set maxWidth(v) {
              this._maxWidth = Math.max(0, v);
              this._item.changedDimensions(true, false);
          }
          get maxHeight() {
              return this._maxHeight;
          }
          set maxHeight(v) {
              this._maxHeight = Math.max(0, v);
              this._item.changedDimensions(false, true);
          }
          set margin(v) {
              this.marginLeft = v;
              this.marginTop = v;
              this.marginRight = v;
              this.marginBottom = v;
          }
          get margin() {
              return this.marginLeft;
          }
          set marginLeft(v) {
              this._marginLeft = v;
              this._changed();
          }
          get marginLeft() {
              return this._marginLeft;
          }
          set marginTop(v) {
              this._marginTop = v;
              this._changed();
          }
          get marginTop() {
              return this._marginTop;
          }
          set marginRight(v) {
              this._marginRight = v;
              this._changed();
          }
          get marginRight() {
              return this._marginRight;
          }
          set marginBottom(v) {
              this._marginBottom = v;
              this._changed();
          }
          get marginBottom() {
              return this._marginBottom;
          }
          _changed() {
              if (this.ctr) this.ctr._changedContents();
          }
          set ctr(v) {
              this._ctr = v;
          }
          get ctr() {
              return this._ctr;
          }
          patch(settings) {
              Base.patchObject(this, settings);
          }
          _resetLayoutSize() {
              this._resetHorizontalAxisLayoutSize();
              this._resetVerticalAxisLayoutSize();
          }
          _resetCrossAxisLayoutSize() {
              if (this.ctr._horizontal) {
                  this._resetVerticalAxisLayoutSize();
              } else {
                  this._resetHorizontalAxisLayoutSize();
              }
          }
          _resetHorizontalAxisLayoutSize() {
              let w = FlexUtils.getRelAxisSize(this.item, true);
              if (this._minWidth) {
                  w = Math.max(this._minWidth, w);
              }
              if (this._maxWidth) {
                  w = Math.min(this._maxWidth, w);
              }
              FlexUtils.setAxisLayoutSize(this.item, true, w);
          }
          _resetVerticalAxisLayoutSize() {
              let h = FlexUtils.getRelAxisSize(this.item, false);
              if (this._minHeight) {
                  h = Math.max(this._minHeight, h);
              }
              if (this._maxHeight) {
                  h = Math.min(this._maxHeight, h);
              }
              FlexUtils.setAxisLayoutSize(this.item, false, h);
          }
          _getCrossAxisMinSizeSetting() {
              return this._getMinSizeSetting(!this.ctr._horizontal);
          }
          _getCrossAxisMaxSizeSetting() {
              return this._getMaxSizeSetting(!this.ctr._horizontal);
          }
          _getMainAxisMaxSizeSetting() {
              return this._getMaxSizeSetting(this.ctr._horizontal);
          }
          _getMinSizeSetting(horizontal) {
              if (horizontal) {
                  return this._minWidth;
              } else {
                  return this._minHeight;
              }
          }
          _getMaxSizeSetting(horizontal) {
              if (horizontal) {
                  return this._maxWidth;
              } else {
                  return this._maxHeight;
              }
          }
          _getMainAxisMinSize() {
              return FlexUtils.getAxisMinSize(this.item, this.ctr._horizontal);
          }
          _getCrossAxisMinSize() {
              return FlexUtils.getAxisMinSize(this.item, !this.ctr._horizontal);
          }
          _getMainAxisLayoutSize() {
              return FlexUtils.getAxisLayoutSize(this.item, this.ctr._horizontal);
          }
          _getMainAxisLayoutPos() {
              return FlexUtils.getAxisLayoutPos(this.item, this.ctr._horizontal);
          }
          _setMainAxisLayoutPos(pos) {
              return FlexUtils.setAxisLayoutPos(this.item, this.ctr._horizontal, pos);
          }
          _setCrossAxisLayoutPos(pos) {
              return FlexUtils.setAxisLayoutPos(this.item, !this.ctr._horizontal, pos);
          }
          _getCrossAxisLayoutSize() {
              return FlexUtils.getAxisLayoutSize(this.item, !this.ctr._horizontal);
          }
          _resizeCrossAxis(size) {
              return FlexUtils.resizeAxis(this.item, !this.ctr._horizontal, size);
          }
          _resizeMainAxis(size) {
              return FlexUtils.resizeAxis(this.item, this.ctr._horizontal, size);
          }
          _getMainAxisPadding() {
              return FlexUtils.getTotalPadding(this.item, this.ctr._horizontal);
          }
          _getCrossAxisPadding() {
              return FlexUtils.getTotalPadding(this.item, !this.ctr._horizontal);
          }
          _getMainAxisMargin() {
              return FlexUtils.getTotalMargin(this.item, this.ctr._horizontal);
          }
          _getCrossAxisMargin() {
              return FlexUtils.getTotalMargin(this.item, !this.ctr._horizontal);
          }
          _getHorizontalMarginOffset() {
              return FlexUtils.getMarginOffset(this.item, true);
          }
          _getVerticalMarginOffset() {
              return FlexUtils.getMarginOffset(this.item, false);
          }
          _getMainAxisMinSizeWithPaddingAndMargin() {
              return this._getMainAxisMinSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
          }
          _getCrossAxisMinSizeWithPaddingAndMargin() {
              return this._getCrossAxisMinSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
          }
          _getMainAxisLayoutSizeWithPaddingAndMargin() {
              return this._getMainAxisLayoutSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
          }
          _getCrossAxisLayoutSizeWithPaddingAndMargin() {
              return this._getCrossAxisLayoutSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
          }
          _hasFixedCrossAxisSize() {
              return !FlexUtils.isZeroAxisSize(this.item, !this.ctr._horizontal);
          }
          _hasRelCrossAxisSize() {
              return !!(this.ctr._horizontal ? this.item.funcH : this.item.funcW);
          }
      }
      FlexItem.SHRINK_AUTO = -1;

      class FlexTarget {
          constructor(target) {
              this._target = target;
              this._recalc = 0;
              this._enabled = false;
              this.x = 0;
              this.y = 0;
              this.w = 0;
              this.h = 0;
              this._originalX = 0;
              this._originalY = 0;
              this._originalWidth = 0;
              this._originalHeight = 0;
              this._flex = null;
              this._flexItem = null;
              this._flexItemDisabled = false;
              this._items = null;
          }
          get flexLayout() {
              return this.flex ? this.flex._layout : null;
          }
          layoutFlexTree() {
              if (this.isFlexEnabled() && this.isChanged()) {
                  this.flexLayout.layoutTree();
              }
          }
          get target() {
              return this._target;
          }
          get flex() {
              return this._flex;
          }
          set flex(v) {
              if (!v) {
                  if (this.isFlexEnabled()) {
                      this._disableFlex();
                  }
              } else {
                  if (!this.isFlexEnabled()) {
                      this._enableFlex();
                  }
                  this._flex.patch(v);
              }
          }
          get flexItem() {
              if (this._flexItemDisabled) {
                  return false;
              }
              this._ensureFlexItem();
              return this._flexItem;
          }
          set flexItem(v) {
              if (v === false) {
                  if (!this._flexItemDisabled) {
                      const parent = this.flexParent;
                      this._flexItemDisabled = true;
                      this._checkEnabled();
                      if (parent) {
                          parent._clearFlexItemsCache();
                          parent.changedContents();
                      }
                  }
              } else {
                  this._ensureFlexItem();
                  this._flexItem.patch(v);
                  if (this._flexItemDisabled) {
                      this._flexItemDisabled = false;
                      this._checkEnabled();
                      const parent = this.flexParent;
                      if (parent) {
                          parent._clearFlexItemsCache();
                          parent.changedContents();
                      }
                  }
              }
          }
          _enableFlex() {
              this._flex = new FlexContainer(this);
              this._checkEnabled();
              this.changedDimensions();
              this._enableChildrenAsFlexItems();
          }
          _disableFlex() {
              this.changedDimensions();
              this._flex = null;
              this._checkEnabled();
              this._disableChildrenAsFlexItems();
          }
          _enableChildrenAsFlexItems() {
              const children = this._target._children;
              if (children) {
                  for (let i = 0, n = children.length; i < n; i++) {
                      const child = children[i];
                      child.layout._enableFlexItem();
                  }
              }
          }
          _disableChildrenAsFlexItems() {
              const children = this._target._children;
              if (children) {
                  for (let i = 0, n = children.length; i < n; i++) {
                      const child = children[i];
                      child.layout._disableFlexItem();
                  }
              }
          }
          _enableFlexItem() {
              this._ensureFlexItem();
              const flexParent = this._target._parent._layout;
              this._flexItem.ctr = flexParent._flex;
              flexParent.changedContents();
              this._checkEnabled();
          }
          _disableFlexItem() {
              if (this._flexItem) {
                  this._flexItem.ctr = null;
              }
              this._checkEnabled();
              this._resetOffsets();
          }
          _resetOffsets() {
              this.x = 0;
              this.y = 0;
          }
          _ensureFlexItem() {
              if (!this._flexItem) {
                  this._flexItem = new FlexItem(this);
              }
          }
          _checkEnabled() {
              const enabled = this.isEnabled();
              if (this._enabled !== enabled) {
                  if (enabled) {
                      this._enable();
                  } else {
                      this._disable();
                  }
                  this._enabled = enabled;
              }
          }
          _enable() {
              this._setupTargetForFlex();
              this._target.enableFlexLayout();
          }
          _disable() {
              this._restoreTargetToNonFlex();
              this._target.disableFlexLayout();
          }
          isEnabled() {
              return this.isFlexEnabled() || this.isFlexItemEnabled();
          }
          isFlexEnabled() {
              return this._flex !== null;
          }
          isFlexItemEnabled() {
              return this.flexParent !== null;
          }
          _restoreTargetToNonFlex() {
              const target = this._target;
              target.x = this._originalX;
              target.y = this._originalY;
              target.setDimensions(this._originalWidth, this._originalHeight);
          }
          _setupTargetForFlex() {
              const target = this._target;
              this._originalX = target._x;
              this._originalY = target._y;
              this._originalWidth = target._w;
              this._originalHeight = target._h;
          }
          setParent(from, to) {
              if (from && from.isFlexContainer()) {
                  from._layout._changedChildren();
              }
              if (to && to.isFlexContainer()) {
                  this._enableFlexItem();
                  to._layout._changedChildren();
              }
              this._checkEnabled();
          }
          get flexParent() {
              if (this._flexItemDisabled) {
                  return null;
              }
              const parent = this._target._parent;
              if (parent && parent.isFlexContainer()) {
                  return parent._layout;
              }
              return null;
          }
          setVisible(v) {
              const parent = this.flexParent;
              if (parent) {
                  parent._changedChildren();
              }
          }
          get items() {
              if (!this._items) {
                  this._items = this._getFlexItems();
              }
              return this._items;
          }
          _getFlexItems() {
              const items = [];
              const children = this._target._children;
              if (children) {
                  for (let i = 0, n = children.length; i < n; i++) {
                      const item = children[i];
                      if (item.visible) {
                          if (item.isFlexItem()) {
                              items.push(item.layout);
                          }
                      }
                  }
              }
              return items;
          }
          _changedChildren() {
              this._clearFlexItemsCache();
              this.changedContents();
          }
          _clearFlexItemsCache() {
              this._items = null;
          }
          setLayout(x, y, w, h) {
              let originalX = this._originalX;
              let originalY = this._originalY;
              if (this.funcX) {
                  originalX = this.funcX(FlexUtils.getParentAxisSizeWithPadding(this, true));
              }
              if (this.funcY) {
                  originalY = this.funcY(FlexUtils.getParentAxisSizeWithPadding(this, false));
              }
              if (this.isFlexItemEnabled()) {
                  this.target.setLayout(x + originalX, y + originalY, w, h);
              } else {
                  this.target.setLayout(originalX, originalY, w, h);
              }
          }
          changedDimensions(changeWidth = true, changeHeight = true) {
              this._updateRecalc(changeWidth, changeHeight);
          }
          changedContents() {
              this._updateRecalc();
          }
          forceLayout() {
              this._updateRecalc();
          }
          isChanged() {
              return this._recalc > 0;
          }
          _updateRecalc(changeExternalWidth = false, changeExternalHeight = false) {
              if (this.isFlexEnabled()) {
                  const layout = this._flex._layout;
                  changeExternalWidth = changeExternalWidth || layout.isAxisFitToContents(true);
                  changeExternalHeight = changeExternalHeight || layout.isAxisFitToContents(false);
              }
              const recalc = 1 + (changeExternalWidth ? 2 : 0) + (changeExternalHeight ? 4 : 0);
              const newRecalcFlags = this.getNewRecalcFlags(recalc);
              this._recalc |= recalc;
              if (newRecalcFlags > 1) {
                  if (this.flexParent) {
                      this.flexParent._updateRecalcBottomUp(recalc);
                  } else {
                      this._target.triggerLayout();
                  }
              } else {
                  this._target.triggerLayout();
              }
          }
          getNewRecalcFlags(flags) {
              return (7 - this._recalc) & flags;
          }
          _updateRecalcBottomUp(childRecalc) {
              const newRecalc = this._getRecalcFromChangedChildRecalc(childRecalc);
              const newRecalcFlags = this.getNewRecalcFlags(newRecalc);
              this._recalc |= newRecalc;
              if (newRecalcFlags > 1) {
                  const flexParent = this.flexParent;
                  if (flexParent) {
                      flexParent._updateRecalcBottomUp(newRecalc);
                  } else {
                      this._target.triggerLayout();
                  }
              } else {
                  this._target.triggerLayout();
              }
          }
          _getRecalcFromChangedChildRecalc(childRecalc) {
              const layout = this._flex._layout;
              const mainAxisRecalcFlag = layout._horizontal ? 1 : 2;
              const crossAxisRecalcFlag = layout._horizontal ? 2 : 1;
              const crossAxisDimensionsChangedInChild = (childRecalc & crossAxisRecalcFlag);
              if (!crossAxisDimensionsChangedInChild) {
                  const mainAxisDimensionsChangedInChild = (childRecalc & mainAxisRecalcFlag);
                  if (mainAxisDimensionsChangedInChild) {
                      const mainAxisIsWrapping = layout.isWrapping();
                      if (mainAxisIsWrapping) {
                          const crossAxisIsFitToContents = layout.isCrossAxisFitToContents();
                          if (crossAxisIsFitToContents) {
                              childRecalc += crossAxisRecalcFlag;
                          }
                      }
                  }
              }
              let isWidthDynamic = layout.isAxisFitToContents(true);
              let isHeightDynamic = layout.isAxisFitToContents(false);
              if (layout.shrunk) {
                  if (layout._horizontal) {
                      isWidthDynamic = true;
                  } else {
                      isHeightDynamic = true;
                  }
              }
              const localRecalc = 1 + (isWidthDynamic ? 2 : 0) + (isHeightDynamic ? 4 : 0);
              const combinedRecalc = childRecalc & localRecalc;
              return combinedRecalc;
          }
          get recalc() {
              return this._recalc;
          }
          clearRecalcFlag() {
              this._recalc = 0;
          }
          enableLocalRecalcFlag() {
              this._recalc = 1;
          }
          get originalX() {
              return this._originalX;
          }
          setOriginalXWithoutUpdatingLayout(v) {
              this._originalX = v;
          }
          get originalY() {
              return this._originalY;
          }
          setOriginalYWithoutUpdatingLayout(v) {
              this._originalY = v;
          }
          get originalWidth() {
              return this._originalWidth;
          }
          set originalWidth(v) {
              if (this._originalWidth !== v) {
                  this._originalWidth = v;
                  this.changedDimensions(true, false);
              }
          }
          get originalHeight() {
              return this._originalHeight;
          }
          set originalHeight(v) {
              if (this._originalHeight !== v) {
                  this._originalHeight = v;
                  this.changedDimensions(false, true);
              }
          }
          get funcX() {
              return this._target.funcX;
          }
          get funcY() {
              return this._target.funcY;
          }
          get funcW() {
              return this._target.funcW;
          }
          get funcH() {
              return this._target.funcH;
          }
      }

      class TextureSource {
          constructor(manager, loader = null) {
              this.id = TextureSource.id++;
              this.manager = manager;
              this.stage = manager.stage;
              this.textures = new Set();
              this._activeTextureCount = 0;
              this.loader = loader;
              this.lookupId = null;
              this._cancelCb = null;
              this.loadingSince = 0;
              this.w = 0;
              this.h = 0;
              this._nativeTexture = null;
              this.permanent = false;
              this.renderInfo = null;
              this._isResultTexture = !this.loader;
              this._loadError = null;
              this._imageRef = null;
          }
          get loadError() {
              return this._loadError;
          }
          addTexture(v) {
              if (!this.textures.has(v)) {
                  this.textures.add(v);
              }
          }
          removeTexture(v) {
              this.textures.delete(v);
          }
          incActiveTextureCount() {
              this._activeTextureCount++;
              if (this._activeTextureCount === 1) {
                  this.becomesUsed();
              }
          }
          decActiveTextureCount() {
              this._activeTextureCount--;
              if (this._activeTextureCount === 0) {
                  this.becomesUnused();
              }
          }
          get isResultTexture() {
              return this._isResultTexture;
          }
          set isResultTexture(v) {
              this._isResultTexture = v;
          }
          forEachEnabledElement(cb) {
              this.textures.forEach(texture => {
                  texture.elements.forEach(cb);
              });
          }
          hasEnabledElements() {
              return this.textures.size > 0;
          }
          forEachActiveElement(cb) {
              this.textures.forEach(texture => {
                  texture.elements.forEach(element => {
                      if (element.active) {
                          cb(element);
                      }
                  });
              });
          }
          getRenderWidth() {
              return this.w;
          }
          getRenderHeight() {
              return this.h;
          }
          allowCleanup() {
              return !this.permanent && !this.isUsed();
          }
          becomesUsed() {
              this.load();
          }
          becomesUnused() {
              this.cancel();
          }
          cancel() {
              if (this.isLoading()) {
                  if (this._cancelCb) {
                      this._cancelCb(this);
                      this._cancelCb = null;
                  }
                  this.loadingSince = 0;
              }
          }
          isLoaded() {
              return !!this._nativeTexture;
          }
          isLoading() {
              return (this.loadingSince > 0);
          }
          isError() {
              return !!this._loadError;
          }
          reload() {
              this.free();
              if (this.isUsed()) {
                  this.load();
              }
          }
          load(forceSync = false) {
              if (this.isResultTexture) {
                  return;
              }
              if (!this._nativeTexture && !this.isLoading()) {
                  this.loadingSince = (new Date()).getTime();
                  this._cancelCb = this.loader((err, options) => {
                      if (this.isLoading()) {
                          this._cancelCb = null;
                          if (this.manager.stage.destroyed) {
                              return;
                          }
                          if (err) {
                              this.onError(err);
                          } else if (options && options.source) {
                              if (!this.stage.isUpdatingFrame() && !forceSync && (options.throttle !== false)) {
                                  const textureThrottler = this.stage.textureThrottler;
                                  this._cancelCb = textureThrottler.genericCancelCb;
                                  textureThrottler.add(this, options);
                              } else {
                                  this.processLoadedSource(options);
                              }
                          }
                      }
                  }, this);
              }
          }
          processLoadedSource(options) {
              this.loadingSince = 0;
              this.setSource(options);
          }
          setSource(options) {
              const source = options.source;
              this.w = source.width || (options && options.w) || 0;
              this.h = source.height || (options && options.h) || 0;
              if (options && options.renderInfo) {
                  this.renderInfo = options.renderInfo;
              }
              this.permanent = !!options.permanent;
              if (options && options.imageRef)
                  this._imageRef = options.imageRef;
              if (options && options.flipTextureY) {
                  this._flipTextureY = options.flipTextureY;
              } else {
                  this._flipTextureY = false;
              }
              if (this._isNativeTexture(source)) {
                  this._nativeTexture = source;
                  this.w = this.w || source.w;
                  this.h = this.h || source.h;
                  this.permanent = options.hasOwnProperty('permanent') ? options.permanent : true;
              } else {
                  this.manager.uploadTextureSource(this, options);
              }
              this._loadError = null;
              this.onLoad();
          }
          isUsed() {
              return this._activeTextureCount > 0;
          }
          onLoad() {
              if (this.isUsed()) {
                  this.textures.forEach(texture => {
                      texture.onLoad();
                  });
              }
          }
          forceRenderUpdate() {
              if (this._nativeTexture) {
                  this._nativeTexture.update = this.stage.frameCounter;
              }
              this.forEachActiveElement(function (element) {
                  element.forceRenderUpdate();
              });
          }
          forceUpdateRenderCoords() {
              this.forEachActiveElement(function (element) {
                  element._updateTextureCoords();
              });
          }
          get nativeTexture() {
              return this._nativeTexture;
          }
          clearNativeTexture() {
              this._nativeTexture = null;
              this._imageRef = null;
          }
          replaceNativeTexture(newNativeTexture, w, h) {
              let prevNativeTexture = this._nativeTexture;
              this._nativeTexture = newNativeTexture;
              this.w = w;
              this.h = h;
              if (!prevNativeTexture && this._nativeTexture) {
                  this.forEachActiveElement(element => element.onTextureSourceLoaded());
              }
              if (!this._nativeTexture) {
                  this.forEachActiveElement(element => element._setDisplayedTexture(null));
              }
              this.forEachEnabledElement(element => element._updateDimensions());
          }
          onError(e) {
              this._loadError = e;
              this.loadingSince = 0;
              console.error('[Lightning] texture load error', e, this.lookupId);
              this.forEachActiveElement(element => element.onTextureSourceLoadError(e));
          }
          free() {
              if (this.isLoaded()) {
                  this.manager.freeTextureSource(this);
              }
          }
          _isNativeTexture(source) {
              if (Utils.isNode) {
                  return source.constructor.name === "WebGLTexture";
              }
              if ('WebGLTexture' in window) {
                  return source instanceof WebGLTexture;
              }
              return false;
          }
      }
      TextureSource.prototype.isTextureSource = true;
      TextureSource.id = 1;

      class ElementTexturizer {
          constructor(elementCore) {
              this._element = elementCore.element;
              this._core = elementCore;
              this.ctx = this._core.ctx;
              this._enabled = false;
              this.lazy = false;
              this._colorize = false;
              this._renderTexture = null;
              this._renderTextureReused = false;
              this._resultTextureSource = null;
              this._renderOffscreen = false;
              this.empty = false;
          }
          get enabled() {
              return this._enabled;
          }
          set enabled(v) {
              this._enabled = v;
              this._core.updateRenderToTextureEnabled();
          }
          get renderOffscreen() {
              return this._renderOffscreen;
          }
          set renderOffscreen(v) {
              this._renderOffscreen = v;
              this._core.setHasRenderUpdates(1);
              this._core._setRecalc(6);
          }
          get colorize() {
              return this._colorize;
          }
          set colorize(v) {
              if (this._colorize !== v) {
                  this._colorize = v;
                  this._core.setHasRenderUpdates(1);
              }
          }
          _getTextureSource() {
              if (!this._resultTextureSource) {
                  this._resultTextureSource = new TextureSource(this._element.stage.textureManager);
                  this.updateResultTexture();
              }
              return this._resultTextureSource;
          }
          hasResultTexture() {
              return !!this._resultTextureSource;
          }
          resultTextureInUse() {
              return this._resultTextureSource && this._resultTextureSource.hasEnabledElements();
          }
          updateResultTexture() {
              let resultTexture = this.getResultTexture();
              if (this._resultTextureSource) {
                  if (this._resultTextureSource.nativeTexture !== resultTexture) {
                      let w = resultTexture ? resultTexture.w : 0;
                      let h = resultTexture ? resultTexture.h : 0;
                      this._resultTextureSource.replaceNativeTexture(resultTexture, w, h);
                  }
                  this._resultTextureSource.forEachEnabledElement(element => {
                      element._updateDimensions();
                      element.core.setHasRenderUpdates(3);
                  });
              }
          }
          mustRenderToTexture() {
              if (this._enabled && !this.lazy) {
                  return true;
              } else if (this._enabled && this.lazy && this._core._hasRenderUpdates < 3) {
                  return true;
              }
              return false;
          }
          deactivate() {
              this.release();
          }
          get renderTextureReused() {
              return this._renderTextureReused;
          }
          release() {
              this.releaseRenderTexture();
          }
          releaseRenderTexture() {
              if (this._renderTexture) {
                  if (!this._renderTextureReused) {
                      this.ctx.releaseRenderTexture(this._renderTexture);
                  }
                  this._renderTexture = null;
                  this._renderTextureReused = false;
                  this.updateResultTexture();
              }
          }
          reuseTextureAsRenderTexture(nativeTexture) {
              if (this._renderTexture !== nativeTexture) {
                  this.releaseRenderTexture();
                  this._renderTexture = nativeTexture;
                  this._renderTextureReused = true;
              }
          }
          hasRenderTexture() {
              return !!this._renderTexture;
          }
          getRenderTexture() {
              if (!this._renderTexture) {
                  this._renderTexture = this.ctx.allocateRenderTexture(this._core._w, this._core._h);
                  this._renderTextureReused = false;
              }
              return this._renderTexture;
          }
          getResultTexture() {
              return this._renderTexture;
          }
      }

      class ElementCore {
          constructor(element) {
              this._element = element;
              this.ctx = element.stage.ctx;
              this._recalc = 0;
              this._parent = null;
              this._onUpdate = null;
              this._pRecalc = 0;
              this._worldContext = new ElementCoreContext();
              this._hasUpdates = false;
              this._localAlpha = 1;
              this._onAfterCalcs = null;
              this._onAfterUpdate = null;
              this._localPx = 0;
              this._localPy = 0;
              this._localTa = 1;
              this._localTb = 0;
              this._localTc = 0;
              this._localTd = 1;
              this._isComplex = false;
              this._dimsUnknown = false;
              this._clipping = false;
              this._zSort = false;
              this._outOfBounds = 0;
              this._displayedTextureSource = null;
              this._zContextUsage = 0;
              this._children = null;
              this._hasRenderUpdates = 0;
              this._zIndexedChildren = null;
              this._renderContext = this._worldContext;
              this.renderState = this.ctx.renderState;
              this._scissor = null;
              this._shaderOwner = null;
              this._updateTreeOrder = 0;
              this._colorUl = this._colorUr = this._colorBl = this._colorBr = 0xFFFFFFFF;
              this._x = 0;
              this._y = 0;
              this._w = 0;
              this._h = 0;
              this._optFlags = 0;
              this._funcX = null;
              this._funcY = null;
              this._funcW = null;
              this._funcH = null;
              this._scaleX = 1;
              this._scaleY = 1;
              this._pivotX = 0.5;
              this._pivotY = 0.5;
              this._mountX = 0;
              this._mountY = 0;
              this._rotation = 0;
              this._alpha = 1;
              this._visible = true;
              this._ulx = 0;
              this._uly = 0;
              this._brx = 1;
              this._bry = 1;
              this._zIndex = 0;
              this._forceZIndexContext = false;
              this._zParent = null;
              this._isRoot = false;
              this._zIndexResort = false;
              this._shader = null;
              this._renderToTextureEnabled = false;
              this._texturizer = null;
              this._useRenderToTexture = false;
              this._boundsMargin = null;
              this._recBoundsMargin = null;
              this._withinBoundsMargin = false;
              this._viewport = null;
              this._clipbox = true;
              this.render = this._renderSimple;
              this._layout = null;
          }
          get offsetX() {
              if (this._funcX) {
                  return this._funcX;
              } else {
                  if (this.hasFlexLayout()) {
                      return this._layout.originalX;
                  } else {
                      return this._x;
                  }
              }
          }
          set offsetX(v) {
              if (Utils.isFunction(v)) {
                  this.funcX = v;
              } else {
                  this._disableFuncX();
                  if (this.hasFlexLayout()) {
                      this.x += (v - this._layout.originalX);
                      this._layout.setOriginalXWithoutUpdatingLayout(v);
                  } else {
                      this.x = v;
                  }
              }
          }
          get x() {
              return this._x;
          }
          set x(v) {
              if (v !== this._x) {
                  this._updateLocalTranslateDelta(v - this._x, 0);
                  this._x = v;
              }
          }
          get funcX() {
              return (this._optFlags & 1 ? this._funcX : null);
          }
          set funcX(v) {
              if (this._funcX !== v) {
                  this._optFlags |= 1;
                  this._funcX = v;
                  if (this.hasFlexLayout()) {
                      this._layout.setOriginalXWithoutUpdatingLayout(0);
                      this.layout.forceLayout();
                  } else {
                      this._x = 0;
                      this._triggerRecalcTranslate();
                  }
              }
          }
          _disableFuncX() {
              this._optFlags = this._optFlags & (0xFFFF - 1);
              this._funcX = null;
          }
          get offsetY() {
              if (this._funcY) {
                  return this._funcY;
              } else {
                  if (this.hasFlexLayout()) {
                      return this._layout.originalY;
                  } else {
                      return this._y;
                  }
              }
          }
          set offsetY(v) {
              if (Utils.isFunction(v)) {
                  this.funcY = v;
              } else {
                  this._disableFuncY();
                  if (this.hasFlexLayout()) {
                      this.y += (v - this._layout.originalY);
                      this._layout.setOriginalYWithoutUpdatingLayout(v);
                  } else {
                      this.y = v;
                  }
              }
          }
          get y() {
              return this._y;
          }
          set y(v) {
              if (v !== this._y) {
                  this._updateLocalTranslateDelta(0, v - this._y);
                  this._y = v;
              }
          }
          get funcY() {
              return (this._optFlags & 2 ? this._funcY : null);
          }
          set funcY(v) {
              if (this._funcY !== v) {
                  this._optFlags |= 2;
                  this._funcY = v;
                  if (this.hasFlexLayout()) {
                      this._layout.setOriginalYWithoutUpdatingLayout(0);
                      this.layout.forceLayout();
                  } else {
                      this._y = 0;
                      this._triggerRecalcTranslate();
                  }
              }
          }
          _disableFuncY() {
              this._optFlags = this._optFlags & (0xFFFF - 2);
              this._funcY = null;
          }
          get funcW() {
              return (this._optFlags & 4 ? this._funcW : null);
          }
          set funcW(v) {
              if (this._funcW !== v) {
                  this._optFlags |= 4;
                  this._funcW = v;
                  if (this.hasFlexLayout()) {
                      this._layout._originalWidth = 0;
                      this.layout.changedDimensions(true, false);
                  } else {
                      this._w = 0;
                      this._triggerRecalcTranslate();
                  }
              }
          }
          disableFuncW() {
              this._optFlags = this._optFlags & (0xFFFF - 4);
              this._funcW = null;
          }
          get funcH() {
              return (this._optFlags & 8 ? this._funcH : null);
          }
          set funcH(v) {
              if (this._funcH !== v) {
                  this._optFlags |= 8;
                  this._funcH = v;
                  if (this.hasFlexLayout()) {
                      this._layout._originalHeight = 0;
                      this.layout.changedDimensions(false, true);
                  } else {
                      this._h = 0;
                      this._triggerRecalcTranslate();
                  }
              }
          }
          disableFuncH() {
              this._optFlags = this._optFlags & (0xFFFF - 8);
              this._funcH = null;
          }
          get w() {
              return this._w;
          }
          getRenderWidth() {
              if (this.hasFlexLayout()) {
                  return this._layout.originalWidth;
              } else {
                  return this._w;
              }
          }
          get h() {
              return this._h;
          }
          getRenderHeight() {
              if (this.hasFlexLayout()) {
                  return this._layout.originalHeight;
              } else {
                  return this._h;
              }
          }
          get scaleX() {
              return this._scaleX;
          }
          set scaleX(v) {
              if (this._scaleX !== v) {
                  this._scaleX = v;
                  this._updateLocalTransform();
              }
          }
          get scaleY() {
              return this._scaleY;
          }
          set scaleY(v) {
              if (this._scaleY !== v) {
                  this._scaleY = v;
                  this._updateLocalTransform();
              }
          }
          get scale() {
              return this.scaleX;
          }
          set scale(v) {
              if (this._scaleX !== v || this._scaleY !== v) {
                  this._scaleX = v;
                  this._scaleY = v;
                  this._updateLocalTransform();
              }
          }
          get pivotX() {
              return this._pivotX;
          }
          set pivotX(v) {
              if (this._pivotX !== v) {
                  this._pivotX = v;
                  this._updateLocalTranslate();
              }
          }
          get pivotY() {
              return this._pivotY;
          }
          set pivotY(v) {
              if (this._pivotY !== v) {
                  this._pivotY = v;
                  this._updateLocalTranslate();
              }
          }
          get pivot() {
              return this._pivotX;
          }
          set pivot(v) {
              if (this._pivotX !== v || this._pivotY !== v) {
                  this._pivotX = v;
                  this._pivotY = v;
                  this._updateLocalTranslate();
              }
          }
          get mountX() {
              return this._mountX;
          }
          set mountX(v) {
              if (this._mountX !== v) {
                  this._mountX = v;
                  this._updateLocalTranslate();
              }
          }
          get mountY() {
              return this._mountY;
          }
          set mountY(v) {
              if (this._mountY !== v) {
                  this._mountY = v;
                  this._updateLocalTranslate();
              }
          }
          get mount() {
              return this._mountX;
          }
          set mount(v) {
              if (this._mountX !== v || this._mountY !== v) {
                  this._mountX = v;
                  this._mountY = v;
                  this._updateLocalTranslate();
              }
          }
          get rotation() {
              return this._rotation;
          }
          set rotation(v) {
              if (this._rotation !== v) {
                  this._rotation = v;
                  this._updateLocalTransform();
              }
          }
          get alpha() {
              return this._alpha;
          }
          set alpha(v) {
              v = (v > 1 ? 1 : (v < 1e-14 ? 0 : v));
              if (this._alpha !== v) {
                  let prev = this._alpha;
                  this._alpha = v;
                  this._updateLocalAlpha();
                  if ((prev === 0) !== (v === 0)) {
                      this._element._updateEnabledFlag();
                  }
              }
          }
          get visible() {
              return this._visible;
          }
          set visible(v) {
              if (this._visible !== v) {
                  this._visible = v;
                  this._updateLocalAlpha();
                  this._element._updateEnabledFlag();
                  if (this.hasFlexLayout()) {
                      this.layout.setVisible(v);
                  }
              }
          }
          _updateLocalTransform() {
              if (this._rotation !== 0 && this._rotation % (2 * Math.PI)) {
                  let _sr = Math.sin(this._rotation);
                  let _cr = Math.cos(this._rotation);
                  this._setLocalTransform(
                      _cr * this._scaleX,
                      -_sr * this._scaleY,
                      _sr * this._scaleX,
                      _cr * this._scaleY
                  );
              } else {
                  this._setLocalTransform(
                      this._scaleX,
                      0,
                      0,
                      this._scaleY
                  );
              }
              this._updateLocalTranslate();
          };
          _updateLocalTranslate() {
              this._recalcLocalTranslate();
              this._triggerRecalcTranslate();
          };
          _recalcLocalTranslate() {
              let pivotXMul = this._pivotX * this._w;
              let pivotYMul = this._pivotY * this._h;
              let px = this._x - (pivotXMul * this._localTa + pivotYMul * this._localTb) + pivotXMul;
              let py = this._y - (pivotXMul * this._localTc + pivotYMul * this._localTd) + pivotYMul;
              px -= this._mountX * this._w;
              py -= this._mountY * this._h;
              this._localPx = px;
              this._localPy = py;
          }
          _updateLocalTranslateDelta(dx, dy) {
              this._addLocalTranslate(dx, dy);
          };
          _updateLocalAlpha() {
              this._setLocalAlpha(this._visible ? this._alpha : 0);
          };
          setHasRenderUpdates(type) {
              if (this._worldContext.alpha) {
                  let p = this;
                  p._hasRenderUpdates = Math.max(type, p._hasRenderUpdates);
                  while ((p = p._parent) && (p._hasRenderUpdates !== 3)) {
                      p._hasRenderUpdates = 3;
                  }
              }
          }
          _setRecalc(type) {
              this._recalc |= type;
              this._setHasUpdates();
              if (this._parent) {
                  this._parent.setHasRenderUpdates(3);
              }
          }
          _setHasUpdates() {
              let p = this;
              while (p && !p._hasUpdates) {
                  p._hasUpdates = true;
                  p = p._parent;
              }
          }
          getParent() {
              return this._parent;
          }
          setParent(parent) {
              if (parent !== this._parent) {
                  let prevIsZContext = this.isZContext();
                  let prevParent = this._parent;
                  this._parent = parent;
                  if (this._layout || (parent && parent.isFlexContainer())) {
                      this.layout.setParent(prevParent, parent);
                  }
                  if (prevParent) {
                      prevParent.setHasRenderUpdates(3);
                  }
                  this._setRecalc(1 + 2 + 4);
                  if (this._parent) {
                      this._parent._setHasUpdates();
                  }
                  if (this._zIndex === 0) {
                      this.setZParent(parent);
                  } else {
                      this.setZParent(parent ? parent.findZContext() : null);
                  }
                  if (prevIsZContext !== this.isZContext()) {
                      if (!this.isZContext()) {
                          this.disableZContext();
                      } else {
                          this.enableZContext(prevParent.findZContext());
                      }
                  }
                  this._zIndexResort = true;
                  if (this._zParent) {
                      this._zParent.enableZSort();
                  }
                  if (!this._shader) {
                      let newShaderOwner = parent && !parent._renderToTextureEnabled ? parent._shaderOwner : null;
                      if (newShaderOwner !== this._shaderOwner) {
                          this.setHasRenderUpdates(1);
                          this._setShaderOwnerRecursive(newShaderOwner);
                      }
                  }
              }
          };
          enableZSort(force = false) {
              if (!this._zSort && this._zContextUsage > 0) {
                  this._zSort = true;
                  if (force) {
                      this.ctx.forceZSort(this);
                  }
              }
          }
          addChildAt(index, child) {
              if (!this._children) this._children = [];
              this._children.splice(index, 0, child);
              child.setParent(this);
          };
          setChildAt(index, child) {
              if (!this._children) this._children = [];
              this._children[index].setParent(null);
              this._children[index] = child;
              child.setParent(this);
          }
          removeChildAt(index) {
              let child = this._children[index];
              this._children.splice(index, 1);
              child.setParent(null);
          };
          removeChildren() {
              if (this._children) {
                  for (let i = 0, n = this._children.length; i < n; i++) {
                      this._children[i].setParent(null);
                  }
                  this._children.splice(0);
                  if (this._zIndexedChildren) {
                      this._zIndexedChildren.splice(0);
                  }
              }
          };
          syncChildren(removed, added, order) {
              this._children = order;
              for (let i = 0, n = removed.length; i < n; i++) {
                  removed[i].setParent(null);
              }
              for (let i = 0, n = added.length; i < n; i++) {
                  added[i].setParent(this);
              }
          }
          moveChild(fromIndex, toIndex) {
              let c = this._children[fromIndex];
              this._children.splice(fromIndex, 1);
              this._children.splice(toIndex, 0, c);
              this._zIndexResort = true;
              if (this._zParent) {
                  this._zParent.enableZSort();
              }
          }
          _setLocalTransform(a, b, c, d) {
              this._setRecalc(4);
              this._localTa = a;
              this._localTb = b;
              this._localTc = c;
              this._localTd = d;
              this._isComplex = (b !== 0) || (c !== 0) || (a < 0) || (d < 0);
          };
          _addLocalTranslate(dx, dy) {
              this._localPx += dx;
              this._localPy += dy;
              this._triggerRecalcTranslate();
          }
          _setLocalAlpha(a) {
              if (!this._worldContext.alpha && ((this._parent && this._parent._worldContext.alpha) && a)) {
                  this._setRecalc(1 + 128);
              } else {
                  this._setRecalc(1);
              }
              if (a < 1e-14) {
                  a = 0;
              }
              this._localAlpha = a;
          };
          setDimensions(w, h, isEstimate = this._dimsUnknown) {
              this._dimsUnknown = isEstimate;
              if (this.hasFlexLayout()) {
                  this._layout.originalWidth = w;
                  this._layout.originalHeight = h;
              } else {
                  if (this._w !== w || this._h !== h) {
                      this._updateDimensions(w, h);
                      return true;
                  }
              }
              return false;
          };
          _updateDimensions(w, h) {
              if (this._w !== w || this._h !== h) {
                  this._w = w;
                  this._h = h;
                  this._triggerRecalcTranslate();
                  if (this._texturizer) {
                      this._texturizer.releaseRenderTexture();
                      this._texturizer.updateResultTexture();
                  }
                  this._updateLocalTranslate();
              }
          }
          setTextureCoords(ulx, uly, brx, bry) {
              this.setHasRenderUpdates(3);
              this._ulx = ulx;
              this._uly = uly;
              this._brx = brx;
              this._bry = bry;
          };
          get displayedTextureSource() {
              return this._displayedTextureSource;
          }
          setDisplayedTextureSource(textureSource) {
              this.setHasRenderUpdates(3);
              this._displayedTextureSource = textureSource;
          };
          get isRoot() {
              return this._isRoot;
          }
          setAsRoot() {
              this._parent = new ElementCore(this._element);
              this._parent._hasRenderUpdates = 3;
              this._parent._hasUpdates = true;
              this._isRoot = true;
              this.ctx.root = this;
              this._parent._viewport = [0, 0, this.ctx.stage.coordsWidth, this.ctx.stage.coordsHeight];
              this._parent._scissor = this._parent._viewport;
              this._parent._recBoundsMargin = null;
              this._setRecalc(1 + 2 + 4);
          };
          isAncestorOf(c) {
              let p = c;
              while (p = p._parent) {
                  if (this === p) {
                      return true;
                  }
              }
              return false;
          };
          isZContext() {
              return (this._forceZIndexContext || this._renderToTextureEnabled || this._zIndex !== 0 || this._isRoot || !this._parent);
          };
          findZContext() {
              if (this.isZContext()) {
                  return this;
              } else {
                  return this._parent.findZContext();
              }
          };
          setZParent(newZParent) {
              if (this._zParent !== newZParent) {
                  if (this._zParent !== null) {
                      if (this._zIndex !== 0) {
                          this._zParent.decZContextUsage();
                      }
                      this._zParent.enableZSort();
                  }
                  if (newZParent !== null) {
                      let hadZContextUsage = (newZParent._zContextUsage > 0);
                      if (this._zIndex !== 0) {
                          newZParent.incZContextUsage();
                      }
                      if (newZParent._zContextUsage > 0) {
                          if (!hadZContextUsage && (this._parent === newZParent)) ; else {
                              newZParent._zIndexedChildren.push(this);
                          }
                          newZParent.enableZSort();
                      }
                  }
                  this._zParent = newZParent;
                  this._zIndexResort = true;
              }
          };
          incZContextUsage() {
              this._zContextUsage++;
              if (this._zContextUsage === 1) {
                  if (!this._zIndexedChildren) {
                      this._zIndexedChildren = [];
                  }
                  if (this._children) {
                      for (let i = 0, n = this._children.length; i < n; i++) {
                          this._zIndexedChildren.push(this._children[i]);
                      }
                      this._zSort = false;
                  }
              }
          };
          decZContextUsage() {
              this._zContextUsage--;
              if (this._zContextUsage === 0) {
                  this._zSort = false;
                  this._zIndexedChildren.splice(0);
              }
          };
          get zIndex() {
              return this._zIndex;
          }
          set zIndex(zIndex) {
              if (this._zIndex !== zIndex) {
                  this.setHasRenderUpdates(1);
                  let newZParent = this._zParent;
                  let prevIsZContext = this.isZContext();
                  if (zIndex === 0 && this._zIndex !== 0) {
                      if (this._parent === this._zParent) {
                          if (this._zParent) {
                              this._zParent.decZContextUsage();
                          }
                      } else {
                          newZParent = this._parent;
                      }
                  } else if (zIndex !== 0 && this._zIndex === 0) {
                      newZParent = this._parent ? this._parent.findZContext() : null;
                      if (newZParent === this._zParent) {
                          if (this._zParent) {
                              this._zParent.incZContextUsage();
                              this._zParent.enableZSort();
                          }
                      }
                  } else if (zIndex !== this._zIndex) {
                      if (this._zParent && this._zParent._zContextUsage) {
                          this._zParent.enableZSort();
                      }
                  }
                  if (newZParent !== this._zParent) {
                      this.setZParent(null);
                  }
                  this._zIndex = zIndex;
                  if (newZParent !== this._zParent) {
                      this.setZParent(newZParent);
                  }
                  if (prevIsZContext !== this.isZContext()) {
                      if (!this.isZContext()) {
                          this.disableZContext();
                      } else {
                          this.enableZContext(this._parent.findZContext());
                      }
                  }
                  this._zIndexResort = true;
                  if (this._zParent) {
                      this._zParent.enableZSort();
                  }
              }
          };
          get forceZIndexContext() {
              return this._forceZIndexContext;
          }
          set forceZIndexContext(v) {
              this.setHasRenderUpdates(1);
              let prevIsZContext = this.isZContext();
              this._forceZIndexContext = v;
              if (prevIsZContext !== this.isZContext()) {
                  if (!this.isZContext()) {
                      this.disableZContext();
                  } else {
                      this.enableZContext(this._parent.findZContext());
                  }
              }
          };
          enableZContext(prevZContext) {
              if (prevZContext && prevZContext._zContextUsage > 0) {
                  const results = this._getZIndexedDescs();
                  results.forEach((c) => {
                      if (this.isAncestorOf(c) && c._zIndex !== 0) {
                          c.setZParent(this);
                      }
                  });
              }
          }
          _getZIndexedDescs() {
              const results = [];
              if (this._children) {
                  for (let i = 0, n = this._children.length; i < n; i++) {
                      this._children[i]._getZIndexedDescsRec(results);
                  }
              }
              return results;
          }
          _getZIndexedDescsRec(results) {
              if (this._zIndex) {
                  results.push(this);
              } else if (this._children && !this.isZContext()) {
                  for (let i = 0, n = this._children.length; i < n; i++) {
                      this._children[i]._getZIndexedDescsRec(results);
                  }
              }
          }
          disableZContext() {
              if (this._zContextUsage > 0) {
                  let newZParent = this._parent.findZContext();
                  if (this._zSort) {
                      this.sortZIndexedChildren();
                  }
                  this._zIndexedChildren.slice().forEach(function (c) {
                      if (c._zIndex !== 0) {
                          c.setZParent(newZParent);
                      }
                  });
              }
          };
          get colorUl() {
              return this._colorUl;
          }
          set colorUl(color) {
              if (this._colorUl !== color) {
                  this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
                  this._colorUl = color;
              }
          }
          get colorUr() {
              return this._colorUr;
          }
          set colorUr(color) {
              if (this._colorUr !== color) {
                  this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
                  this._colorUr = color;
              }
          };
          get colorBl() {
              return this._colorBl;
          }
          set colorBl(color) {
              if (this._colorBl !== color) {
                  this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
                  this._colorBl = color;
              }
          };
          get colorBr() {
              return this._colorBr;
          }
          set colorBr(color) {
              if (this._colorBr !== color) {
                  this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
                  this._colorBr = color;
              }
          };
          set onUpdate(f) {
              this._onUpdate = f;
              this._setRecalc(7);
          }
          set onAfterUpdate(f) {
              this._onAfterUpdate = f;
              this._setRecalc(7);
          }
          set onAfterCalcs(f) {
              this._onAfterCalcs = f;
              this._setRecalc(7);
          }
          get shader() {
              return this._shader;
          }
          set shader(v) {
              this.setHasRenderUpdates(1);
              let prevShader = this._shader;
              this._shader = v;
              if (!v && prevShader) {
                  let newShaderOwner = (this._parent && !this._parent._renderToTextureEnabled ? this._parent._shaderOwner : null);
                  this._setShaderOwnerRecursive(newShaderOwner);
              } else if (v) {
                  this._setShaderOwnerRecursive(this);
              }
          }
          get activeShader() {
              return this._shaderOwner ? this._shaderOwner.shader : this.renderState.defaultShader;
          }
          get activeShaderOwner() {
              return this._shaderOwner;
          }
          get clipping() {
              return this._clipping;
          }
          set clipping(v) {
              if (this._clipping !== v) {
                  this._clipping = v;
                  this._setRecalc(1 + 2);
              }
          }
          get clipbox() {
              return this._clipbox;
          }
          set clipbox(v) {
              this._clipbox = v;
          }
          _setShaderOwnerRecursive(elementCore) {
              this._shaderOwner = elementCore;
              if (this._children && !this._renderToTextureEnabled) {
                  for (let i = 0, n = this._children.length; i < n; i++) {
                      let c = this._children[i];
                      if (!c._shader) {
                          c._setShaderOwnerRecursive(elementCore);
                          c._hasRenderUpdates = 3;
                      }
                  }
              }
          };
          _setShaderOwnerChildrenRecursive(elementCore) {
              if (this._children) {
                  for (let i = 0, n = this._children.length; i < n; i++) {
                      let c = this._children[i];
                      if (!c._shader) {
                          c._setShaderOwnerRecursive(elementCore);
                          c._hasRenderUpdates = 3;
                      }
                  }
              }
          };
          _hasRenderContext() {
              return this._renderContext !== this._worldContext;
          }
          get renderContext() {
              return this._renderContext;
          }
          updateRenderToTextureEnabled() {
              let v = this.texturizer._enabled;
              if (v) {
                  this._enableRenderToTexture();
              } else {
                  this._disableRenderToTexture();
                  this._texturizer.releaseRenderTexture();
              }
          }
          _enableRenderToTexture() {
              if (!this._renderToTextureEnabled) {
                  let prevIsZContext = this.isZContext();
                  this._renderToTextureEnabled = true;
                  this._renderContext = new ElementCoreContext();
                  this._setShaderOwnerChildrenRecursive(null);
                  if (!prevIsZContext) {
                      this.enableZContext(this._parent ? this._parent.findZContext() : null);
                  }
                  this.setHasRenderUpdates(3);
                  this._setRecalc(7);
                  this.render = this._renderAdvanced;
              }
          }
          _disableRenderToTexture() {
              if (this._renderToTextureEnabled) {
                  this._renderToTextureEnabled = false;
                  this._setShaderOwnerChildrenRecursive(this._shaderOwner);
                  this._renderContext = this._worldContext;
                  if (!this.isZContext()) {
                      this.disableZContext();
                  }
                  this._setRecalc(7);
                  this.setHasRenderUpdates(3);
                  this.render = this._renderSimple;
              }
          }
          isWhite() {
              return (this._colorUl === 0xFFFFFFFF) && (this._colorUr === 0xFFFFFFFF) && (this._colorBl === 0xFFFFFFFF) && (this._colorBr === 0xFFFFFFFF);
          }
          hasSimpleTexCoords() {
              return (this._ulx === 0) && (this._uly === 0) && (this._brx === 1) && (this._bry === 1);
          }
          _stashTexCoords() {
              this._stashedTexCoords = [this._ulx, this._uly, this._brx, this._bry];
              this._ulx = 0;
              this._uly = 0;
              this._brx = 1;
              this._bry = 1;
          }
          _unstashTexCoords() {
              this._ulx = this._stashedTexCoords[0];
              this._uly = this._stashedTexCoords[1];
              this._brx = this._stashedTexCoords[2];
              this._bry = this._stashedTexCoords[3];
              this._stashedTexCoords = null;
          }
          _stashColors() {
              this._stashedColors = [this._colorUl, this._colorUr, this._colorBr, this._colorBl];
              this._colorUl = 0xFFFFFFFF;
              this._colorUr = 0xFFFFFFFF;
              this._colorBr = 0xFFFFFFFF;
              this._colorBl = 0xFFFFFFFF;
          }
          _unstashColors() {
              this._colorUl = this._stashedColors[0];
              this._colorUr = this._stashedColors[1];
              this._colorBr = this._stashedColors[2];
              this._colorBl = this._stashedColors[3];
              this._stashedColors = null;
          }
          isVisible() {
              return (this._localAlpha > 1e-14);
          };
          get outOfBounds() {
              return this._outOfBounds;
          }
          set boundsMargin(v) {
              this._boundsMargin = v ? v.slice() : null;
              this._triggerRecalcTranslate();
          }
          get boundsMargin() {
              return this._boundsMargin;
          }
          update() {
              this._recalc |= this._parent._pRecalc;
              if (this._layout && this._layout.isEnabled()) {
                  if (this._recalc & 256) {
                      this._layout.layoutFlexTree();
                  }
              } else if ((this._recalc & 2) && this._optFlags) {
                  this._applyRelativeDimFuncs();
              }
              if (this._onUpdate) {
                  this._hasUpdates = true;
                  this._onUpdate(this.element, this);
              }
              const pw = this._parent._worldContext;
              let w = this._worldContext;
              const visible = (pw.alpha && this._localAlpha);
              if (this._hasUpdates || (this._recalc && visible) || (w.alpha && !visible)) {
                  let recalc = this._recalc;
                  if (recalc & 1) {
                      if (!w.alpha && visible) {
                          this._hasRenderUpdates = 3;
                      }
                      w.alpha = pw.alpha * this._localAlpha;
                      if (w.alpha < 1e-14) {
                          w.alpha = 0;
                      }
                  }
                  if (recalc & 6) {
                      w.px = pw.px + this._localPx * pw.ta;
                      w.py = pw.py + this._localPy * pw.td;
                      if (pw.tb !== 0) w.px += this._localPy * pw.tb;
                      if (pw.tc !== 0) w.py += this._localPx * pw.tc;
                  }
                  if (recalc & 4) {
                      w.ta = this._localTa * pw.ta;
                      w.tb = this._localTd * pw.tb;
                      w.tc = this._localTa * pw.tc;
                      w.td = this._localTd * pw.td;
                      if (this._isComplex) {
                          w.ta += this._localTc * pw.tb;
                          w.tb += this._localTb * pw.ta;
                          w.tc += this._localTc * pw.td;
                          w.td += this._localTb * pw.tc;
                      }
                  }
                  const pr = this._parent._renderContext;
                  if (this._parent._hasRenderContext()) {
                      const init = this._renderContext === this._worldContext;
                      if (init) {
                          this._renderContext = new ElementCoreContext();
                      }
                      const r = this._renderContext;
                      if (init || (recalc & 1)) {
                          r.alpha = pr.alpha * this._localAlpha;
                          if (r.alpha < 1e-14) {
                              r.alpha = 0;
                          }
                      }
                      if (init || (recalc & 6)) {
                          r.px = pr.px + this._localPx * pr.ta;
                          r.py = pr.py + this._localPy * pr.td;
                          if (pr.tb !== 0) r.px += this._localPy * pr.tb;
                          if (pr.tc !== 0) r.py += this._localPx * pr.tc;
                      }
                      if (init) {
                          recalc |= 2;
                      }
                      if (init || (recalc & 4)) {
                          r.ta = this._localTa * pr.ta;
                          r.tb = this._localTd * pr.tb;
                          r.tc = this._localTa * pr.tc;
                          r.td = this._localTd * pr.td;
                          if (this._isComplex) {
                              r.ta += this._localTc * pr.tb;
                              r.tb += this._localTb * pr.ta;
                              r.tc += this._localTc * pr.td;
                              r.td += this._localTb * pr.tc;
                          }
                      }
                  } else {
                      this._renderContext = this._worldContext;
                  }
                  if (this.ctx.updateTreeOrder === -1) {
                      this.ctx.updateTreeOrder = this._updateTreeOrder + 1;
                  } else {
                      this._updateTreeOrder = this.ctx.updateTreeOrder++;
                  }
                  const useRenderToTexture = this._renderToTextureEnabled && this._texturizer.mustRenderToTexture();
                  if (this._useRenderToTexture !== useRenderToTexture) {
                      this._recalc |= 2 + 4;
                      recalc |= 2;
                      if (!this._useRenderToTexture) {
                          this._texturizer.release();
                      }
                  }
                  this._useRenderToTexture = useRenderToTexture;
                  const r = this._renderContext;
                  const bboxW = this._dimsUnknown ? 2048 : this._w;
                  const bboxH = this._dimsUnknown ? 2048 : this._h;
                  let sx, sy, ex, ey;
                  const rComplex = (r.tb !== 0) || (r.tc !== 0) || (r.ta < 0) || (r.td < 0);
                  if (rComplex) {
                      sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                      ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                      sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                      ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                  } else {
                      sx = r.px;
                      ex = r.px + r.ta * bboxW;
                      sy = r.py;
                      ey = r.py + r.td * bboxH;
                  }
                  if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                      const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                      const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                      if (nx < sx) sx = nx;
                      if (ny < sy) sy = ny;
                      if (nx > ex) ex = nx;
                      if (ny > ey) ey = ny;
                  }
                  if (recalc & 6 || !this._scissor ) {
                      if (this._clipping && r.isSquare()) {
                          const area = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                          if (area) {
                              const lx = Math.max(area[0], sx);
                              const ly = Math.max(area[1], sy);
                              this._scissor = [
                                  lx,
                                  ly,
                                  Math.min(area[2] + area[0], ex) - lx,
                                  Math.min(area[3] + area[1], ey) - ly
                              ];
                          } else {
                              this._scissor = [sx, sy, ex - sx, ey - sy];
                          }
                      } else {
                          this._scissor = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                      }
                  }
                  if (this._boundsMargin) {
                      this._recBoundsMargin = this._boundsMargin;
                  } else {
                      this._recBoundsMargin = this._parent._recBoundsMargin;
                  }
                  if (this._onAfterCalcs) {
                      if (this._onAfterCalcs(this.element)) {
                          if (rComplex) {
                              sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                              ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                              sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                              ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                          } else {
                              sx = r.px;
                              ex = r.px + r.ta * bboxW;
                              sy = r.py;
                              ey = r.py + r.td * bboxH;
                          }
                          if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                              const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                              const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                              if (nx < sx) sx = nx;
                              if (ny < sy) sy = ny;
                              if (nx > ex) ex = nx;
                              if (ny > ey) ey = ny;
                          }
                      }
                  }
                  if (this._parent._outOfBounds === 2) {
                      this._outOfBounds = 2;
                      if (this._withinBoundsMargin) {
                          this._withinBoundsMargin = false;
                          this.element._disableWithinBoundsMargin();
                      }
                  } else {
                      if (recalc & 6) {
                          this._outOfBounds = 0;
                          let withinMargin = true;
                          if (!this._renderToTextureEnabled || !this._texturizer || !this._texturizer.renderOffscreen) {
                              if (this._scissor && (this._scissor[2] <= 0 || this._scissor[3] <= 0)) {
                                  this._outOfBounds = 2;
                              } else {
                                  if ((this._scissor[0] > ex) ||
                                      (this._scissor[1] > ey) ||
                                      (sx > (this._scissor[0] + this._scissor[2])) ||
                                      (sy > (this._scissor[1] + this._scissor[3]))
                                  ) {
                                      this._outOfBounds = 1;
                                  }
                                  if (this._outOfBounds) {
                                      if (this._clipping || this._useRenderToTexture || (this._clipbox && (bboxW && bboxH))) {
                                          this._outOfBounds = 2;
                                      }
                                  }
                              }
                              withinMargin = (this._outOfBounds === 0);
                              if (!withinMargin) {
                                  if (this._recBoundsMargin) {
                                      withinMargin = !((ex < this._scissor[0] - this._recBoundsMargin[2]) ||
                                          (ey < this._scissor[1] - this._recBoundsMargin[3]) ||
                                          (sx > this._scissor[0] + this._scissor[2] + this._recBoundsMargin[0]) ||
                                          (sy > this._scissor[1] + this._scissor[3] + this._recBoundsMargin[1]));
                                  } else {
                                      withinMargin = !((ex < this._scissor[0] - 100) ||
                                          (ey < this._scissor[1] - 100) ||
                                          (sx > this._scissor[0] + this._scissor[2] + 100) ||
                                          (sy > this._scissor[1] + this._scissor[3] + 100));
                                  }
                                  if (withinMargin && this._outOfBounds === 2) {
                                      this._outOfBounds = 1;
                                  }
                              }
                          }
                          if (this._withinBoundsMargin !== withinMargin) {
                              this._withinBoundsMargin = withinMargin;
                              if (this._withinBoundsMargin) {
                                  this._hasUpdates = true;
                                  const recalc = this._recalc;
                                  this._recalc = 0;
                                  this.element._enableWithinBoundsMargin();
                                  if (this._recalc) {
                                      return this.update();
                                  }
                                  this._recalc = recalc;
                              } else {
                                  this.element._disableWithinBoundsMargin();
                              }
                          }
                      }
                  }
                  if (this._useRenderToTexture) {
                      if (this._viewport) {
                          this._viewport[2] = bboxW;
                          this._viewport[3] = bboxH;
                      } else {
                          this._viewport = [0, 0, bboxW, bboxH];
                      }
                  }
                  this._pRecalc = (this._recalc & 135);
                  this._recalc = 0;
                  this._hasUpdates = false;
                  if (this._outOfBounds < 2) {
                      if (this._useRenderToTexture) {
                          if (this._worldContext.isIdentity()) {
                              this._renderContext = this._worldContext;
                          } else {
                              this._renderContext = ElementCoreContext.IDENTITY;
                          }
                      }
                      if (this._children) {
                          for (let i = 0, n = this._children.length; i < n; i++) {
                              this._children[i].update();
                          }
                      }
                      if (this._useRenderToTexture) {
                          this._renderContext = r;
                      }
                  } else {
                      if (this._children) {
                          for (let i = 0, n = this._children.length; i < n; i++) {
                              if (this._children[i]._hasUpdates) {
                                  this._children[i].update();
                              } else {
                                  this._children[i]._recalc |= this._pRecalc;
                                  this._children[i].updateOutOfBounds();
                              }
                          }
                      }
                  }
                  if (this._onAfterUpdate) {
                      this._onAfterUpdate(this.element);
                  }
              } else {
                  if (this.ctx.updateTreeOrder === -1 || this._updateTreeOrder >= this.ctx.updateTreeOrder) {
                      this.ctx.updateTreeOrder = -1;
                  } else {
                      this.updateTreeOrder();
                  }
              }
          }
          _applyRelativeDimFuncs() {
              if (this._optFlags & 1) {
                  const x = this._funcX(this._parent.w);
                  if (x !== this._x) {
                      this._localPx += (x - this._x);
                      this._x = x;
                  }
              }
              if (this._optFlags & 2) {
                  const y = this._funcY(this._parent.h);
                  if (y !== this._y) {
                      this._localPy += (y - this._y);
                      this._y = y;
                  }
              }
              let changedDims = false;
              if (this._optFlags & 4) {
                  const w = this._funcW(this._parent.w);
                  if (w !== this._w) {
                      this._w = w;
                      changedDims = true;
                  }
              }
              if (this._optFlags & 8) {
                  const h = this._funcH(this._parent.h);
                  if (h !== this._h) {
                      this._h = h;
                      changedDims = true;
                  }
              }
              if (changedDims) {
                  this._recalcLocalTranslate();
                  this.element.onDimensionsChanged(this._w, this._h);
              }
          }
          updateOutOfBounds() {
              if (this._outOfBounds !== 2 && this._renderContext.alpha > 0) {
                  this._outOfBounds = 2;
                  if (this._withinBoundsMargin) {
                      this._withinBoundsMargin = false;
                      this.element._disableWithinBoundsMargin();
                  }
                  if (this._children) {
                      for (let i = 0, n = this._children.length; i < n; i++) {
                          this._children[i].updateOutOfBounds();
                      }
                  }
              }
          }
          updateTreeOrder() {
              if (this._localAlpha && (this._outOfBounds !== 2)) {
                  this._updateTreeOrder = this.ctx.updateTreeOrder++;
                  if (this._children) {
                      for (let i = 0, n = this._children.length; i < n; i++) {
                          this._children[i].updateTreeOrder();
                      }
                  }
              }
          }
          _renderSimple() {
              this._hasRenderUpdates = 0;
              if (this._zSort) {
                  this.sortZIndexedChildren();
              }
              if (this._outOfBounds < 2 && this._renderContext.alpha) {
                  let renderState = this.renderState;
                  if ((this._outOfBounds === 0) && this._displayedTextureSource) {
                      renderState.setShader(this.activeShader, this._shaderOwner);
                      renderState.setScissor(this._scissor);
                      this.renderState.addQuad(this);
                  }
                  if (this._children) {
                      if (this._zContextUsage) {
                          for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                              this._zIndexedChildren[i].render();
                          }
                      } else {
                          for (let i = 0, n = this._children.length; i < n; i++) {
                              if (this._children[i]._zIndex === 0) {
                                  this._children[i].render();
                              }
                          }
                      }
                  }
              }
          }
          _renderAdvanced() {
              const hasRenderUpdates = this._hasRenderUpdates;
              this._hasRenderUpdates = 0;
              if (this._zSort) {
                  this.sortZIndexedChildren();
              }
              if (this._outOfBounds < 2 && this._renderContext.alpha) {
                  let renderState = this.renderState;
                  let mustRenderChildren = true;
                  let renderTextureInfo;
                  let prevRenderTextureInfo;
                  if (this._useRenderToTexture) {
                      if (this._w === 0 || this._h === 0) {
                          return;
                      } else if (!this._texturizer.hasRenderTexture() || (hasRenderUpdates >= 3)) {
                          renderState.setShader(renderState.defaultShader, this);
                          prevRenderTextureInfo = renderState.renderTextureInfo;
                          renderTextureInfo = {
                              nativeTexture: null,
                              offset: 0,
                              w: this._w,
                              h: this._h,
                              empty: true,
                              cleared: false,
                              ignore: false,
                              cache: false
                          };
                          if (this._texturizer.hasResultTexture() || (!renderState.isCachingTexturizer && (hasRenderUpdates < 3))) {
                              renderTextureInfo.cache = true;
                              renderState.isCachingTexturizer = true;
                          }
                          if (!this._texturizer.hasResultTexture()) {
                              this._texturizer.releaseRenderTexture();
                          }
                          renderState.setRenderTextureInfo(renderTextureInfo);
                          renderState.setScissor(null);
                          if (this._displayedTextureSource) {
                              let r = this._renderContext;
                              this._renderContext = ElementCoreContext.IDENTITY;
                              this.renderState.addQuad(this);
                              this._renderContext = r;
                          }
                      } else {
                          mustRenderChildren = false;
                      }
                  } else {
                      if ((this._outOfBounds === 0) && this._displayedTextureSource) {
                          renderState.setShader(this.activeShader, this._shaderOwner);
                          renderState.setScissor(this._scissor);
                          this.renderState.addQuad(this);
                      }
                  }
                  if (mustRenderChildren && this._children) {
                      if (this._zContextUsage) {
                          for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                              this._zIndexedChildren[i].render();
                          }
                      } else {
                          for (let i = 0, n = this._children.length; i < n; i++) {
                              if (this._children[i]._zIndex === 0) {
                                  this._children[i].render();
                              }
                          }
                      }
                  }
                  if (this._useRenderToTexture) {
                      let updateResultTexture = false;
                      if (mustRenderChildren) {
                          renderState.finishedRenderTexture();
                          this._texturizer.empty = renderTextureInfo.empty;
                          if (renderTextureInfo.empty) {
                              this._texturizer.releaseRenderTexture();
                          } else if (renderTextureInfo.nativeTexture) {
                              this._texturizer.reuseTextureAsRenderTexture(renderTextureInfo.nativeTexture);
                              renderTextureInfo.ignore = true;
                          } else {
                              if (this._texturizer.renderTextureReused) {
                                  this._texturizer.releaseRenderTexture();
                              }
                              renderTextureInfo.nativeTexture = this._texturizer.getRenderTexture();
                          }
                          renderState.setRenderTextureInfo(prevRenderTextureInfo);
                          updateResultTexture = true;
                      }
                      if (!this._texturizer.empty) {
                          let resultTexture = this._texturizer.getResultTexture();
                          if (updateResultTexture) {
                              if (resultTexture) {
                                  resultTexture.update = renderState.stage.frameCounter;
                              }
                              this._texturizer.updateResultTexture();
                          }
                          if (!this._texturizer.renderOffscreen) {
                              renderState.setShader(this.activeShader, this._shaderOwner);
                              renderState.setScissor(this._scissor);
                              const cache = !renderTextureInfo || renderTextureInfo.cache;
                              renderState.setTexturizer(this._texturizer, cache);
                              this._stashTexCoords();
                              if (!this._texturizer.colorize) this._stashColors();
                              this.renderState.addQuad(this, true);
                              if (!this._texturizer.colorize) this._unstashColors();
                              this._unstashTexCoords();
                              renderState.setTexturizer(null);
                          }
                      }
                  }
                  if (renderTextureInfo && renderTextureInfo.cache) {
                      renderState.isCachingTexturizer = false;
                  }
              }
          }
          get zSort() {
              return this._zSort;
          }
          sortZIndexedChildren() {
              const n = this._zIndexedChildren.length;
              let ptr = 0;
              const a = this._zIndexedChildren;
              const b = [];
              for (let i = 0; i < n; i++) {
                  if (a[i]._zParent === this) {
                      if (a[i]._zIndexResort) {
                          b.push(a[i]);
                      } else {
                          if (ptr !== i) {
                              a[ptr] = a[i];
                          }
                          ptr++;
                      }
                  }
              }
              const m = b.length;
              if (m) {
                  for (let j = 0; j < m; j++) {
                      b[j]._zIndexResort = false;
                  }
                  b.sort(ElementCore.sortZIndexedChildren);
                  const n = ptr;
                  if (!n) {
                      ptr = 0;
                      let j = 0;
                      do {
                          a[ptr++] = b[j++];
                      } while (j < m);
                      if (a.length > ptr) {
                          a.splice(ptr);
                      }
                  } else {
                      ptr = 0;
                      let i = 0;
                      let j = 0;
                      const mergeResult = [];
                      do {
                          const v = (a[i]._zIndex === b[j]._zIndex ? a[i]._updateTreeOrder - b[j]._updateTreeOrder : a[i]._zIndex - b[j]._zIndex);
                          const add = v > 0 ? b[j++] : a[i++];
                          if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                              mergeResult[ptr++] = add;
                          }
                          if (i >= n) {
                              do {
                                  const add = b[j++];
                                  if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                                      mergeResult[ptr++] = add;
                                  }
                              } while (j < m);
                              break;
                          } else if (j >= m) {
                              do {
                                  const add = a[i++];
                                  if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                                      mergeResult[ptr++] = add;
                                  }
                              } while (i < n);
                              break;
                          }
                      } while (true);
                      this._zIndexedChildren = mergeResult;
                  }
              } else {
                  if (a.length > ptr) {
                      a.splice(ptr);
                  }
              }
              this._zSort = false;
          };
          get localTa() {
              return this._localTa;
          };
          get localTb() {
              return this._localTb;
          };
          get localTc() {
              return this._localTc;
          };
          get localTd() {
              return this._localTd;
          };
          get element() {
              return this._element;
          }
          get renderUpdates() {
              return this._hasRenderUpdates;
          }
          get texturizer() {
              if (!this._texturizer) {
                  this._texturizer = new ElementTexturizer(this);
              }
              return this._texturizer;
          }
          getCornerPoints() {
              let w = this._worldContext;
              return [
                  w.px,
                  w.py,
                  w.px + this._w * w.ta,
                  w.py + this._w * w.tc,
                  w.px + this._w * w.ta + this._h * w.tb,
                  w.py + this._w * w.tc + this._h * w.td,
                  w.px + this._h * w.tb,
                  w.py + this._h * w.td
              ];
          };
          getRenderTextureCoords(relX, relY) {
              let r = this._renderContext;
              return [
                  r.px + r.ta * relX + r.tb * relY,
                  r.py + r.tc * relX + r.td * relY
              ];
          }
          getAbsoluteCoords(relX, relY) {
              let w = this._renderContext;
              return [
                  w.px + w.ta * relX + w.tb * relY,
                  w.py + w.tc * relX + w.td * relY
              ];
          }
          collectAtCoord(x, y, children) {
              if (this._renderContext.alpha === 0) {
                  return;
              }
              if (this.inBound(x, y)) {
                  if (this._scissor) {
                      if (this.inScissor()) {
                          children.push(this);
                      }
                  } else {
                      children.push(this);
                  }
              }
              if (this._children) {
                  const j = this._children.length;
                  for (let i = 0; i < j; i++) {
                      this._children[i].collectAtCoord(x, y, children);
                  }
              }
              return children.sort(ElementCore.sortZIndexedChildren);
          }
          inBound(tx, ty) {
              const c = this.getCornerPoints();
              return tx > c[0] && tx < c[2] && ty > c[1] && ty < c[7];
          }
          inScissor() {
              const sc = this._scissor;
              const c = this.getCornerPoints();
              return c[2] >= sc[0] && c[0] <= sc[0] + sc[2] && c[7] >= sc[1] && c[1] <= sc[1] + sc[3];
          }
          get layout() {
              this._ensureLayout();
              return this._layout;
          }
          get flex() {
              return this._layout ? this._layout.flex : null;
          }
          set flex(v) {
              this.layout.flex = v;
          }
          get flexItem() {
              return this._layout ? this._layout.flexItem : null;
          }
          set flexItem(v) {
              this.layout.flexItem = v;
          }
          isFlexItem() {
              return !!this._layout && this._layout.isFlexItemEnabled();
          }
          isFlexContainer() {
              return !!this._layout && this._layout.isFlexEnabled();
          }
          enableFlexLayout() {
              this._ensureLayout();
          }
          _ensureLayout() {
              if (!this._layout) {
                  this._layout = new FlexTarget(this);
              }
          }
          disableFlexLayout() {
              this._triggerRecalcTranslate();
          }
          hasFlexLayout() {
              return (this._layout && this._layout.isEnabled());
          }
          setLayout(x, y, w, h) {
              this.x = x;
              this.y = y;
              this._updateDimensions(w, h);
          }
          triggerLayout() {
              this._setRecalc(256);
          }
          _triggerRecalcTranslate() {
              this._setRecalc(2);
          }
      }
      class ElementCoreContext {
          constructor() {
              this.alpha = 1;
              this.px = 0;
              this.py = 0;
              this.ta = 1;
              this.tb = 0;
              this.tc = 0;
              this.td = 1;
          }
          isIdentity() {
              return this.alpha === 1 &&
                  this.px === 0 &&
                  this.py === 0 &&
                  this.ta === 1 &&
                  this.tb === 0 &&
                  this.tc === 0 &&
                  this.td === 1;
          }
          isSquare() {
              return this.tb === 0 && this.tc === 0;
          }
      }
      ElementCoreContext.IDENTITY = new ElementCoreContext();
      ElementCore.sortZIndexedChildren = function (a, b) {
          return (a._zIndex === b._zIndex ? a._updateTreeOrder - b._updateTreeOrder : a._zIndex - b._zIndex);
      };

      class EventEmitter {
          constructor() {
              this._hasEventListeners = false;
          }
          on(name, listener) {
              if (!this._hasEventListeners) {
                  this._eventFunction = {};
                  this._eventListeners = {};
                  this._hasEventListeners = true;
              }
              const current = this._eventFunction[name];
              if (!current) {
                  this._eventFunction[name] = listener;
              } else {
                  if (this._eventFunction[name] !== EventEmitter.combiner) {
                      this._eventListeners[name] = [this._eventFunction[name], listener];
                      this._eventFunction[name] = EventEmitter.combiner;
                  } else {
                      this._eventListeners[name].push(listener);
                  }
              }
          }
          once(name, listener) {
              const wrapper = (arg1, arg2, arg3) => {
                  listener(arg1, arg2, arg3);
                  this.off(name, wrapper);
              };
              wrapper.__originalFunc = listener;
              this.on(name, wrapper);
          }
          has(name, listener) {
              if (this._hasEventListeners) {
                  const current = this._eventFunction[name];
                  if (current) {
                      if (current === EventEmitter.combiner) {
                          const listeners = this._eventListeners[name];
                          for (const l of listeners) {
                              if (l === listener || l.__originalFunc == listener) {
                                  return true;
                              }
                          }
                      } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                          return true;
                      }
                  }
              }
              return false;
          }
          off(name, listener) {
              if (this._hasEventListeners) {
                  const current = this._eventFunction[name];
                  if (current) {
                      if (current === EventEmitter.combiner) {
                          const listeners = this._eventListeners[name];
                          let index = listeners.indexOf(listener);
                          if (index >= 0) {
                              listeners.splice(index, 1);
                          }
                          index = listeners.map((l) => l.__originalFunc).indexOf(listener);
                          if (index >= 0) {
                              listeners.splice(index, 1);
                          }
                          if (listeners.length === 1) {
                              this._eventFunction[name] = listeners[0];
                              this._eventListeners[name] = undefined;
                          }
                      } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                          this._eventFunction[name] = undefined;
                      }
                  }
              }
          }
          removeListener(name, listener) {
              this.off(name, listener);
          }
          emit(name, arg1, arg2, arg3) {
              if (this._hasEventListeners) {
                  const func = this._eventFunction[name];
                  if (func) {
                      if (func === EventEmitter.combiner) {
                          func(this, name, arg1, arg2, arg3);
                      } else {
                          func(arg1, arg2, arg3);
                      }
                  }
              }
          }
          listenerCount(name) {
              if (this._hasEventListeners) {
                  const func = this._eventFunction[name];
                  if (func) {
                      if (func === EventEmitter.combiner) {
                          return this._eventListeners[name].length;
                      } else {
                          return 1;
                      }
                  }
              }
              return 0;
          }
          removeAllListeners(name) {
              if (this._hasEventListeners) {
                  delete this._eventFunction[name];
                  delete this._eventListeners[name];
              }
          }
      }
      EventEmitter.combiner = function(object, name, arg1, arg2, arg3) {
          const listeners = object._eventListeners[name];
          if (listeners) {
              for (const listener of [...listeners]) {
                  listener(arg1, arg2, arg3);
              }
          }
      };
      EventEmitter.addAsMixin = function(cls) {
          cls.prototype.on = EventEmitter.prototype.on;
          cls.prototype.once = EventEmitter.prototype.once;
          cls.prototype.has = EventEmitter.prototype.has;
          cls.prototype.off = EventEmitter.prototype.off;
          cls.prototype.removeListener = EventEmitter.prototype.removeListener;
          cls.prototype.emit = EventEmitter.prototype.emit;
          cls.prototype.listenerCount = EventEmitter.prototype.listenerCount;
          cls.prototype.removeAllListeners = EventEmitter.prototype.removeAllListeners;
      };

      class Shader {
          constructor(coreContext) {
              this._initialized = false;
              this.ctx = coreContext;
              this._elements = new Set();
          }
          static create(stage, v) {
              let shader;
              if (Utils.isObjectLiteral(v)) {
                  if (v.type) {
                      shader = stage.renderer.createShader(stage.ctx, v);
                  } else {
                      shader = this.shader;
                  }
                  if (shader) {
                      Base.patchObject(shader, v);
                  }
              } else if (v === null) {
                  shader = stage.ctx.renderState.defaultShader;
              } else if (v === undefined) {
                  shader = null;
              } else {
                  if (v.isShader) {
                      if (!stage.renderer.isValidShaderType(v.constructor)) {
                          console.error("[Lightning] Invalid shader type");
                          v = null;
                      }
                      shader = v;
                  } else {
                      console.error("[Lightning] Please specify a shader type.");
                      return;
                  }
              }
              return shader;
          }
          static getWebGL() {
              return undefined;
          }
          static getC2d() {
              return undefined;
          }
          addElement(elementCore) {
              this._elements.add(elementCore);
          }
          removeElement(elementCore) {
              this._elements.delete(elementCore);
              if (!this._elements) {
                  this.cleanup();
              }
          }
          redraw() {
              this._elements.forEach(elementCore => {
                  elementCore.setHasRenderUpdates(2);
              });
          }
          patch(settings) {
              Base.patchObject(this, settings);
          }
          useDefault() {
              return false;
          }
          addEmpty() {
              return false;
          }
          cleanup() {
          }
          get isShader() {
              return true;
          }
      }

      class Texture {
          constructor(stage) {
              this.stage = stage;
              this.manager = this.stage.textureManager;
              this.id = Texture.id++;
              this.elements = new Set();
              this._activeCount = 0;
              this._source = null;
              this._resizeMode = null;
              this._x = 0;
              this._y = 0;
              this._w = 0;
              this._h = 0;
              this._precision = 1;
              this.mw = 0;
              this.mh = 0;
              this.clipping = false;
              this._mustUpdate = true;
          }
          get source() {
              if (this._mustUpdate || this.stage.hasUpdateSourceTexture(this)) {
                  this._performUpdateSource(true);
                  this.stage.removeUpdateSourceTexture(this);
              }
              return this._source;
          }
          addElement(v) {
              if (!this.elements.has(v)) {
                  this.elements.add(v);
                  if (this.elements.size === 1) {
                      if (this._source) {
                          this._source.addTexture(this);
                      }
                  }
                  if (v.active) {
                      this.incActiveCount();
                  }
              }
          }
          removeElement(v) {
              if (this.elements.delete(v)) {
                  if (this.elements.size === 0) {
                      if (this._source) {
                          this._source.removeTexture(this);
                      }
                  }
                  if (v.active) {
                      this.decActiveCount();
                  }
              }
          }
          incActiveCount() {
              const source = this.source;
              if (source) {
                  this._checkForNewerReusableTextureSource();
              }
              this._activeCount++;
              if (this._activeCount === 1) {
                  this.becomesUsed();
              }
          }
          decActiveCount() {
              this.source;
              this._activeCount--;
              if (!this._activeCount) {
                  this.becomesUnused();
              }
          }
          becomesUsed() {
              if (this.source) {
                  this.source.incActiveTextureCount();
              }
          }
          onLoad() {
              if (this._resizeMode) {
                  this._applyResizeMode();
              }
              this.elements.forEach(element => {
                  if (element.active) {
                      element.onTextureSourceLoaded();
                  }
              });
          }
          _checkForNewerReusableTextureSource() {
              const source = this.source;
              if (!source.isLoaded()) {
                  const reusable = this._getReusableTextureSource();
                  if (reusable && reusable.isLoaded() && (reusable !== source)) {
                      this._replaceTextureSource(reusable);
                  }
              } else {
                  if (this._resizeMode) {
                      this._applyResizeMode();
                  }
              }
          }
          becomesUnused() {
              if (this.source) {
                  this.source.decActiveTextureCount();
              }
          }
          isUsed() {
              return this._activeCount > 0;
          }
          _getLookupId() {
              return null;
          }
          _getSourceLoader() {
              throw new Error("Texture.generate must be implemented.");
          }
          get isValid() {
              return this._getIsValid();
          }
          _getIsValid() {
              return true;
          }
          _changed() {
              if (this.isUsed()) {
                  this._updateSource();
              } else {
                  this._mustUpdate = true;
              }
          }
          _updateSource() {
              this.stage.addUpdateSourceTexture(this);
          }
          _performUpdateSource(force = false) {
              if (force || this.isUsed()) {
                  this._mustUpdate = false;
                  let source = this._getTextureSource();
                  this._replaceTextureSource(source);
              }
          }
          _getTextureSource() {
              let source = null;
              if (this._getIsValid()) {
                  const lookupId = this._getLookupId();
                  source = this._getReusableTextureSource(lookupId);
                  if (!source) {
                      source = this.manager.getTextureSource(this._getSourceLoader(), lookupId);
                  }
              }
              return source;
          }
          _getReusableTextureSource(lookupId = this._getLookupId()) {
              if (this._getIsValid()) {
                  if (lookupId) {
                      return this.manager.getReusableTextureSource(lookupId);
                  }
              }
              return null;
          }
          _replaceTextureSource(newSource = null) {
              let oldSource = this._source;
              this._source = newSource;
              if (this.elements.size) {
                  if (oldSource) {
                      if (this._activeCount) {
                          oldSource.decActiveTextureCount();
                      }
                      oldSource.removeTexture(this);
                  }
                  if (newSource) {
                      newSource.addTexture(this);
                      if (this._activeCount) {
                          newSource.incActiveTextureCount();
                      }
                  }
              }
              if (this.isUsed()) {
                  if (newSource) {
                      if (newSource.isLoaded()) {
                          if (this._resizeMode) {
                              this._applyResizeMode();
                          }
                          this.elements.forEach(element => {
                              if (element.active) {
                                  element._setDisplayedTexture(this);
                              }
                          });
                      } else {
                          const loadError = newSource.loadError;
                          if (loadError) {
                              this.elements.forEach(element => {
                                  if (element.active) {
                                      element.onTextureSourceLoadError(loadError);
                                  }
                              });
                          }
                      }
                  } else {
                      this.elements.forEach(element => {
                          if (element.active) {
                              element._setDisplayedTexture(null);
                          }
                      });
                  }
              }
          }
          load() {
              if (this.source) {
                  if (!this.isLoaded()) {
                      this.source.load(true);
                  }
              }
          }
          isLoaded() {
              return this._source && this._source.isLoaded();
          }
          get loadError() {
              return this._source && this._source.loadError;
          }
          free() {
              if (this._source) {
                  this._source.free();
              }
          }
          set resizeMode({type = "cover", w = 0, h = 0, clipX = 0.5, clipY = 0.5}) {
              this._resizeMode = {type, w, h, clipX, clipY};
              if (this.isLoaded()) {
                  this._applyResizeMode();
              }
          }
          get resizeMode() {
              return this._resizeMode;
          }
          _clearResizeMode() {
              this._resizeMode = null;
          }
          _applyResizeMode() {
              if (this._resizeMode.type === "cover") {
                  this._applyResizeCover();
              } else if (this._resizeMode.type === "contain") {
                  this._applyResizeContain();
              }
              this._updatePrecision();
              this._updateClipping();
          }
          _applyResizeCover() {
              const scaleX = this._resizeMode.w / this._source.w;
              const scaleY = this._resizeMode.h / this._source.h;
              let scale = Math.max(scaleX, scaleY);
              if (!scale) return;
              this._precision = 1/scale;
              if (scaleX && scaleX < scale) {
                  const desiredSize = this._precision * this._resizeMode.w;
                  const choppedOffPixels = this._source.w - desiredSize;
                  this._x = choppedOffPixels * this._resizeMode.clipX;
                  this._w = this._source.w - choppedOffPixels;
              }
              if (scaleY && scaleY < scale) {
                  const desiredSize = this._precision * this._resizeMode.h;
                  const choppedOffPixels = this._source.h - desiredSize;
                  this._y = choppedOffPixels * this._resizeMode.clipY;
                  this._h = this._source.h - choppedOffPixels;
              }
          }
          _applyResizeContain() {
              const scaleX = this._resizeMode.w / this._source.w;
              const scaleY = this._resizeMode.h / this._source.h;
              let scale = scaleX;
              if (!scale || scaleY < scale) {
                  scale = scaleY;
              }
              if (!scale) return;
              this._precision = 1/scale;
          }
          enableClipping(x, y, w, h) {
              this._clearResizeMode();
              x *= this._precision;
              y *= this._precision;
              w *= this._precision;
              h *= this._precision;
              if (this._x !== x || this._y !== y || this._w !== w || this._h !== h) {
                  this._x = x;
                  this._y = y;
                  this._w = w;
                  this._h = h;
                  this._updateClipping(true);
              }
          }
          disableClipping() {
              this._clearResizeMode();
              if (this._x || this._y || this._w || this._h) {
                  this._x = 0;
                  this._y = 0;
                  this._w = 0;
                  this._h = 0;
                  this._updateClipping();
              }
          }
          _updateClipping() {
              this.clipping = !!(this._x || this._y || this._w || this._h);
              let self = this;
              this.elements.forEach(function(element) {
                  if (element.displayedTexture === self) {
                      element.onDisplayedTextureClippingChanged();
                  }
              });
          }
          _updatePrecision() {
              let self = this;
              this.elements.forEach(function(element) {
                  if (element.displayedTexture === self) {
                      element.onPrecisionChanged();
                  }
              });
          }
          getNonDefaults() {
              let nonDefaults = {};
              nonDefaults['type'] = this.constructor.name;
              if (this.x !== 0) nonDefaults['x'] = this.x;
              if (this.y !== 0) nonDefaults['y'] = this.y;
              if (this.w !== 0) nonDefaults['w'] = this.w;
              if (this.h !== 0) nonDefaults['h'] = this.h;
              if (this.precision !== 1) nonDefaults['precision'] = this.precision;
              return nonDefaults;
          }
          get px() {
              return this._x;
          }
          get py() {
              return this._y;
          }
          get pw() {
              return this._w;
          }
          get ph() {
              return this._h;
          }
          get x() {
              return this._x / this._precision;
          }
          set x(v) {
              this._clearResizeMode();
              v = v * this._precision;
              if (this._x !== v) {
                  this._x = v;
                  this._updateClipping();
              }
          }
          get y() {
              return this._y / this._precision;
          }
          set y(v) {
              this._clearResizeMode();
              v = v * this._precision;
              if (this._y !== v) {
                  this._y = v;
                  this._updateClipping();
              }
          }
          get w() {
              return this._w / this._precision;
          }
          set w(v) {
              this._clearResizeMode();
              v = v * this._precision;
              if (this._w !== v) {
                  this._w = v;
                  this._updateClipping();
              }
          }
          get h() {
              return this._h / this._precision;
          }
          set h(v) {
              this._clearResizeMode();
              v = v * this._precision;
              if (this._h !== v) {
                  this._h = v;
                  this._updateClipping();
              }
          }
          get precision() {
              return this._precision;
          }
          set precision(v) {
              this._clearResizeMode();
              if (this._precision !== v) {
                  this._precision = v;
                  this._updatePrecision();
              }
          }
          isAutosizeTexture() {
              return true;
          }
          getRenderWidth() {
              if (!this.isAutosizeTexture()) {
                  return 0;
              }
              return (this._w || (this._source ? this._source.getRenderWidth() - this._x : 0)) / this._precision;
          }
          getRenderHeight() {
              if (!this.isAutosizeTexture()) {
                  return 0;
              }
              return (this._h || (this._source ? this._source.getRenderHeight() - this._y : 0)) / this._precision;
          }
          patch(settings) {
              Base.patchObject(this, settings);
          }
      }
      Texture.prototype.isTexture = true;
      Texture.id = 0;

      class ImageTexture extends Texture {
          constructor(stage) {
              super(stage);
              this._src = undefined;
              this._hasAlpha = false;
          }
          get src() {
              return this._src;
          }
          set src(v) {
              if (this._src !== v) {
                  this._src = v;
                  this._changed();
              }
          }
          get hasAlpha() {
              return this._hasAlpha;
          }
          set hasAlpha(v) {
              if (this._hasAlpha !== v) {
                  this._hasAlpha = v;
                  this._changed();
              }
          }
          _getIsValid() {
              return !!this._src;
          }
          _getLookupId() {
              return this._src;
          }
          _getSourceLoader() {
              let src = this._src;
              let hasAlpha = this._hasAlpha;
              if (this.stage.getOption('srcBasePath')) {
                  var fc = src.charCodeAt(0);
                  if ((src.indexOf("//") === -1) && ((fc >= 65 && fc <= 90) || (fc >= 97 && fc <= 122) || fc == 46)) {
                      src = this.stage.getOption('srcBasePath') + src;
                  }
              }
              return (cb) => {
                  return this.stage.platform.loadSrcTexture({src: src, hasAlpha: hasAlpha}, cb);
              }
          }
          getNonDefaults() {
              const obj = super.getNonDefaults();
              if (this._src) {
                  obj.src = this._src;
              }
              return obj;
          }
      }

      class TextTextureRenderer {
          constructor(stage, canvas, settings) {
              this._stage = stage;
              this._canvas = canvas;
              this._context = this._canvas.getContext('2d');
              this._settings = settings;
          }
          getPrecision() {
              return this._settings.precision;
          };
          setFontProperties() {
              this._context.font = Utils.isSpark ? this._stage.platform.getFontSetting(this) : this._getFontSetting();
              this._context.textBaseline = this._settings.textBaseline;
          };
          _getFontSetting() {
              let ff = this._settings.fontFace;
              if (!Array.isArray(ff)) {
                  ff = [ff];
              }
              let ffs = [];
              for (let i = 0, n = ff.length; i < n; i++) {
                  if (ff[i] === "serif" || ff[i] === "sans-serif") {
                      ffs.push(ff[i]);
                  } else {
                      ffs.push(`"${ff[i]}"`);
                  }
              }
              return `${this._settings.fontStyle} ${this._settings.fontSize * this.getPrecision()}px ${ffs.join(",")}`
          }
          _load() {
              if (Utils.isWeb && document.fonts) {
                  const fontSetting = this._getFontSetting();
                  try {
                      if (!document.fonts.check(fontSetting, this._settings.text)) {
                          return document.fonts.load(fontSetting, this._settings.text).catch(err => {
                              console.warn('[Lightning] Font load error', err, fontSetting);
                          }).then(() => {
                              if (!document.fonts.check(fontSetting, this._settings.text)) {
                                  console.warn('[Lightning] Font not found', fontSetting);
                              }
                          });
                      }
                  } catch(e) {
                      console.warn("[Lightning] Can't check font loading for " + fontSetting);
                  }
              }
          }
          draw() {
              const loadPromise = this._load();
              if (!loadPromise) {
                  return Utils.isSpark ? this._stage.platform.drawText(this) : this._draw();
              } else {
                  return loadPromise.then(() => {
                      return Utils.isSpark ? this._stage.platform.drawText(this) : this._draw();
                  });
              }
          }
          _calculateRenderInfo() {
              let renderInfo = {};
              const precision = this.getPrecision();
              const paddingLeft = this._settings.paddingLeft * precision;
              const paddingRight = this._settings.paddingRight * precision;
              const fontSize = this._settings.fontSize * precision;
              let offsetY = this._settings.offsetY === null ? null : (this._settings.offsetY * precision);
              let lineHeight = this._settings.lineHeight * precision;
              const w = this._settings.w * precision;
              const h = this._settings.h * precision;
              let wordWrapWidth = this._settings.wordWrapWidth * precision;
              const cutSx = this._settings.cutSx * precision;
              const cutEx = this._settings.cutEx * precision;
              const cutSy = this._settings.cutSy * precision;
              const cutEy = this._settings.cutEy * precision;
              const letterSpacing = (this._settings.letterSpacing || 0) * precision;
              const textIndent = this._settings.textIndent * precision;
              this.setFontProperties();
              let width = w || (2048 / this.getPrecision());
              let innerWidth = width - (paddingLeft);
              if (innerWidth < 10) {
                  width += (10 - innerWidth);
                  innerWidth += (10 - innerWidth);
              }
              if (!wordWrapWidth) {
                  wordWrapWidth = innerWidth;
              }
              if (this._settings.textOverflow && !this._settings.wordWrap) {
                  let suffix;
                  switch (this._settings.textOverflow) {
                      case 'clip':
                          suffix = '';
                          break;
                      case 'ellipsis':
                          suffix = this._settings.maxLinesSuffix;
                          break;
                      default:
                          suffix = this._settings.textOverflow;
                  }
                  this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix);
              }
              let linesInfo;
              if (this._settings.wordWrap) {
                  linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
              } else {
                  linesInfo = {l: this._settings.text.split(/(?:\r\n|\r|\n)/), n: []};
                  let n = linesInfo.l.length;
                  for (let i = 0; i < n - 1; i++) {
                      linesInfo.n.push(i);
                  }
              }
              let lines = linesInfo.l;
              if (this._settings.maxLines && lines.length > this._settings.maxLines) {
                  let usedLines = lines.slice(0, this._settings.maxLines);
                  let otherLines = null;
                  if (this._settings.maxLinesSuffix) {
                      let w = this._settings.maxLinesSuffix ? this.measureText(this._settings.maxLinesSuffix) : 0;
                      let al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - w, letterSpacing, textIndent);
                      usedLines[usedLines.length - 1] = al.l[0] + this._settings.maxLinesSuffix;
                      otherLines = [al.l.length > 1 ? al.l[1] : ''];
                  } else {
                      otherLines = [''];
                  }
                  let i, n = lines.length;
                  let j = 0;
                  let m = linesInfo.n.length;
                  for (i = this._settings.maxLines; i < n; i++) {
                      otherLines[j] += (otherLines[j] ? " " : "") + lines[i];
                      if (i + 1 < m && linesInfo.n[i + 1]) {
                          j++;
                      }
                  }
                  renderInfo.remainingText = otherLines.join("\n");
                  renderInfo.moreTextLines = true;
                  lines = usedLines;
              } else {
                  renderInfo.moreTextLines = false;
                  renderInfo.remainingText = "";
              }
              let maxLineWidth = 0;
              let lineWidths = [];
              for (let i = 0; i < lines.length; i++) {
                  let lineWidth = this.measureText(lines[i], letterSpacing) + (i === 0 ? textIndent : 0);
                  lineWidths.push(lineWidth);
                  maxLineWidth = Math.max(maxLineWidth, lineWidth);
              }
              renderInfo.lineWidths = lineWidths;
              if (!w) {
                  width = maxLineWidth + paddingLeft + paddingRight;
                  innerWidth = maxLineWidth;
              }
              lineHeight = lineHeight || fontSize;
              let height;
              if (h) {
                  height = h;
              } else {
                  height = lineHeight * (lines.length - 1) + 0.5 * fontSize + Math.max(lineHeight, fontSize) + offsetY;
              }
              if (offsetY === null) {
                  offsetY = fontSize;
              }
              renderInfo.w = width;
              renderInfo.h = height;
              renderInfo.lines = lines;
              renderInfo.precision = precision;
              if (!width) {
                  width = 1;
              }
              if (!height) {
                  height = 1;
              }
              if (cutSx || cutEx) {
                  width = Math.min(width, cutEx - cutSx);
              }
              if (cutSy || cutEy) {
                  height = Math.min(height, cutEy - cutSy);
              }
              renderInfo.width = width;
              renderInfo.innerWidth = innerWidth;
              renderInfo.height = height;
              renderInfo.fontSize = fontSize;
              renderInfo.cutSx = cutSx;
              renderInfo.cutSy = cutSy;
              renderInfo.cutEx = cutEx;
              renderInfo.cutEy = cutEy;
              renderInfo.lineHeight = lineHeight;
              renderInfo.lineWidths = lineWidths;
              renderInfo.offsetY = offsetY;
              renderInfo.paddingLeft = paddingLeft;
              renderInfo.paddingRight = paddingRight;
              renderInfo.letterSpacing = letterSpacing;
              renderInfo.textIndent = textIndent;
              return renderInfo;
          }
          _draw() {
              const renderInfo = this._calculateRenderInfo();
              const precision = this.getPrecision();
              this._canvas.width = Math.ceil(renderInfo.width + this._stage.getOption('textRenderIssueMargin'));
              this._canvas.height = Math.ceil(renderInfo.height);
              this.setFontProperties();
              if (renderInfo.fontSize >= 128) {
                  this._context.globalAlpha = 0.01;
                  this._context.fillRect(0, 0, 0.01, 0.01);
                  this._context.globalAlpha = 1.0;
              }
              if (renderInfo.cutSx || renderInfo.cutSy) {
                  this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
              }
              let linePositionX;
              let linePositionY;
              let drawLines = [];
              for (let i = 0, n = renderInfo.lines.length; i < n; i++) {
                  linePositionX = i === 0 ? renderInfo.textIndent : 0;
                  linePositionY = (i * renderInfo.lineHeight) + renderInfo.offsetY;
                  if (this._settings.verticalAlign == 'middle') {
                      linePositionY += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
                  } else if (this._settings.verticalAlign == 'bottom') {
                      linePositionY += renderInfo.lineHeight - renderInfo.fontSize;
                  }
                  if (this._settings.textAlign === 'right') {
                      linePositionX += (renderInfo.innerWidth - renderInfo.lineWidths[i]);
                  } else if (this._settings.textAlign === 'center') {
                      linePositionX += ((renderInfo.innerWidth - renderInfo.lineWidths[i]) / 2);
                  }
                  linePositionX += renderInfo.paddingLeft;
                  drawLines.push({text: renderInfo.lines[i], x: linePositionX, y: linePositionY, w: renderInfo.lineWidths[i]});
              }
              if (this._settings.highlight) {
                  let color = this._settings.highlightColor || 0x00000000;
                  let hlHeight = (this._settings.highlightHeight * precision || renderInfo.fontSize * 1.5);
                  const offset = this._settings.highlightOffset * precision;
                  const hlPaddingLeft = (this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision : renderInfo.paddingLeft);
                  const hlPaddingRight = (this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision : renderInfo.paddingRight);
                  this._context.fillStyle = StageUtils.getRgbaString(color);
                  for (let i = 0; i < drawLines.length; i++) {
                      let drawLine = drawLines[i];
                      this._context.fillRect((drawLine.x - hlPaddingLeft), (drawLine.y - renderInfo.offsetY + offset), (drawLine.w + hlPaddingRight + hlPaddingLeft), hlHeight);
                  }
              }
              let prevShadowSettings = null;
              if (this._settings.shadow) {
                  prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];
                  this._context.shadowColor = StageUtils.getRgbaString(this._settings.shadowColor);
                  this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
                  this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
                  this._context.shadowBlur = this._settings.shadowBlur * precision;
              }
              this._context.fillStyle = StageUtils.getRgbaString(this._settings.textColor);
              for (let i = 0, n = drawLines.length; i < n; i++) {
                  let drawLine = drawLines[i];
                  if (renderInfo.letterSpacing === 0) {
                      this._context.fillText(drawLine.text, drawLine.x, drawLine.y);
                  } else {
                      const textSplit = drawLine.text.split('');
                      let x = drawLine.x;
                      for (let i = 0, j = textSplit.length; i < j; i++) {
                          this._context.fillText(textSplit[i], x, drawLine.y);
                          x += this.measureText(textSplit[i], renderInfo.letterSpacing);
                      }
                  }
              }
              if (prevShadowSettings) {
                  this._context.shadowColor = prevShadowSettings[0];
                  this._context.shadowOffsetX = prevShadowSettings[1];
                  this._context.shadowOffsetY = prevShadowSettings[2];
                  this._context.shadowBlur = prevShadowSettings[3];
              }
              if (renderInfo.cutSx || renderInfo.cutSy) {
                  this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
              }
              this.renderInfo = renderInfo;
          };
          wrapWord(word, wordWrapWidth, suffix) {
              const suffixWidth = this._context.measureText(suffix).width;
              const wordLen = word.length;
              const wordWidth = this._context.measureText(word).width;
              if (wordWidth <= wordWrapWidth) {
                  return word;
              }
              let cutoffIndex = Math.floor((wordWrapWidth * wordLen) / wordWidth);
              let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
              if (truncWordWidth > wordWrapWidth) {
                  while (cutoffIndex > 0) {
                      truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                      if (truncWordWidth > wordWrapWidth) {
                          cutoffIndex -= 1;
                      } else {
                          break;
                      }
                  }
              } else {
                  while (cutoffIndex < wordLen) {
                      truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                      if (truncWordWidth < wordWrapWidth) {
                          cutoffIndex += 1;
                      } else {
                          cutoffIndex -=1;
                          break;
                      }
                  }
              }
              return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '');
          }
          wrapText(text, wordWrapWidth, letterSpacing, indent = 0) {
              let lines = text.split(/\r?\n/g);
              let allLines = [];
              let realNewlines = [];
              for (let i = 0; i < lines.length; i++) {
                  let resultLines = [];
                  let result = '';
                  let spaceLeft = wordWrapWidth - indent;
                  let words = lines[i].split(' ');
                  for (let j = 0; j < words.length; j++) {
                      const wordWidth = this.measureText(words[j], letterSpacing);
                      const wordWidthWithSpace = wordWidth + this.measureText(' ',letterSpacing);
                      if (j === 0 || wordWidthWithSpace > spaceLeft) {
                          if (j > 0) {
                              resultLines.push(result);
                              result = '';
                          }
                          result += words[j];
                          spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
                      }
                      else {
                          spaceLeft -= wordWidthWithSpace;
                          result += ' ' + words[j];
                      }
                  }
                  resultLines.push(result);
                  result = '';
                  allLines = allLines.concat(resultLines);
                  if (i < lines.length - 1) {
                      realNewlines.push(allLines.length);
                  }
              }
              return {l: allLines, n: realNewlines};
          };
          measureText(word, space = 0) {
              if (!space) {
                  return this._context.measureText(word).width;
              }
              return word.split('').reduce((acc, char) => {
                  return acc + this._context.measureText(char).width + space;
              }, 0);
          }
      }

      class TextTexture extends Texture {
          constructor(stage) {
              super(stage);
              this._precision = this.stage.getOption('precision');
          }
          static renderer(stage, canvas, settings) {
              return new TextTextureRenderer(stage, canvas, settings);
          }
          get text() {
              return this._text;
          }
          set text(v) {
              if (this._text !== v) {
                  this._text = "" + v;
                  this._changed();
              }
          }
          get w() {
              return this._w;
          }
          set w(v) {
              if (this._w !== v) {
                  this._w = v;
                  this._changed();
              }
          }
          get h() {
              return this._h;
          }
          set h(v) {
              if (this._h !== v) {
                  this._h = v;
                  this._changed();
              }
          }
          get fontStyle() {
              return this._fontStyle;
          }
          set fontStyle(v) {
              if (this._fontStyle !== v) {
                  this._fontStyle = v;
                  this._changed();
              }
          }
          get fontSize() {
              return this._fontSize;
          }
          set fontSize(v) {
              if (this._fontSize !== v) {
                  this._fontSize = v;
                  this._changed();
              }
          }
          get fontFace() {
              return this._fontFace;
          }
          set fontFace(v) {
              if (this._fontFace !== v) {
                  this._fontFace = v;
                  this._changed();
              }
          }
          get wordWrap() {
              return this._wordWrap;
          }
          set wordWrap(v) {
              if (this._wordWrap !== v) {
                  this._wordWrap = v;
                  this._changed();
              }
          }
          get wordWrapWidth() {
              return this._wordWrapWidth;
          }
          set wordWrapWidth(v) {
              if (this._wordWrapWidth !== v) {
                  this._wordWrapWidth = v;
                  this._changed();
              }
          }
          get textOverflow() {
              return this._textOverflow;
          }
          set textOverflow(v) {
              if (v != this._textOverflow) {
                  this._textOverflow = v;
                  this._changed();
              }
          }
          get lineHeight() {
              return this._lineHeight;
          }
          set lineHeight(v) {
              if (this._lineHeight !== v) {
                  this._lineHeight = v;
                  this._changed();
              }
          }
          get textBaseline() {
              return this._textBaseline;
          }
          set textBaseline(v) {
              if (this._textBaseline !== v) {
                  this._textBaseline = v;
                  this._changed();
              }
          }
          get textAlign() {
              return this._textAlign;
          }
          set textAlign(v) {
              if (this._textAlign !== v) {
                  this._textAlign = v;
                  this._changed();
              }
          }
          get verticalAlign() {
              return this._verticalAlign;
          }
          set verticalAlign(v) {
              if (this._verticalAlign !== v) {
                  this._verticalAlign = v;
                  this._changed();
              }
          }
          get offsetY() {
              return this._offsetY;
          }
          set offsetY(v) {
              if (this._offsetY !== v) {
                  this._offsetY = v;
                  this._changed();
              }
          }
          get maxLines() {
              return this._maxLines;
          }
          set maxLines(v) {
              if (this._maxLines !== v) {
                  this._maxLines = v;
                  this._changed();
              }
          }
          get maxLinesSuffix() {
              return this._maxLinesSuffix;
          }
          set maxLinesSuffix(v) {
              if (this._maxLinesSuffix !== v) {
                  this._maxLinesSuffix = v;
                  this._changed();
              }
          }
          get textColor() {
              return this._textColor;
          }
          set textColor(v) {
              if (this._textColor !== v) {
                  this._textColor = v;
                  this._changed();
              }
          }
          get paddingLeft() {
              return this._paddingLeft;
          }
          set paddingLeft(v) {
              if (this._paddingLeft !== v) {
                  this._paddingLeft = v;
                  this._changed();
              }
          }
          get paddingRight() {
              return this._paddingRight;
          }
          set paddingRight(v) {
              if (this._paddingRight !== v) {
                  this._paddingRight = v;
                  this._changed();
              }
          }
          get shadow() {
              return this._shadow;
          }
          set shadow(v) {
              if (this._shadow !== v) {
                  this._shadow = v;
                  this._changed();
              }
          }
          get shadowColor() {
              return this._shadowColor;
          }
          set shadowColor(v) {
              if (this._shadowColor !== v) {
                  this._shadowColor = v;
                  this._changed();
              }
          }
          get shadowOffsetX() {
              return this._shadowOffsetX;
          }
          set shadowOffsetX(v) {
              if (this._shadowOffsetX !== v) {
                  this._shadowOffsetX = v;
                  this._changed();
              }
          }
          get shadowOffsetY() {
              return this._shadowOffsetY;
          }
          set shadowOffsetY(v) {
              if (this._shadowOffsetY !== v) {
                  this._shadowOffsetY = v;
                  this._changed();
              }
          }
          get shadowBlur() {
              return this._shadowBlur;
          }
          set shadowBlur(v) {
              if (this._shadowBlur !== v) {
                  this._shadowBlur = v;
                  this._changed();
              }
          }
          get highlight() {
              return this._highlight;
          }
          set highlight(v) {
              if (this._highlight !== v) {
                  this._highlight = v;
                  this._changed();
              }
          }
          get highlightHeight() {
              return this._highlightHeight;
          }
          set highlightHeight(v) {
              if (this._highlightHeight !== v) {
                  this._highlightHeight = v;
                  this._changed();
              }
          }
          get highlightColor() {
              return this._highlightColor;
          }
          set highlightColor(v) {
              if (this._highlightColor !== v) {
                  this._highlightColor = v;
                  this._changed();
              }
          }
          get highlightOffset() {
              return this._highlightOffset;
          }
          set highlightOffset(v) {
              if (this._highlightOffset !== v) {
                  this._highlightOffset = v;
                  this._changed();
              }
          }
          get highlightPaddingLeft() {
              return this._highlightPaddingLeft;
          }
          set highlightPaddingLeft(v) {
              if (this._highlightPaddingLeft !== v) {
                  this._highlightPaddingLeft = v;
                  this._changed();
              }
          }
          get highlightPaddingRight() {
              return this._highlightPaddingRight;
          }
          set highlightPaddingRight(v) {
              if (this._highlightPaddingRight !== v) {
                  this._highlightPaddingRight = v;
                  this._changed();
              }
          }
          get cutSx() {
              return this._cutSx;
          }
          set cutSx(v) {
              if (this._cutSx !== v) {
                  this._cutSx = v;
                  this._changed();
              }
          }
          get cutEx() {
              return this._cutEx;
          }
          set cutEx(v) {
              if (this._cutEx !== v) {
                  this._cutEx = v;
                  this._changed();
              }
          }
          get cutSy() {
              return this._cutSy;
          }
          set cutSy(v) {
              if (this._cutSy !== v) {
                  this._cutSy = v;
                  this._changed();
              }
          }
          get cutEy() {
              return this._cutEy;
          }
          set cutEy(v) {
              if (this._cutEy !== v) {
                  this._cutEy = v;
                  this._changed();
              }
          }
          set letterSpacing(v) {
              if (this._letterSpacing !== v) {
                  this._letterSpacing = v;
                  this._changed();
              }
          }
          get letterSpacing() {
              return this._letterSpacing;
          }
          set textIndent(v) {
              if (this._textIndent !== v) {
                  this._textIndent = v;
                  this._changed();
              }
          }
          get textIndent() {
              return this._textIndent;
          }
          get precision() {
              return super.precision;
          }
          set precision(v) {
              if (this.precision !== v) {
                  super.precision = v;
                  this._changed();
              }
          }
          _getIsValid() {
              return !!this.text;
          }
          _getLookupId() {
              let parts = [];
              if (this.w !== 0) parts.push("w " + this.w);
              if (this.h !== 0) parts.push("h " + this.h);
              if (this.fontStyle !== "normal") parts.push("fS" + this.fontStyle);
              if (this.fontSize !== 40) parts.push("fs" + this.fontSize);
              if (this.fontFace !== null) parts.push("ff" + (Array.isArray(this.fontFace) ? this.fontFace.join(",") : this.fontFace));
              if (this.wordWrap !== true) parts.push("wr" + (this.wordWrap ? 1 : 0));
              if (this.wordWrapWidth !== 0) parts.push("ww" + this.wordWrapWidth);
              if (this.textOverflow != "") parts.push("to" + this.textOverflow);
              if (this.lineHeight !== null) parts.push("lh" + this.lineHeight);
              if (this.textBaseline !== "alphabetic") parts.push("tb" + this.textBaseline);
              if (this.textAlign !== "left") parts.push("ta" + this.textAlign);
              if (this.verticalAlign !== "top") parts.push("va" + this.verticalAlign);
              if (this.offsetY !== null) parts.push("oy" + this.offsetY);
              if (this.maxLines !== 0) parts.push("ml" + this.maxLines);
              if (this.maxLinesSuffix !== "..") parts.push("ms" + this.maxLinesSuffix);
              parts.push("pc" + this.precision);
              if (this.textColor !== 0xffffffff) parts.push("co" + this.textColor.toString(16));
              if (this.paddingLeft !== 0) parts.push("pl" + this.paddingLeft);
              if (this.paddingRight !== 0) parts.push("pr" + this.paddingRight);
              if (this.shadow !== false) parts.push("sh" + (this.shadow ? 1 : 0));
              if (this.shadowColor !== 0xff000000) parts.push("sc" + this.shadowColor.toString(16));
              if (this.shadowOffsetX !== 0) parts.push("sx" + this.shadowOffsetX);
              if (this.shadowOffsetY !== 0) parts.push("sy" + this.shadowOffsetY);
              if (this.shadowBlur !== 5) parts.push("sb" + this.shadowBlur);
              if (this.highlight !== false) parts.push("hL" + (this.highlight ? 1 : 0));
              if (this.highlightHeight !== 0) parts.push("hh" + this.highlightHeight);
              if (this.highlightColor !== 0xff000000) parts.push("hc" + this.highlightColor.toString(16));
              if (this.highlightOffset !== null) parts.push("ho" + this.highlightOffset);
              if (this.highlightPaddingLeft !== null) parts.push("hl" + this.highlightPaddingLeft);
              if (this.highlightPaddingRight !== null) parts.push("hr" + this.highlightPaddingRight);
              if (this.letterSpacing !== null) parts.push("ls" + this.letterSpacing);
              if (this.textIndent !== null) parts.push("ti" + this.textIndent);
              if (this.cutSx) parts.push("csx" + this.cutSx);
              if (this.cutEx) parts.push("cex" + this.cutEx);
              if (this.cutSy) parts.push("csy" + this.cutSy);
              if (this.cutEy) parts.push("cey" + this.cutEy);
              let id = "TX$" + parts.join("|") + ":" + this.text;
              return id;
          }
          _getSourceLoader() {
              const args = this.cloneArgs();
              if (args.fontFace === null) {
                  args.fontFace = this.stage.getOption('defaultFontFace');
              }
              return function (cb) {
                  const canvas = this.stage.platform.getDrawingCanvas();
                  const renderer = new TextTextureRenderer(this.stage, canvas, args);
                  const p = renderer.draw();
                  if (p) {
                      p.then(() => {
                          cb(null, Object.assign({
                              renderInfo: renderer.renderInfo,
                              throttle: false
                          }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
                      }).catch((err) => {
                          cb(err);
                      });
                  } else {
                      cb(null, Object.assign({
                          renderInfo: renderer.renderInfo,
                          throttle: false
                      }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
                  }
              };
          }
          getNonDefaults() {
              const nonDefaults = super.getNonDefaults();
              if (this.text !== "") nonDefaults['text'] = this.text;
              if (this.w !== 0) nonDefaults['w'] = this.w;
              if (this.h !== 0) nonDefaults['h'] = this.h;
              if (this.fontStyle !== "normal") nonDefaults['fontStyle'] = this.fontStyle;
              if (this.fontSize !== 40) nonDefaults["fontSize"] = this.fontSize;
              if (this.fontFace !== null) nonDefaults["fontFace"] = this.fontFace;
              if (this.wordWrap !== true) nonDefaults["wordWrap"] = this.wordWrap;
              if (this.wordWrapWidth !== 0) nonDefaults["wordWrapWidth"] = this.wordWrapWidth;
              if (this.textOverflow != "") nonDefaults["textOverflow"] = this.textOverflow;
              if (this.lineHeight !== null) nonDefaults["lineHeight"] = this.lineHeight;
              if (this.textBaseline !== "alphabetic") nonDefaults["textBaseline"] = this.textBaseline;
              if (this.textAlign !== "left") nonDefaults["textAlign"] = this.textAlign;
              if (this.verticalAlign !== "top") nonDefaults["verticalAlign"] = this.verticalAlign;
              if (this.offsetY !== null) nonDefaults["offsetY"] = this.offsetY;
              if (this.maxLines !== 0) nonDefaults["maxLines"] = this.maxLines;
              if (this.maxLinesSuffix !== "..") nonDefaults["maxLinesSuffix"] = this.maxLinesSuffix;
              if (this.precision !== this.stage.getOption('precision')) nonDefaults["precision"] = this.precision;
              if (this.textColor !== 0xffffffff) nonDefaults["textColor"] = this.textColor;
              if (this.paddingLeft !== 0) nonDefaults["paddingLeft"] = this.paddingLeft;
              if (this.paddingRight !== 0) nonDefaults["paddingRight"] = this.paddingRight;
              if (this.shadow !== false) nonDefaults["shadow"] = this.shadow;
              if (this.shadowColor !== 0xff000000) nonDefaults["shadowColor"] = this.shadowColor;
              if (this.shadowOffsetX !== 0) nonDefaults["shadowOffsetX"] = this.shadowOffsetX;
              if (this.shadowOffsetY !== 0) nonDefaults["shadowOffsetY"] = this.shadowOffsetY;
              if (this.shadowBlur !== 5) nonDefaults["shadowBlur"] = this.shadowBlur;
              if (this.highlight !== false) nonDefaults["highlight"] = this.highlight;
              if (this.highlightHeight !== 0) nonDefaults["highlightHeight"] = this.highlightHeight;
              if (this.highlightColor !== 0xff000000) nonDefaults["highlightColor"] = this.highlightColor;
              if (this.highlightOffset !== 0) nonDefaults["highlightOffset"] = this.highlightOffset;
              if (this.highlightPaddingLeft !== 0) nonDefaults["highlightPaddingLeft"] = this.highlightPaddingLeft;
              if (this.highlightPaddingRight !== 0) nonDefaults["highlightPaddingRight"] = this.highlightPaddingRight;
              if (this.letterSpacing !== 0) nonDefaults["letterSpacing"] = this.letterSpacing;
              if (this.textIndent !== 0) nonDefaults["textIndent"] = this.textIndent;
              if (this.cutSx) nonDefaults["cutSx"] = this.cutSx;
              if (this.cutEx) nonDefaults["cutEx"] = this.cutEx;
              if (this.cutSy) nonDefaults["cutSy"] = this.cutSy;
              if (this.cutEy) nonDefaults["cutEy"] = this.cutEy;
              return nonDefaults;
          }
          cloneArgs() {
              let obj = {};
              obj.text = this._text;
              obj.w = this._w;
              obj.h = this._h;
              obj.fontStyle = this._fontStyle;
              obj.fontSize = this._fontSize;
              obj.fontFace = this._fontFace;
              obj.wordWrap = this._wordWrap;
              obj.wordWrapWidth = this._wordWrapWidth;
              obj.textOverflow = this._textOverflow;
              obj.lineHeight = this._lineHeight;
              obj.textBaseline = this._textBaseline;
              obj.textAlign = this._textAlign;
              obj.verticalAlign = this._verticalAlign;
              obj.offsetY = this._offsetY;
              obj.maxLines = this._maxLines;
              obj.maxLinesSuffix = this._maxLinesSuffix;
              obj.precision = this._precision;
              obj.textColor = this._textColor;
              obj.paddingLeft = this._paddingLeft;
              obj.paddingRight = this._paddingRight;
              obj.shadow = this._shadow;
              obj.shadowColor = this._shadowColor;
              obj.shadowOffsetX = this._shadowOffsetX;
              obj.shadowOffsetY = this._shadowOffsetY;
              obj.shadowBlur = this._shadowBlur;
              obj.highlight = this._highlight;
              obj.highlightHeight = this._highlightHeight;
              obj.highlightColor = this._highlightColor;
              obj.highlightOffset = this._highlightOffset;
              obj.highlightPaddingLeft = this._highlightPaddingLeft;
              obj.highlightPaddingRight = this._highlightPaddingRight;
              obj.letterSpacing = this._letterSpacing;
              obj.textIndent = this._textIndent;
              obj.cutSx = this._cutSx;
              obj.cutEx = this._cutEx;
              obj.cutSy = this._cutSy;
              obj.cutEy = this._cutEy;
              return obj;
          }
      }
      let proto = TextTexture.prototype;
      proto._text = "";
      proto._w = 0;
      proto._h = 0;
      proto._fontStyle = "normal";
      proto._fontSize = 40;
      proto._fontFace = null;
      proto._wordWrap = true;
      proto._wordWrapWidth = 0;
      proto._textOverflow = "";
      proto._lineHeight = null;
      proto._textBaseline = "alphabetic";
      proto._textAlign = "left";
      proto._verticalAlign = "top";
      proto._offsetY = null;
      proto._maxLines = 0;
      proto._maxLinesSuffix = "..";
      proto._textColor = 0xFFFFFFFF;
      proto._paddingLeft = 0;
      proto._paddingRight = 0;
      proto._shadow = false;
      proto._shadowColor = 0xFF000000;
      proto._shadowOffsetX = 0;
      proto._shadowOffsetY = 0;
      proto._shadowBlur = 5;
      proto._highlight = false;
      proto._highlightHeight = 0;
      proto._highlightColor = 0xFF000000;
      proto._highlightOffset = 0;
      proto._highlightPaddingLeft = 0;
      proto._highlightPaddingRight = 0;
      proto._letterSpacing = 0;
      proto._textIndent = 0;
      proto._cutSx = 0;
      proto._cutEx = 0;
      proto._cutSy = 0;
      proto._cutEy = 0;

      class SourceTexture extends Texture {
          constructor(stage) {
              super(stage);
              this._textureSource = undefined;
          }
          get textureSource() {
              return this._textureSource;
          }
          set textureSource(v) {
              if (v !== this._textureSource) {
                  if (v.isResultTexture) {
                      this._precision = this.stage.getRenderPrecision();
                  }
                  this._textureSource = v;
                  this._changed();
              }
          }
          _getTextureSource() {
              return this._textureSource;
          }
      }

      class Transition extends EventEmitter {
          constructor(manager, settings, element, property) {
              super();
              this.manager = manager;
              this._settings = settings;
              this._element = element;
              this._getter = element.constructor.getGetter(property);
              this._setter = element.constructor.getSetter(property);
              this._merger = settings.merger;
              if (!this._merger) {
                  this._merger = element.constructor.getMerger(property);
              }
              this._startValue = this._getter(this._element);
              this._targetValue = this._startValue;
              this._p = 1;
              this._delayLeft = 0;
          }
          start(targetValue) {
              this._startValue = this._getter(this._element);
              if (!this.isAttached()) {
                  this._targetValue = targetValue;
                  this._p = 1;
                  this._updateDrawValue();
              } else {
                  if (targetValue === this._startValue) {
                      this.reset(targetValue, 1);
                  } else {
                      this._targetValue = targetValue;
                      this._p = 0;
                      this._delayLeft = this._settings.delay;
                      this.emit('start');
                      this.add();
                  }
              }
          }
          finish() {
              if (this._p < 1) {
                  this._p = 1;
              }
          }
          stop() {
              this.emit('stop');
              this.manager.removeActive(this);
          }
          pause() {
              this.stop();
          }
          play() {
              this.manager.addActive(this);
          }
          reset(targetValue, p) {
              if (!this.isAttached()) {
                  this._startValue = this._getter(this._element);
                  this._targetValue = targetValue;
                  this._p = 1;
                  this._updateDrawValue();
              } else {
                  this._startValue = this._getter(this._element);
                  this._targetValue = targetValue;
                  this._p = p;
                  this.add();
              }
          }
          _updateDrawValue() {
              this._setter(this._element, this.getDrawValue());
          }
          add() {
              this.manager.addActive(this);
          }
          isAttached() {
              return this._element.attached;
          }
          isRunning() {
              return (this._p < 1.0);
          }
          progress(dt) {
              if (!this.isAttached()) {
                  this._p = 1;
              }
              if (this.p < 1) {
                  if (this.delayLeft > 0) {
                      this._delayLeft -= dt;
                      if (this.delayLeft < 0) {
                          dt = -this.delayLeft;
                          this._delayLeft = 0;
                          this.emit('delayEnd');
                      } else {
                          return;
                      }
                  }
                  if (this._settings.duration == 0) {
                      this._p = 1;
                  } else {
                      this._p += dt / this._settings.duration;
                  }
                  if (this._p >= 1) {
                      this._p = 1;
                  }
              }
              this._updateDrawValue();
              this.invokeListeners();
          }
          invokeListeners() {
              this.emit('progress', this.p);
              if (this.p === 1) {
                  this.emit('finish');
              }
          }
          updateTargetValue(targetValue) {
              let t = this._settings.timingFunctionImpl(this.p);
              if (t === 1) {
                  this._targetValue = targetValue;
              } else if (t === 0) {
                  this._startValue = this._targetValue;
                  this._targetValue = targetValue;
              } else {
                  this._startValue = targetValue - ((targetValue - this._targetValue) / (1 - t));
                  this._targetValue = targetValue;
              }
          }
          getDrawValue() {
              if (this.p >= 1) {
                  return this.targetValue;
              } else {
                  let v = this._settings._timingFunctionImpl(this.p);
                  return this._merger(this.targetValue, this.startValue, v);
              }
          }
          skipDelay() {
              this._delayLeft = 0;
          }
          get startValue() {
              return this._startValue;
          }
          get targetValue() {
              return this._targetValue;
          }
          get p() {
              return this._p;
          }
          get delayLeft() {
              return this._delayLeft;
          }
          get element() {
              return this._element;
          }
          get settings() {
              return this._settings;
          }
          set settings(v) {
              this._settings = v;
          }
      }
      Transition.prototype.isTransition = true;

      class ObjectList {
          constructor() {
              this._items = [];
              this._refs = {};
          }
          get() {
              return this._items;
          }
          get first() {
              return this._items[0];
          }
          get last() {
              return this._items.length ? this._items[this._items.length - 1] : undefined;
          }
          add(item) {
              this.addAt(item, this._items.length);
          }
          addAt(item, index) {
              if (index >= 0 && index <= this._items.length) {
                  let currentIndex = this._items.indexOf(item);
                  if (currentIndex === index) {
                      return item;
                  }
                  if (currentIndex != -1) {
                      this.setAt(item, index);
                  } else {
                      if (item.ref) {
                          this._refs[item.ref] = item;
                      }
                      this._items.splice(index, 0, item);
                      this.onAdd(item, index);
                  }
              } else {
                  throw new Error('addAt: The index ' + index + ' is out of bounds ' + this._items.length);
              }
          }
          replaceByRef(item) {
              if (item.ref) {
                  const existingItem = this.getByRef(item.ref);
                  if (!existingItem) {
                      throw new Error('replaceByRef: no item found with reference: ' + item.ref);
                  }
                  this.replace(item, existingItem);
              } else {
                  throw new Error('replaceByRef: no ref specified in item');
              }
              this.addAt(item, this._items.length);
          }
          replace(item, prevItem) {
              const index = this.getIndex(prevItem);
              if (index === -1) {
                  throw new Error('replace: The previous item does not exist');
              }
              this.setAt(item, index);
          }
          setAt(item, index) {
              if (index >= 0 && index <= this._items.length) {
                  let currentIndex = this._items.indexOf(item);
                  if (currentIndex != -1) {
                      if (currentIndex !== index) {
                          const fromIndex = currentIndex;
                          if (fromIndex !== index) {
                              this._items.splice(fromIndex, 1);
                              this._items.splice(index, 0, item);
                              this.onMove(item, fromIndex, index);
                          }
                      }
                  } else {
                      if (index < this._items.length) {
                          if (this._items[index].ref) {
                              this._refs[this._items[index].ref] = undefined;
                          }
                      }
                      const prevItem = this._items[index];
                      this._items[index] = item;
                      if (item.ref) {
                          this._refs[item.ref] = item;
                      }
                      this.onSet(item, index, prevItem);
                  }
              } else {
                  throw new Error('setAt: The index ' + index + ' is out of bounds ' + this._items.length);
              }
          }
          getAt(index) {
              return this._items[index];
          }
          getIndex(item) {
              return this._items.indexOf(item);
          }
          remove(item) {
              let index = this._items.indexOf(item);
              if (index !== -1) {
                  this.removeAt(index);
              }
          };
          removeAt(index) {
              let item = this._items[index];
              if (item.ref) {
                  this._refs[item.ref] = undefined;
              }
              this._items.splice(index, 1);
              this.onRemove(item, index);
              return item;
          };
          clear() {
              let n = this._items.length;
              if (n) {
                  let prev = this._items;
                  this._items = [];
                  this._refs = {};
                  this.onSync(prev, [], []);
              }
          };
          a(o) {
              if (Utils.isObjectLiteral(o)) {
                  let c = this.createItem(o);
                  c.patch(o);
                  this.add(c);
                  return c;
              } else if (Array.isArray(o)) {
                  for (let i = 0, n = o.length; i < n; i++) {
                      this.a(o[i]);
                  }
                  return null;
              } else if (this.isItem(o)) {
                  this.add(o);
                  return o;
              }
          };
          get length() {
              return this._items.length;
          }
          _getRefs() {
              return this._refs;
          }
          getByRef(ref) {
              return this._refs[ref];
          }
          clearRef(ref) {
              delete this._refs[ref];
          }
          setRef(ref, child) {
              this._refs[ref] = child;
          }
          patch(settings) {
              if (Utils.isObjectLiteral(settings)) {
                  this._setByObject(settings);
              } else if (Array.isArray(settings)) {
                  this._setByArray(settings);
              }
          }
          _setByObject(settings) {
              let refs = this._getRefs();
              let crefs = Object.keys(settings);
              for (let i = 0, n = crefs.length; i < n; i++) {
                  let cref = crefs[i];
                  let s = settings[cref];
                  let c = refs[cref];
                  if (!c) {
                      if (this.isItem(s)) {
                          s.ref = cref;
                          this.add(s);
                      } else {
                          c = this.createItem(s);
                          c.ref = cref;
                          c.patch(s);
                          this.add(c);
                      }
                  } else {
                      if (this.isItem(s)) {
                          if (c !== s) {
                              let idx = this.getIndex(c);
                              s.ref = cref;
                              this.setAt(s, idx);
                          }
                      } else {
                          c.patch(s);
                      }
                  }
              }
          }
          _equalsArray(array) {
              let same = true;
              if (array.length === this._items.length) {
                  for (let i = 0, n = this._items.length; (i < n) && same; i++) {
                      same = same && (this._items[i] === array[i]);
                  }
              } else {
                  same = false;
              }
              return same;
          }
          _setByArray(array) {
              if (this._equalsArray(array)) {
                  return;
              }
              for (let i = 0, n = this._items.length; i < n; i++) {
                  this._items[i].marker = true;
              }
              let refs;
              let newItems = [];
              for (let i = 0, n = array.length; i < n; i++) {
                  let s = array[i];
                  if (this.isItem(s)) {
                      s.marker = false;
                      newItems.push(s);
                  } else {
                      let cref = s.ref;
                      let c;
                      if (cref) {
                          if (!refs) refs = this._getRefs();
                          c = refs[cref];
                      }
                      if (!c) {
                          c = this.createItem(s);
                      } else {
                          c.marker = false;
                      }
                      if (Utils.isObjectLiteral(s)) {
                          c.patch(s);
                      }
                      newItems.push(c);
                  }
              }
              this._setItems(newItems);
          }
          _setItems(newItems) {
              let prevItems = this._items;
              this._items = newItems;
              let removed = prevItems.filter(item => {let m = item.marker; delete item.marker; return m});
              let added = newItems.filter(item => (prevItems.indexOf(item) === -1));
              if (removed.length || added.length) {
                  this._refs = {};
                  for (let i = 0, n = this._items.length; i < n; i++) {
                      let ref = this._items[i].ref;
                      if (ref) {
                          this._refs[ref] = this._items[i];
                      }
                  }
              }
              this.onSync(removed, added, newItems);
          }
          sort(f) {
              const items = this._items.slice();
              items.sort(f);
              this._setByArray(items);
          }
          onAdd(item, index) {
          }
          onRemove(item, index) {
          }
          onSync(removed, added, order) {
          }
          onSet(item, index, prevItem) {
          }
          onMove(item, fromIndex, toIndex) {
          }
          createItem(object) {
              throw new Error("ObjectList.createItem must create and return a new object");
          }
          isItem(object) {
              return false;
          }
          forEach(f) {
              this.get().forEach(f);
          }
      }

      class ElementChildList extends ObjectList {
          constructor(element) {
              super();
              this._element = element;
          }
          _connectParent(item) {
              const prevParent = item.parent;
              if (prevParent && prevParent !== this._element) {
                  const prevChildList = item.parent.childList;
                  const index = prevChildList.getIndex(item);
                  if (item.ref) {
                      prevChildList._refs[item.ref] = undefined;
                  }
                  prevChildList._items.splice(index, 1);
                  prevParent.core.removeChildAt(index);
              }
              item._setParent(this._element);
          }
          onAdd(item, index) {
              this._connectParent(item);
              this._element.core.addChildAt(index, item.core);
          }
          onRemove(item, index) {
              item._setParent(null);
              this._element.core.removeChildAt(index);
          }
          onSync(removed, added, order) {
              for (let i = 0, n = removed.length; i < n; i++) {
                  removed[i]._setParent(null);
              }
              for (let i = 0, n = added.length; i < n; i++) {
                  this._connectParent(added[i]);
              }
              let gc = i => i.core;
              this._element.core.syncChildren(removed.map(gc), added.map(gc), order.map(gc));
          }
          onSet(item, index, prevItem) {
              prevItem._setParent(null);
              this._connectParent(item);
              this._element.core.setChildAt(index, item.core);
          }
          onMove(item, fromIndex, toIndex) {
              this._element.core.moveChild(fromIndex, toIndex);
          }
          createItem(object) {
              if (object.type) {
                  return new object.type(this._element.stage);
              } else {
                  return this._element.stage.createElement();
              }
          }
          isItem(object) {
              return object.isElement;
          }
      }

      class Element {
          constructor(stage) {
              this.stage = stage;
              this.__id = Element.id++;
              this.__start();
              this._hasEventListeners = false;
              this.__core = new ElementCore(this);
              this.__ref = null;
              this.__attached = false;
              this.__enabled = false;
              this.__active = false;
              this.__parent = null;
              this.__texture = null;
              this.__displayedTexture = null;
              this.__tags = null;
              this.__treeTags = null;
              this.__tagRoot = false;
              this.__childList = null;
              this._w = 0;
              this._h = 0;
          }
          __start() {
          }
          get id() {
              return this.__id;
          }
          set ref(ref) {
              if (this.__ref !== ref) {
                  const charcode = ref.charCodeAt(0);
                  if (!Utils.isUcChar(charcode)) {
                      this._throwError("Ref must start with an upper case character: " + ref);
                  }
                  if (this.__ref !== null) {
                      this.removeTag(this.__ref);
                      if (this.__parent) {
                          this.__parent.__childList.clearRef(this.__ref);
                      }
                  }
                  this.__ref = ref;
                  if (this.__ref) {
                      this._addTag(this.__ref);
                      if (this.__parent) {
                          this.__parent.__childList.setRef(this.__ref, this);
                      }
                  }
              }
          }
          get ref() {
              return this.__ref;
          }
          get core() {
              return this.__core;
          }
          setAsRoot() {
              this.__core.setAsRoot();
              this._updateAttachedFlag();
              this._updateEnabledFlag();
          }
          get isRoot() {
              return this.__core.isRoot;
          }
          _setParent(parent) {
              if (this.__parent === parent) return;
              if (this.__parent) {
                  this._unsetTagsParent();
              }
              this.__parent = parent;
              if (parent) {
                  this._setTagsParent();
              }
              this._updateAttachedFlag();
              this._updateEnabledFlag();
              if (this.isRoot && parent) {
                  this._throwError("Root should not be added as a child! Results are unspecified!");
              }
          };
          getDepth() {
              let depth = 0;
              let p = this.__parent;
              while(p) {
                  depth++;
                  p = p.__parent;
              }
              return depth;
          };
          getAncestor(l) {
              let p = this;
              while (l > 0 && p.__parent) {
                  p = p.__parent;
                  l--;
              }
              return p;
          };
          getAncestorAtDepth(depth) {
              let levels = this.getDepth() - depth;
              if (levels < 0) {
                  return null;
              }
              return this.getAncestor(levels);
          };
          isAncestorOf(c) {
              let p = c;
              while(p = p.parent) {
                  if (this === p) {
                      return true;
                  }
              }
              return false;
          };
          getSharedAncestor(c) {
              let o1 = this;
              let o2 = c;
              let l1 = o1.getDepth();
              let l2 = o2.getDepth();
              if (l1 > l2) {
                  o1 = o1.getAncestor(l1 - l2);
              } else if (l2 > l1) {
                  o2 = o2.getAncestor(l2 - l1);
              }
              do {
                  if (o1 === o2) {
                      return o1;
                  }
                  o1 = o1.__parent;
                  o2 = o2.__parent;
              } while (o1 && o2);
              return null;
          };
          get attached() {
              return this.__attached;
          }
          get enabled() {
              return this.__enabled;
          }
          get active() {
              return this.__active;
          }
          _isAttached() {
              return (this.__parent ? this.__parent.__attached : (this.stage.root === this));
          };
          _isEnabled() {
              return this.__core.visible && (this.__core.alpha > 0) && (this.__parent ? this.__parent.__enabled : (this.stage.root === this));
          };
          _isActive() {
              return this._isEnabled() && this.withinBoundsMargin;
          };
          _updateAttachedFlag() {
              let newAttached = this._isAttached();
              if (this.__attached !== newAttached) {
                  this.__attached = newAttached;
                  if (newAttached) {
                      this._onSetup();
                  }
                  let children = this._children.get();
                  if (children) {
                      let m = children.length;
                      if (m > 0) {
                          for (let i = 0; i < m; i++) {
                              children[i]._updateAttachedFlag();
                          }
                      }
                  }
                  if (newAttached) {
                      this._onAttach();
                  } else {
                      this._onDetach();
                  }
              }
          };
          _updateEnabledFlag() {
              let newEnabled = this._isEnabled();
              if (this.__enabled !== newEnabled) {
                  if (newEnabled) {
                      this._onEnabled();
                      this._setEnabledFlag();
                  } else {
                      this._onDisabled();
                      this._unsetEnabledFlag();
                  }
                  let children = this._children.get();
                  if (children) {
                      let m = children.length;
                      if (m > 0) {
                          for (let i = 0; i < m; i++) {
                              children[i]._updateEnabledFlag();
                          }
                      }
                  }
              }
          };
          _setEnabledFlag() {
              this.__enabled = true;
              this._updateDimensions();
              this._updateTextureCoords();
              if (this.__texture) {
                  this.__texture.addElement(this);
              }
              if (this.withinBoundsMargin) {
                  this._setActiveFlag();
              }
              if (this.__core.shader) {
                  this.__core.shader.addElement(this.__core);
              }
          }
          _unsetEnabledFlag() {
              if (this.__active) {
                  this._unsetActiveFlag();
              }
              if (this.__texture) {
                  this.__texture.removeElement(this);
              }
              if (this.__core.shader) {
                  this.__core.shader.removeElement(this.__core);
              }
              if (this._texturizer) {
                  this.texturizer.filters.forEach(filter => filter.removeElement(this.__core));
              }
              this.__enabled = false;
          }
          _setActiveFlag() {
              this.__active = true;
              if (this.__texture) {
                  this.__texture.incActiveCount();
              }
              if (this.__texture) {
                  this._enableTexture();
              }
              this._onActive();
          }
          _unsetActiveFlag() {
              if (this.__texture) {
                  this.__texture.decActiveCount();
              }
              this.__active = false;
              if (this.__texture) {
                  this._disableTexture();
              }
              if (this._hasTexturizer()) {
                  this.texturizer.deactivate();
              }
              this._onInactive();
          }
          _onSetup() {
          }
          _onAttach() {
          }
          _onDetach() {
          }
          _onEnabled() {
          }
          _onDisabled() {
          }
          _onActive() {
          }
          _onInactive() {
          }
          _onResize() {
          }
          _getRenderWidth() {
              if (this._w) {
                  return this._w;
              } else if (this.__displayedTexture) {
                  return this.__displayedTexture.getRenderWidth();
              } else if (this.__texture) {
                  return this.__texture.getRenderWidth();
              } else {
                  return 0;
              }
          };
          _getRenderHeight() {
              if (this._h) {
                  return this._h;
              } else if (this.__displayedTexture) {
                  return this.__displayedTexture.getRenderHeight();
              } else if (this.__texture) {
                  return this.__texture.getRenderHeight();
              } else {
                  return 0;
              }
          };
          get renderWidth() {
              if (this.__enabled) {
                  return this.__core.getRenderWidth();
              } else {
                  return this._getRenderWidth();
              }
          }
          get renderHeight() {
              if (this.__enabled) {
                  return this.__core.getRenderHeight();
              } else {
                  return this._getRenderHeight();
              }
          }
          get finalX() {
              return this.__core.x;
          }
          get finalY() {
              return this.__core.y;
          }
          get finalW() {
              return this.__core.w;
          }
          get finalH() {
              return this.__core.h;
          }
          textureIsLoaded() {
              return this.__texture && this.__texture.isLoaded();
          }
          loadTexture() {
              if (this.__texture) {
                  this.__texture.load();
                  if (!this.__texture.isUsed() || !this._isEnabled()) {
                      this._updateDimensions();
                  }
              }
          }
          _enableTextureError() {
              const loadError = this.__texture.loadError;
              if (loadError) {
                  this.emit('txError', loadError, this.__texture._source);
              }
          }
          _enableTexture() {
              if (this.__texture.isLoaded()) {
                  this._setDisplayedTexture(this.__texture);
              } else {
                  this._setDisplayedTexture(null);
                  this._enableTextureError();
              }
          }
          _disableTexture() {
              this._setDisplayedTexture(null);
          }
          get texture() {
              return this.__texture;
          }
          set texture(v) {
              let texture;
              if (Utils.isObjectLiteral(v)) {
                  if (v.type) {
                      texture = new v.type(this.stage);
                  } else {
                      texture = this.texture;
                  }
                  if (texture) {
                      Base.patchObject(texture, v);
                  }
              } else if (!v) {
                  texture = null;
              } else {
                  if (v.isTexture) {
                      texture = v;
                  } else if (v.isTextureSource) {
                      texture = new SourceTexture(this.stage);
                      texture.textureSource = v;
                  } else {
                      console.error("[Lightning] Please specify a texture type.");
                      return;
                  }
              }
              const prevTexture = this.__texture;
              if (texture !== prevTexture) {
                  this.__texture = texture;
                  if (this.__texture) {
                      if (this.__enabled) {
                          this.__texture.addElement(this);
                          if (this.withinBoundsMargin) {
                              if (this.__texture.isLoaded()) {
                                  this._setDisplayedTexture(this.__texture);
                              } else {
                                  this._enableTextureError();
                              }
                          }
                      }
                  } else {
                      this._setDisplayedTexture(null);
                  }
                  if (prevTexture && prevTexture !== this.__displayedTexture) {
                      prevTexture.removeElement(this);
                  }
                  this._updateDimensions();
              }
          }
          get displayedTexture() {
              return this.__displayedTexture;
          }
          _setDisplayedTexture(v) {
              let prevTexture = this.__displayedTexture;
              if (prevTexture && (v !== prevTexture)) {
                  if (this.__texture !== prevTexture) {
                      prevTexture.removeElement(this);
                  }
              }
              const prevSource = this.__core.displayedTextureSource ? this.__core.displayedTextureSource._source : null;
              const sourceChanged = (v ? v._source : null) !== prevSource;
              this.__displayedTexture = v;
              this._updateDimensions();
              if (this.__displayedTexture) {
                  if (sourceChanged) {
                      this._updateTextureCoords();
                      this.__core.setDisplayedTextureSource(this.__displayedTexture._source);
                  }
              } else {
                  this.__core.setDisplayedTextureSource(null);
              }
              if (sourceChanged) {
                  if (this.__displayedTexture) {
                      this.emit('txLoaded', this.__displayedTexture);
                  } else {
                      this.emit('txUnloaded', this.__displayedTexture);
                  }
              }
          }
          onTextureSourceLoaded() {
              if (this.active) {
                  this._setDisplayedTexture(this.__texture);
              }
          };
          onTextureSourceLoadError(e) {
              this.emit('txError', e, this.__texture._source);
          };
          forceRenderUpdate() {
              this.__core.setHasRenderUpdates(3);
          }
          onDisplayedTextureClippingChanged() {
              this._updateDimensions();
              this._updateTextureCoords();
          };
          onPrecisionChanged() {
              this._updateDimensions();
          };
          onDimensionsChanged(w, h) {
              if (this.texture instanceof TextTexture) {
                  this.texture.w = w;
                  this.texture.h = h;
                  this.w = w;
                  this.h = h;
              }
          }
          _updateDimensions() {
              let w = this._getRenderWidth();
              let h = this._getRenderHeight();
              let unknownSize = false;
              if (!w || !h) {
                  if (!this.__displayedTexture && this.__texture) {
                      w = w || this.__texture.mw;
                      h = h || this.__texture.mh;
                      if ((!w || !h) && this.__texture.isAutosizeTexture()) {
                          unknownSize = true;
                      }
                  }
              }
              if (this.__core.setDimensions(w, h, unknownSize)) {
                  this._onResize();
              }
          }
          _updateTextureCoords() {
              if (this.displayedTexture && this.displayedTexture._source) {
                  let displayedTexture = this.displayedTexture;
                  let displayedTextureSource = this.displayedTexture._source;
                  let tx1 = 0, ty1 = 0, tx2 = 1.0, ty2 = 1.0;
                  if (displayedTexture.clipping) {
                      let w = displayedTextureSource.getRenderWidth();
                      let h = displayedTextureSource.getRenderHeight();
                      let iw, ih, rw, rh;
                      iw = 1 / w;
                      ih = 1 / h;
                      if (displayedTexture.pw) {
                          rw = (displayedTexture.pw) * iw;
                      } else {
                          rw = (w - displayedTexture.px) * iw;
                      }
                      if (displayedTexture.ph) {
                          rh = displayedTexture.ph * ih;
                      } else {
                          rh = (h - displayedTexture.py) * ih;
                      }
                      iw *= (displayedTexture.px);
                      ih *= (displayedTexture.py);
                      tx1 = iw;
                      ty1 = ih;
                      tx2 = tx2 * rw + iw;
                      ty2 = ty2 * rh + ih;
                      tx1 = Math.max(0, tx1);
                      ty1 = Math.max(0, ty1);
                      tx2 = Math.min(1, tx2);
                      ty2 = Math.min(1, ty2);
                  }
                  if (displayedTextureSource._flipTextureY) {
                      let tempty = ty2;
                      ty2 = ty1;
                      ty1 = tempty;
                  }
                  this.__core.setTextureCoords(tx1, ty1, tx2, ty2);
              }
          }
          getCornerPoints() {
              return this.__core.getCornerPoints();
          }
          _unsetTagsParent() {
              if (this.__tags) {
                  this.__tags.forEach((tag) => {
                      let p = this;
                      while (p = p.__parent) {
                          let parentTreeTags = p.__treeTags.get(tag);
                          parentTreeTags.delete(this);
                          if (p.__tagRoot) {
                              break;
                          }
                      }
                  });
              }
              let tags = null;
              let n = 0;
              if (this.__treeTags) {
                  if (!this.__tagRoot) {
                      tags = Utils.iteratorToArray(this.__treeTags.keys());
                      n = tags.length;
                      if (n > 0) {
                          for (let i = 0; i < n; i++) {
                              let tagSet = this.__treeTags.get(tags[i]);
                              let p = this;
                              while ((p = p.__parent)) {
                                  let parentTreeTags = p.__treeTags.get(tags[i]);
                                  tagSet.forEach(function (comp) {
                                      parentTreeTags.delete(comp);
                                  });
                                  if (p.__tagRoot) {
                                      break;
                                  }
                              }
                          }
                      }
                  }
              }
          };
          _setTagsParent() {
              if (this.__tags) {
                  this.__tags.forEach((tag) => {
                      let p = this;
                      while (p = p.__parent) {
                          if (!p.__treeTags) {
                              p.__treeTags = new Map();
                          }
                          let s = p.__treeTags.get(tag);
                          if (!s) {
                              s = new Set();
                              p.__treeTags.set(tag, s);
                          }
                          s.add(this);
                          if (p.__tagRoot) {
                              break;
                          }
                      }
                  });
              }
              if (this.__treeTags && this.__treeTags.size) {
                  if (!this.__tagRoot) {
                      this.__treeTags.forEach((tagSet, tag) => {
                          let p = this;
                          while (!p.__tagRoot && (p = p.__parent)) {
                              if (p.__tagRoot) ;
                              if (!p.__treeTags) {
                                  p.__treeTags = new Map();
                              }
                              let s = p.__treeTags.get(tag);
                              if (!s) {
                                  s = new Set();
                                  p.__treeTags.set(tag, s);
                              }
                              tagSet.forEach(function (comp) {
                                  s.add(comp);
                              });
                          }
                      });
                  }
              }
          };
          _getByTag(tag) {
              if (!this.__treeTags) {
                  return [];
              }
              let t = this.__treeTags.get(tag);
              return t ? Utils.setToArray(t) : [];
          };
          getTags() {
              return this.__tags ? this.__tags : [];
          };
          setTags(tags) {
              tags = tags.reduce((acc, tag) => {
                  return acc.concat(tag.split(' '));
              }, []);
              if (this.__ref) {
                  tags.push(this.__ref);
              }
              let i, n = tags.length;
              let removes = [];
              let adds = [];
              for (i = 0; i < n; i++) {
                  if (!this.hasTag(tags[i])) {
                      adds.push(tags[i]);
                  }
              }
              let currentTags = this.tags || [];
              n = currentTags.length;
              for (i = 0; i < n; i++) {
                  if (tags.indexOf(currentTags[i]) == -1) {
                      removes.push(currentTags[i]);
                  }
              }
              for (i = 0; i < removes.length; i++) {
                  this.removeTag(removes[i]);
              }
              for (i = 0; i < adds.length; i++) {
                  this.addTag(adds[i]);
              }
          }
          addTag(tag) {
              if (tag.indexOf(' ') === -1) {
                  if (Utils.isUcChar(tag.charCodeAt(0))) {
                      this._throwError("Tag may not start with an upper case character.");
                  }
                  this._addTag(tag);
              } else {
                  const tags = tag.split(' ');
                  for (let i = 0, m = tags.length; i < m; i++) {
                      const tag = tags[i];
                      if (Utils.isUcChar(tag.charCodeAt(0))) {
                          this._throwError("Tag may not start with an upper case character.");
                      }
                      this._addTag(tag);
                  }
              }
          }
          _addTag(tag) {
              if (!this.__tags) {
                  this.__tags = [];
              }
              if (this.__tags.indexOf(tag) === -1) {
                  this.__tags.push(tag);
                  let p = this.__parent;
                  if (p) {
                      do {
                          if (!p.__treeTags) {
                              p.__treeTags = new Map();
                          }
                          let s = p.__treeTags.get(tag);
                          if (!s) {
                              s = new Set();
                              p.__treeTags.set(tag, s);
                          }
                          s.add(this);
                      } while (!p.__tagRoot && (p = p.__parent));
                  }
              }
          }
          removeTag(tag) {
              let i = this.__tags.indexOf(tag);
              if (i !== -1) {
                  this.__tags.splice(i, 1);
                  let p = this.__parent;
                  if (p) {
                      do {
                          let list = p.__treeTags.get(tag);
                          if (list) {
                              list.delete(this);
                          }
                      } while (!p.__tagRoot && (p = p.__parent));
                  }
              }
          }
          hasTag(tag) {
              return (this.__tags && (this.__tags.indexOf(tag) !== -1));
          }
          _tag(tag) {
              if (tag.indexOf(".") !== -1) {
                  return this.mtag(tag)[0];
              } else {
                  if (this.__treeTags) {
                      let t = this.__treeTags.get(tag);
                      if (t) {
                          const item = t.values().next();
                          return item ? item.value : undefined;
                      }
                  }
              }
          };
          get tag() {
              return this._tag;
          }
          set tag(t) {
              this.tags = t;
          }
          mtag(tag) {
              let idx = tag.indexOf(".");
              if (idx >= 0) {
                  let parts = tag.split('.');
                  let res = this._getByTag(parts[0]);
                  let level = 1;
                  let c = parts.length;
                  while (res.length && level < c) {
                      let resn = [];
                      for (let j = 0, n = res.length; j < n; j++) {
                          resn = resn.concat(res[j]._getByTag(parts[level]));
                      }
                      res = resn;
                      level++;
                  }
                  return res;
              } else {
                  return this._getByTag(tag);
              }
          };
          stag(tag, settings) {
              let t = this.mtag(tag);
              let n = t.length;
              for (let i = 0; i < n; i++) {
                  Base.patchObject(t[i], settings);
              }
          }
          get tagRoot() {
              return this.__tagRoot;
          }
          set tagRoot(v) {
              if (this.__tagRoot !== v) {
                  if (!v) {
                      this._setTagsParent();
                  } else {
                      this._unsetTagsParent();
                  }
                  this.__tagRoot = v;
              }
          }
          sel(path) {
              const results = this.select(path);
              if (results.length) {
                  return results[0];
              } else {
                  return undefined;
              }
          }
          select(path) {
              if (path.indexOf(",") !== -1) {
                  let selectors = path.split(',');
                  let res = [];
                  for (let i = 0; i < selectors.length; i++) {
                      res = res.concat(this._select(selectors[i]));
                  }
                  return res;
              } else {
                  return this._select(path);
              }
          }
          _select(path) {
              if (path === "") return [this];
              let pointIdx = path.indexOf(".");
              let arrowIdx = path.indexOf(">");
              if (pointIdx === -1 && arrowIdx === -1) {
                  return this.mtag(path);
              }
              let isRef;
              if (arrowIdx === 0) {
                  isRef = true;
                  path = path.substr(1);
              } else if (pointIdx === 0) {
                  isRef = false;
                  path = path.substr(1);
              } else {
                  isRef = false;
              }
              return this._selectChilds(path, isRef);
          }
          _selectChilds(path, isRef) {
              const pointIdx = path.indexOf(".");
              const arrowIdx = path.indexOf(">");
              if (pointIdx === -1 && arrowIdx === -1) {
                  if (isRef) {
                      const ref = this.getByRef(path);
                      return ref ? [ref] : [];
                  } else {
                      return this.mtag(path);
                  }
              }
              if ((arrowIdx === -1) || (pointIdx !== -1 && pointIdx < arrowIdx)) {
                  let next;
                  const str = path.substr(0, pointIdx);
                  if (isRef) {
                      const ref = this.getByRef(str);
                      next = ref ? [ref] : [];
                  } else {
                      next = this.mtag(str);
                  }
                  let total = [];
                  const subPath = path.substr(pointIdx + 1);
                  for (let i = 0, n = next.length; i < n; i++) {
                      total = total.concat(next[i]._selectChilds(subPath, false));
                  }
                  return total;
              } else {
                  let next;
                  const str = path.substr(0, arrowIdx);
                  if (isRef) {
                      const ref = this.getByRef(str);
                      next = ref ? [ref] : [];
                  } else {
                      next = this.mtag(str);
                  }
                  let total = [];
                  const subPath = path.substr(arrowIdx + 1);
                  for (let i = 0, n = next.length; i < n; i++) {
                      total = total.concat(next[i]._selectChilds(subPath, true));
                  }
                  return total;
              }
          }
          getByRef(ref) {
              return this.childList.getByRef(ref);
          }
          getLocationString() {
              let i;
              i = this.__parent ? this.__parent._children.getIndex(this) : "R";
              let localTags = this.getTags();
              let str = this.__parent ? this.__parent.getLocationString(): "";
              if (this.ref) {
                  str += ":[" + i + "]" + this.ref;
              } else if (localTags.length) {
                  str += ":[" + i + "]" + localTags.join(",");
              } else {
                  str += ":[" + i + "]#" + this.id;
              }
              return str;
          }
          toString() {
              let obj = this.getSettings();
              return Element.getPrettyString(obj, "");
          };
          static getPrettyString(obj, indent) {
              let children = obj.children;
              delete obj.children;
              let colorKeys = ["color", "colorUl", "colorUr", "colorBl", "colorBr"];
              let str = JSON.stringify(obj, function (k, v) {
                  if (colorKeys.indexOf(k) !== -1) {
                      return "COLOR[" + v.toString(16) + "]";
                  }
                  return v;
              });
              str = str.replace(/"COLOR\[([a-f0-9]{1,8})\]"/g, "0x$1");
              if (children) {
                  let childStr = "";
                  if (Utils.isObjectLiteral(children)) {
                      let refs = Object.keys(children);
                      childStr = "";
                      for (let i = 0, n = refs.length; i < n; i++) {
                          childStr += `\n${indent}  "${refs[i]}":`;
                          delete children[refs[i]].ref;
                          childStr += Element.getPrettyString(children[refs[i]], indent + "  ") + (i < n - 1 ? "," : "");
                      }
                      let isEmpty = (str === "{}");
                      str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + childStr + "\n" + indent + "}";
                  } else {
                      let n = children.length;
                      childStr = "[";
                      for (let i = 0; i < n; i++) {
                          childStr += Element.getPrettyString(children[i], indent + "  ") + (i < n - 1 ? "," : "") + "\n";
                      }
                      childStr += indent + "]}";
                      let isEmpty = (str === "{}");
                      str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + "\"children\":\n" + indent + childStr + "}";
                  }
              }
              return str;
          }
          getSettings() {
              let settings = this.getNonDefaults();
              let children = this._children.get();
              if (children) {
                  let n = children.length;
                  if (n) {
                      const childArray = [];
                      let missing = false;
                      for (let i = 0; i < n; i++) {
                          childArray.push(children[i].getSettings());
                          missing = missing || !children[i].ref;
                      }
                      if (!missing) {
                          settings.children = {};
                          childArray.forEach(child => {
                              settings.children[child.ref] = child;
                          });
                      } else {
                          settings.children = childArray;
                      }
                  }
              }
              settings.id = this.id;
              return settings;
          }
          getNonDefaults() {
              let settings = {};
              if (this.constructor !== Element) {
                  settings.type = this.constructor.name;
              }
              if (this.__ref) {
                  settings.ref = this.__ref;
              }
              if (this.__tags && this.__tags.length) {
                  settings.tags = this.__tags;
              }
              if (this.x !== 0) settings.x = this.x;
              if (this.y !== 0) settings.y = this.y;
              if (this.w !== 0) settings.w = this.w;
              if (this.h !== 0) settings.h = this.h;
              if (this.scaleX === this.scaleY) {
                  if (this.scaleX !== 1) settings.scale = this.scaleX;
              } else {
                  if (this.scaleX !== 1) settings.scaleX = this.scaleX;
                  if (this.scaleY !== 1) settings.scaleY = this.scaleY;
              }
              if (this.pivotX === this.pivotY) {
                  if (this.pivotX !== 0.5) settings.pivot = this.pivotX;
              } else {
                  if (this.pivotX !== 0.5) settings.pivotX = this.pivotX;
                  if (this.pivotY !== 0.5) settings.pivotY = this.pivotY;
              }
              if (this.mountX === this.mountY) {
                  if (this.mountX !== 0) settings.mount = this.mountX;
              } else {
                  if (this.mountX !== 0) settings.mountX = this.mountX;
                  if (this.mountY !== 0) settings.mountY = this.mountY;
              }
              if (this.alpha !== 1) settings.alpha = this.alpha;
              if (!this.visible) settings.visible = false;
              if (this.rotation !== 0) settings.rotation = this.rotation;
              if (this.colorUl === this.colorUr && this.colorBl === this.colorBr && this.colorUl === this.colorBl) {
                  if (this.colorUl !== 0xFFFFFFFF) settings.color = this.colorUl.toString(16);
              } else {
                  if (this.colorUl !== 0xFFFFFFFF) settings.colorUl = this.colorUl.toString(16);
                  if (this.colorUr !== 0xFFFFFFFF) settings.colorUr = this.colorUr.toString(16);
                  if (this.colorBl !== 0xFFFFFFFF) settings.colorBl = this.colorBl.toString(16);
                  if (this.colorBr !== 0xFFFFFFFF) settings.colorBr = this.colorBr.toString(16);
              }
              if (this.zIndex) settings.zIndex = this.zIndex;
              if (this.forceZIndexContext) settings.forceZIndexContext = true;
              if (this.clipping) settings.clipping = this.clipping;
              if (!this.clipbox) settings.clipbox = this.clipbox;
              if (this.__texture) {
                  let tnd = this.__texture.getNonDefaults();
                  if (Object.keys(tnd).length) {
                      settings.texture = tnd;
                  }
              }
              if (this.shader && Utils.isFunction(this.shader.getNonDefaults)) {
                  let tnd = this.shader.getNonDefaults();
                  if (Object.keys(tnd).length) {
                      settings.shader = tnd;
                  }
              }
              if (this._hasTexturizer()) {
                  if (this.texturizer.enabled) {
                      settings.renderToTexture = this.texturizer.enabled;
                  }
                  if (this.texturizer.lazy) {
                      settings.renderToTextureLazy = this.texturizer.lazy;
                  }
                  if (this.texturizer.colorize) {
                      settings.colorizeResultTexture = this.texturizer.colorize;
                  }
                  if (this.texturizer.renderOffscreen) {
                      settings.renderOffscreen = this.texturizer.renderOffscreen;
                  }
              }
              return settings;
          };
          static getGetter(propertyPath) {
              let getter = Element.PROP_GETTERS.get(propertyPath);
              if (!getter) {
                  getter = new Function('obj', 'return obj.' + propertyPath);
                  Element.PROP_GETTERS.set(propertyPath, getter);
              }
              return getter;
          }
          static getSetter(propertyPath) {
              let setter = Element.PROP_SETTERS.get(propertyPath);
              if (!setter) {
                  setter = new Function('obj', 'v', 'obj.' + propertyPath + ' = v');
                  Element.PROP_SETTERS.set(propertyPath, setter);
              }
              return setter;
          }
          get withinBoundsMargin() {
              return this.__core._withinBoundsMargin;
          }
          _enableWithinBoundsMargin() {
              if (this.__enabled) {
                  this._setActiveFlag();
              }
          }
          _disableWithinBoundsMargin() {
              if (this.__active) {
                  this._unsetActiveFlag();
              }
          }
          set boundsMargin(v) {
              if (!Array.isArray(v) && v !== null) {
                  throw new Error("boundsMargin should be an array of left-top-right-bottom values or null (inherit margin)");
              }
              this.__core.boundsMargin = v;
          }
          get boundsMargin() {
              return this.__core.boundsMargin;
          }
          get x() {
              return this.__core.offsetX;
          }
          set x(v) {
              this.__core.offsetX = v;
          }
          get y() {
              return this.__core.offsetY;
          }
          set y(v) {
              this.__core.offsetY = v;
          }
          get w() {
              return this._w;
          }
          set w(v) {
              if (Utils.isFunction(v)) {
                  this._w = 0;
                  this.__core.funcW = v;
              } else {
                  v = Math.max(v, 0);
                  if (this._w !== v) {
                      this.__core.disableFuncW();
                      this._w = v;
                      this._updateDimensions();
                  }
              }
          }
          get h() {
              return this._h;
          }
          set h(v) {
              if (Utils.isFunction(v)) {
                  this._h = 0;
                  this.__core.funcH = v;
              } else {
                  v = Math.max(v, 0);
                  if (this._h !== v) {
                      this.__core.disableFuncH();
                      this._h = v;
                      this._updateDimensions();
                  }
              }
          }
          get scaleX() {
              return this.__core.scaleX;
          }
          set scaleX(v) {
              this.__core.scaleX = v;
          }
          get scaleY() {
              return this.__core.scaleY;
          }
          set scaleY(v) {
              this.__core.scaleY = v;
          }
          get scale() {
              return this.__core.scale;
          }
          set scale(v) {
              this.__core.scale = v;
          }
          get pivotX() {
              return this.__core.pivotX;
          }
          set pivotX(v) {
              this.__core.pivotX = v;
          }
          get pivotY() {
              return this.__core.pivotY;
          }
          set pivotY(v) {
              this.__core.pivotY = v;
          }
          get pivot() {
              return this.__core.pivot;
          }
          set pivot(v) {
              this.__core.pivot = v;
          }
          get mountX() {
              return this.__core.mountX;
          }
          set mountX(v) {
              this.__core.mountX = v;
          }
          get mountY() {
              return this.__core.mountY;
          }
          set mountY(v) {
              this.__core.mountY = v;
          }
          get mount() {
              return this.__core.mount;
          }
          set mount(v) {
              this.__core.mount = v;
          }
          get rotation() {
              return this.__core.rotation;
          }
          set rotation(v) {
              this.__core.rotation = v;
          }
          get alpha() {
              return this.__core.alpha;
          }
          set alpha(v) {
              this.__core.alpha = v;
          }
          get visible() {
              return this.__core.visible;
          }
          set visible(v) {
              this.__core.visible = v;
          }
          get colorUl() {
              return this.__core.colorUl;
          }
          set colorUl(v) {
              this.__core.colorUl = v;
          }
          get colorUr() {
              return this.__core.colorUr;
          }
          set colorUr(v) {
              this.__core.colorUr = v;
          }
          get colorBl() {
              return this.__core.colorBl;
          }
          set colorBl(v) {
              this.__core.colorBl = v;
          }
          get colorBr() {
              return this.__core.colorBr;
          }
          set colorBr(v) {
              this.__core.colorBr = v;
          }
          get color() {
              return this.__core.colorUl;
          }
          set color(v) {
              if (this.colorUl !== v || this.colorUr !== v || this.colorBl !== v || this.colorBr !== v) {
                  this.colorUl = v;
                  this.colorUr = v;
                  this.colorBl = v;
                  this.colorBr = v;
              }
          }
          get colorTop() {
              return this.colorUl;
          }
          set colorTop(v) {
              if (this.colorUl !== v || this.colorUr !== v) {
                  this.colorUl = v;
                  this.colorUr = v;
              }
          }
          get colorBottom() {
              return this.colorBl;
          }
          set colorBottom(v) {
              if (this.colorBl !== v || this.colorBr !== v) {
                  this.colorBl = v;
                  this.colorBr = v;
              }
          }
          get colorLeft() {
              return this.colorUl;
          }
          set colorLeft(v) {
              if (this.colorUl !== v || this.colorBl !== v) {
                  this.colorUl = v;
                  this.colorBl = v;
              }
          }
          get colorRight() {
              return this.colorUr;
          }
          set colorRight(v) {
              if (this.colorUr !== v || this.colorBr !== v) {
                  this.colorUr = v;
                  this.colorBr = v;
              }
          }
          get zIndex() {return this.__core.zIndex}
          set zIndex(v) {
              this.__core.zIndex = v;
          }
          get forceZIndexContext() {return this.__core.forceZIndexContext}
          set forceZIndexContext(v) {
              this.__core.forceZIndexContext = v;
          }
          get clipping() {return this.__core.clipping}
          set clipping(v) {
              this.__core.clipping = v;
          }
          get clipbox() {return this.__core.clipbox}
          set clipbox(v) {
              this.__core.clipbox = v;
          }
          get tags() {
              return this.getTags();
          }
          set tags(v) {
              if (!Array.isArray(v)) v = [v];
              this.setTags(v);
          }
          set t(v) {
              this.tags = v;
          }
          get _children() {
              if (!this.__childList) {
                  this.__childList = new ElementChildList(this, false);
              }
              return this.__childList;
          }
          get childList() {
              if (!this._allowChildrenAccess()) {
                  this._throwError("Direct access to children is not allowed in " + this.getLocationString());
              }
              return this._children;
          }
          hasChildren() {
              return this._allowChildrenAccess() && this.__childList && (this.__childList.length > 0);
          }
          _allowChildrenAccess() {
              return true;
          }
          get children() {
              return this.childList.get();
          }
          set children(children) {
              this.childList.patch(children);
          }
          add(o) {
              return this.childList.a(o);
          }
          get p() {
              return this.__parent;
          }
          get parent() {
              return this.__parent;
          }
          get src() {
              if (this.texture && this.texture instanceof ImageTexture) {
                  return this.texture._src;
              } else {
                  return undefined;
              }
          }
          set src(v) {
              const texture = new ImageTexture(this.stage);
              texture.src = v;
              this.texture = texture;
          }
          set mw(v) {
              if (this.texture) {
                  this.texture.mw = v;
                  this._updateDimensions();
              } else {
                  this._throwError('Please set mw after setting a texture.');
              }
          }
          set mh(v) {
              if (this.texture) {
                  this.texture.mh = v;
                  this._updateDimensions();
              } else {
                  this._throwError('Please set mh after setting a texture.');
              }
          }
          get rect() {
              return (this.texture === this.stage.rectangleTexture);
          }
          set rect(v) {
              if (v) {
                  this.texture = this.stage.rectangleTexture;
              } else {
                  this.texture = null;
              }
          }
          enableTextTexture() {
              if (!this.texture || !(this.texture instanceof TextTexture)) {
                  this.texture = new TextTexture(this.stage);
                  if (!this.texture.w && !this.texture.h) {
                      this.texture.w = this.w;
                      this.texture.h = this.h;
                  }
              }
              return this.texture;
          }
          get text() {
              if (this.texture && (this.texture instanceof TextTexture)) {
                  return this.texture;
              } else {
                  return null;
              }
          }
          set text(v) {
              if (!this.texture || !(this.texture instanceof TextTexture)) {
                  this.enableTextTexture();
              }
              if (Utils.isString(v)) {
                  this.texture.text = v;
              } else {
                  this.texture.patch(v);
              }
          }
          set onUpdate(f) {
              this.__core.onUpdate = f;
          }
          set onAfterCalcs(f) {
              this.__core.onAfterCalcs = f;
          }
          set onAfterUpdate(f) {
              this.__core.onAfterUpdate = f;
          }
          forceUpdate() {
              this.__core._setHasUpdates();
          }
          get shader() {
              return this.__core.shader;
          }
          set shader(v) {
              if (Utils.isObjectLiteral(v) && !v.type) {
                  if (this.shader) {
                      this.shader.patch(v);
                  }
              } else {
                  const shader = Shader.create(this.stage, v);
                  if (this.__enabled && this.__core.shader) {
                      this.__core.shader.removeElement(this.__core);
                  }
                  this.__core.shader = shader;
                  if (this.__enabled && this.__core.shader) {
                      this.__core.shader.addElement(this.__core);
                  }
              }
          }
          _hasTexturizer() {
              return !!this.__core._texturizer;
          }
          get renderToTexture() {
              return this.rtt
          }
          set renderToTexture(v) {
              this.rtt = v;
          }
          get rtt() {
              return this._hasTexturizer() && this.texturizer.enabled;
          }
          set rtt(v) {
              this.texturizer.enabled = v;
          }
          get rttLazy() {
              return this._hasTexturizer() && this.texturizer.lazy;
          }
          set rttLazy(v) {
              this.texturizer.lazy = v;
          }
          get renderOffscreen() {
              return this._hasTexturizer() && this.texturizer.renderOffscreen;
          }
          set renderOffscreen(v) {
              this.texturizer.renderOffscreen = v;
          }
          get colorizeResultTexture() {
              return this._hasTexturizer() && this.texturizer.colorize;
          }
          set colorizeResultTexture(v) {
              this.texturizer.colorize = v;
          }
          getTexture() {
              return this.texturizer._getTextureSource();
          }
          get texturizer() {
              return this.__core.texturizer;
          }
          patch(settings) {
              let paths = Object.keys(settings);
              for (let i = 0, n = paths.length; i < n; i++) {
                  let path = paths[i];
                  const v = settings[path];
                  const firstCharCode = path.charCodeAt(0);
                  if (Utils.isUcChar(firstCharCode)) {
                      const child = this.getByRef(path);
                      if (!child) {
                          if (v !== undefined) {
                              let c;
                              if (Utils.isObjectLiteral(v)) {
                                  c = this.childList.createItem(v);
                                  c.patch(v);
                              } else if (Utils.isObject(v)) {
                                  c = v;
                              }
                              if (c.isElement) {
                                  c.ref = path;
                              }
                              this.childList.a(c);
                          }
                      } else {
                          if (v === undefined) {
                              if (child.parent) {
                                  child.parent.childList.remove(child);
                              }
                          } else if (Utils.isObjectLiteral(v)) {
                              child.patch(v);
                          } else if (v.isElement) {
                              v.ref = path;
                              this.childList.replace(v, child);
                          } else {
                              this._throwError("Unexpected value for path: " + path);
                          }
                      }
                  } else {
                      Base.patchObjectProperty(this, path, v);
                  }
              }
          }
          _throwError(message) {
              throw new Error(this.constructor.name + " (" + this.getLocationString() + "): " + message);
          }
          animation(settings) {
              return this.stage.animations.createAnimation(this, settings);
          }
          transition(property, settings = null) {
              if (settings === null) {
                  return this._getTransition(property);
              } else {
                  this._setTransition(property, settings);
                  return null;
              }
          }
          set transitions(object) {
              let keys = Object.keys(object);
              keys.forEach(property => {
                  this.transition(property, object[property]);
              });
          }
          set smooth(object) {
              let keys = Object.keys(object);
              keys.forEach(property => {
                  let value = object[property];
                  if (Array.isArray(value)) {
                      this.setSmooth(property, value[0], value[1]);
                  } else {
                      this.setSmooth(property, value);
                  }
              });
          }
          fastForward(property) {
              if (this._transitions) {
                  let t = this._transitions[property];
                  if (t && t.isTransition) {
                      t.finish();
                  }
              }
          }
          _getTransition(property) {
              if (!this._transitions) {
                  this._transitions = {};
              }
              let t = this._transitions[property];
              if (!t) {
                  t = new Transition(this.stage.transitions, this.stage.transitions.defaultTransitionSettings, this, property);
              } else if (t.isTransitionSettings) {
                  t = new Transition(
                      this.stage.transitions,
                      t,
                      this,
                      property
                  );
              }
              this._transitions[property] = t;
              return t;
          }
          _setTransition(property, settings) {
              if (!settings) {
                  this._removeTransition(property);
              } else {
                  if (Utils.isObjectLiteral(settings)) {
                      settings = this.stage.transitions.createSettings(settings);
                  }
                  if (!this._transitions) {
                      this._transitions = {};
                  }
                  let current = this._transitions[property];
                  if (current && current.isTransition) {
                      current.settings = settings;
                      return current;
                  } else {
                      this._transitions[property] = settings;
                  }
              }
          }
          _removeTransition(property) {
              if (this._transitions) {
                  delete this._transitions[property];
              }
          }
          getSmooth(property, v) {
              let t = this._getTransition(property);
              if (t && t.isAttached()) {
                  return t.targetValue;
              } else {
                  return v;
              }
          }
          setSmooth(property, v, settings) {
              if (settings) {
                  this._setTransition(property, settings);
              }
              let t = this._getTransition(property);
              t.start(v);
              return t;
          }
          get flex() {
              return this.__core.flex;
          }
          set flex(v) {
              this.__core.flex = v;
          }
          get flexItem() {
              return this.__core.flexItem;
          }
          set flexItem(v) {
              this.__core.flexItem = v;
          }
          static isColorProperty(property) {
              return property.toLowerCase().indexOf("color") >= 0;
          }
          static getMerger(property) {
              if (Element.isColorProperty(property)) {
                  return StageUtils.mergeColors;
              } else {
                  return StageUtils.mergeNumbers;
              }
          }
          toJSON() {
              const ref = [`${this.constructor.name}`];
              const tree = {[ref]: {}};
              if (this.hasChildren()) {
                  Element.collectChildren(tree[ref], this.__childList);
              } else {
                  tree[ref] = {...Element.getProperties(this)};
              }
              return tree;
          }
          static collectChildren(tree, children) {
              const childList = children;
              for (let i = 0, j = childList.length; i < j; i++) {
                  const element = childList.getAt(i);
                  const ref = `${element.__ref || `Element-${element.id}`}`;
                  const properties = this.getProperties(element);
                  tree[ref] = {...properties};
                  if (element.hasChildren()) {
                      tree[ref].children = {};
                      this.collectChildren(
                          tree[ref].children, element.__childList
                      );
                  }
              }
          }
          static getProperties(element) {
              const props = {};
              const list = [
                  "alpha", "active", "attached", "boundsMargin", "color", "clipping", "enabled", "h", "id", "isComponent",
                  "mount", "mountY", "mountX", "pivot", "pivotX", "pivotY", "ref", "renderOfScreen", "renderToTexture", "scale",
                  "scaleX", "scaleY", "state", "tag", "visible", "w", "x", "y", "zIndex",
                  "!!flex", "!!flexItem", "hasFocus()", "hasFinalFocus()"
              ];
              let n = list.length;
              while (n--) {
                  let key = list[n];
                  const getBoolean = /^!{2}/;
                  const isFunction = /\(\)$/;
                  if (getBoolean.test(key)) {
                      key = key.substring(2, key.length);
                      props[key] = !!element[key];
                  } else if (isFunction.test(key)) {
                      key = key.substring(0, key.length - 2);
                      if (typeof element[key] === "function") {
                          props[key] = element[key]();
                      }
                  } else {
                      props[key] = element[key];
                  }
              }
              return {...props, ...element.getNonDefaults()};
          }
      }
      EventEmitter.addAsMixin(Element);
      Element.prototype.isElement = 1;
      Element.id = 1;
      Element.PROP_GETTERS = new Map();
      Element.PROP_SETTERS = new Map();

      class StateMachine {
          constructor() {
              StateMachine.setupStateMachine(this);
          }
          static setupStateMachine(target) {
              const targetConstructor = target.constructor;
              const router = StateMachine.create(targetConstructor);
              Object.setPrototypeOf(target, router.prototype);
              target.constructor = targetConstructor;
              target._initStateMachine();
          }
          static create(type) {
              if (!type.hasOwnProperty('_sm')) {
                  const stateMachineType = new StateMachineType(type);
                  type._sm = stateMachineType;
              }
              return type._sm.router;
          }
          fire(event, ...args) {
              if (this._hasMethod(event)) {
                  return this[event](...args);
              }
          }
          _getState() {
              return this._state.__path;
          }
          _inState(statePath, currentStatePath = this._state.__path) {
              const state = this._sm.getStateByPath(statePath);
              const currentState = this._sm.getStateByPath(currentStatePath);
              const level = state.__level;
              const stateAtLevel = StateMachine._getStateAtLevel(currentState, level);
              return (stateAtLevel === state);
          }
          _hasMember(name) {
              return !!this.constructor.prototype[name];
          }
          _hasMethod(name) {
              const member = this.constructor.prototype[name];
              return !!member && (typeof member === "function")
          }
          _setState(statePath, args) {
              const setStateId = ++this._setStateCounter;
              this._setStateId = setStateId;
              if (this._state.__path !== statePath) {
                  let newState = this._sm._stateMap[statePath];
                  if (!newState) {
                      newState = this._sm.getStateByPath(statePath);
                  }
                  const prevState = this._state;
                  const hasDifferentEnterMethod = (newState.prototype.$enter !== this._state.prototype.$enter);
                  const hasDifferentExitMethod = (newState.prototype.$exit !== this._state.prototype.$exit);
                  if (hasDifferentEnterMethod || hasDifferentExitMethod) {
                      const sharedState = StateMachine._getSharedState(this._state, newState);
                      const context = {
                          newState: newState.__path,
                          prevState: prevState.__path,
                          sharedState: sharedState.__path
                      };
                      const sharedLevel = sharedState.__level;
                      if (hasDifferentExitMethod) {
                          const exitStates = StateMachine._getStatesUntilLevel(this._state, sharedLevel);
                          for (let i = 0, n = exitStates.length; i < n; i++) {
                              this.__setState(exitStates[i]);
                              this._callExit(this._state, args, context);
                              const stateChangeOverridden = (this._setStateId !== setStateId);
                              if (stateChangeOverridden) {
                                  return;
                              }
                          }
                      }
                      if (hasDifferentEnterMethod) {
                          const enterStates = StateMachine._getStatesUntilLevel(newState, sharedLevel).reverse();
                          for (let i = 0, n = enterStates.length; i < n; i++) {
                              this.__setState(enterStates[i]);
                              this._callEnter(this._state, args, context);
                              const stateChangeOverridden = (this._setStateId !== setStateId);
                              if (stateChangeOverridden) {
                                  return;
                              }
                          }
                      }
                  }
                  this.__setState(newState);
                  if (this._changedState) {
                      const context = {
                          newState: newState.__path,
                          prevState: prevState.__path
                      };
                      if (args) {
                          this._changedState(context, ...args);
                      } else {
                          this._changedState(context);
                      }
                  }
                  if (this._onStateChange) {
                      const context = {
                          newState: newState.__path,
                          prevState: prevState.__path
                      };
                      this._onStateChange(context);
                  }
              }
          }
          _callEnter(state, args = [], context) {
              const hasParent = !!state.__parent;
              if (state.prototype.$enter) {
                  if (!hasParent || (state.__parent.prototype.$enter !== state.prototype.$enter)) {
                      state.prototype.$enter.apply(this, [context, ...args]);
                  }
              }
          }
          _callExit(state, args = [], context) {
              const hasParent = !!state.__parent;
              if (state.prototype.$exit) {
                  if (!hasParent || (state.__parent.prototype.$exit !== state.prototype.$exit)) {
                      state.prototype.$exit.apply(this, [context, ...args]);
                  }
              }
          }
          __setState(state) {
              this._state = state;
              this._stateIndex = state.__index;
              this.constructor = state;
          }
          _initStateMachine() {
              this._state = null;
              this._stateIndex = 0;
              this._setStateCounter = 0;
              this._sm = this._routedType._sm;
              this.__setState(this._sm.getStateByPath(""));
              const context = {newState: "", prevState: undefined, sharedState: undefined};
              this._callEnter(this._state, [], context);
              this._onStateChange = undefined;
          }
          _getMostSpecificHandledMember(memberNames) {
              let cur = this._state;
              do {
                  for (let i = 0, n = memberNames.length; i < n; i++) {
                      const memberName = memberNames[i];
                      if (!cur.__parent) {
                          if (cur.prototype[memberName]) {
                              return memberName;
                          }
                      } else {
                          const alias = StateMachineType.getStateMemberAlias(cur.__path, memberName);
                          if (this[alias]) {
                              return memberName;
                          }
                      }
                  }
                  cur = cur.__parent;
              } while (cur);
          }
          static _getStatesUntilLevel(state, level) {
              const states = [];
              while (state.__level > level) {
                  states.push(state);
                  state = state.__parent;
              }
              return states;
          }
          static _getSharedState(state1, state2) {
              const state1Array = StateMachine._getAncestorStates(state1);
              const state2Array = StateMachine._getAncestorStates(state2);
              const n = Math.min(state1Array.length, state2Array.length);
              for (let i = 0; i < n; i++) {
                  if (state1Array[i] !== state2Array[i]) {
                      return state1Array[i - 1];
                  }
              }
              return state1Array[n - 1];
          }
          static _getAncestorStates(state) {
              const result = [];
              do {
                  result.push(state);
              } while(state = state.__parent);
              return result.reverse();
          }
          static _getStateAtLevel(state, level) {
              if (level > state.__level) {
                  return undefined;
              }
              while(level < state.__level) {
                  state = state.__parent;
              }
              return state;
          }
      }
      class StateMachineType {
          constructor(type) {
              this._type = type;
              this._router = null;
              this.init();
          }
          get router() {
              return this._router;
          }
          init() {
              this._router = this._createRouter();
              this._stateMap = this._getStateMap();
              this._addStateMemberDelegatorsToRouter();
          }
          _createRouter() {
              const type = this._type;
              const router = class StateMachineRouter extends type {
                  constructor() {
                      super(...arguments);
                      if (!this.constructor.hasOwnProperty('_isRouter')) {
                          throw new Error(`You need to extend ${type.name}.original instead of ${type.name}.`);
                      }
                  }
              };
              router._isRouter = true;
              router.prototype._routedType = type;
              router.original = type;
              this._mixinStateMachineMethods(router);
              return router;
          }
          _mixinStateMachineMethods(router) {
              const names = Object.getOwnPropertyNames(StateMachine.prototype);
              for (let i = 0, n = names.length; i < n; i++) {
                  const name = names[i];
                  if (name !== "constructor") {
                      const descriptor = Object.getOwnPropertyDescriptor(StateMachine.prototype, name);
                      Object.defineProperty(router.prototype, name, descriptor);
                  }
              }
          }
          _addStateMemberDelegatorsToRouter() {
              const members = this._getAllMemberNames();
              members.forEach(member => {
                  this._addMemberRouter(member);
              });
          }
          _addMemberRouter(member) {
              const statePaths = Object.keys(this._stateMap);
              const descriptors = [];
              const aliases = [];
              statePaths.forEach((statePath, index) => {
                  const state = this._stateMap[statePath];
                  const descriptor = this._getDescriptor(state, member);
                  if (descriptor) {
                      descriptors[index] = descriptor;
                      const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                      aliases[index] = alias;
                      if (!this._router.prototype.hasOwnProperty(alias)) {
                          Object.defineProperty(this._router.prototype, alias, descriptor);
                      }
                  } else {
                      descriptors[index] = null;
                      aliases[index] = null;
                  }
              });
              let type = undefined;
              descriptors.forEach(descriptor => {
                  if (descriptor) {
                      const descType = this._getDescriptorType(descriptor);
                      if (type && (type !== descType)) {
                          console.warn(`[Lightning] Member ${member} in ${this._type.name} has inconsistent types.`);
                          return;
                      }
                      type = descType;
                  }
              });
              switch(type) {
                  case "method":
                      this._addMethodRouter(member, descriptors, aliases);
                      break;
                  case "getter":
                      this._addGetterSetterRouters(member);
                      break;
                  case "property":
                      console.warn("[Lightning] Fixed properties are not supported; please use a getter instead!");
                      break;
              }
          }
          _getDescriptor(state, member, isValid = () => true) {
              let type = state;
              let curState = state;
              do {
                  const descriptor = Object.getOwnPropertyDescriptor(type.prototype, member);
                  if (descriptor) {
                      if (isValid(descriptor)) {
                          descriptor._source = curState;
                          return descriptor;
                      }
                  }
                  type = Object.getPrototypeOf(type);
                  if (type && type.hasOwnProperty('__state')) {
                      curState = type;
                  }
              } while(type && type.prototype);
              return undefined;
          }
          _getDescriptorType(descriptor) {
              if (descriptor.get || descriptor.set) {
                  return 'getter';
              } else {
                  if (typeof descriptor.value === "function") {
                      return 'method';
                  } else {
                      return 'property';
                  }
              }
          }
          static _supportsSpread() {
              if (this.__supportsSpread === undefined) {
                  this.__supportsSpread = false;
                  try {
                      const func = new Function("return [].concat(...arguments);");
                      func();
                      this.__supportsSpread = true;
                  } catch(e) {}
              }
              return this.__supportsSpread;
          }
          _addMethodRouter(member, descriptors, aliases) {
              const code = [
                  "//@ sourceURL=StateMachineRouter.js",
                  "var i = this._stateIndex;"
              ];
              let cur = aliases[0];
              const supportsSpread = StateMachineType._supportsSpread();
              for (let i = 1, n = aliases.length; i < n; i++) {
                  const alias = aliases[i];
                  if (alias !== cur) {
                      if (cur) {
                          if (supportsSpread) {
                              code.push(`if (i < ${i}) return this["${cur}"](...arguments); else`);
                          } else {
                              code.push(`if (i < ${i}) return this["${cur}"].apply(this, arguments); else`);
                          }
                      } else {
                          code.push(`if (i < ${i}) return ; else`);
                      }
                  }
                  cur = alias;
              }
              if (cur) {
                  if (supportsSpread) {
                      code.push(`return this["${cur}"](...arguments);`);
                  } else {
                      code.push(`return this["${cur}"].apply(this, arguments);`);
                  }
              } else {
                  code.push(`;`);
              }
              const functionBody = code.join("\n");
              const router = new Function([], functionBody);
              const descriptor = {value: router};
              Object.defineProperty(this._router.prototype, member, descriptor);
          }
          _addGetterSetterRouters(member) {
              const getter = this._getGetterRouter(member);
              const setter = this._getSetterRouter(member);
              const descriptor = {
                  get: getter,
                  set: setter
              };
              Object.defineProperty(this._router.prototype, member, descriptor);
          }
          _getGetterRouter(member) {
              const statePaths = Object.keys(this._stateMap);
              const descriptors = [];
              const aliases = [];
              statePaths.forEach((statePath, index) => {
                  const state = this._stateMap[statePath];
                  const descriptor = this._getDescriptor(state, member, (descriptor => descriptor.get));
                  if (descriptor) {
                      descriptors[index] = descriptor;
                      const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                      aliases[index] = alias;
                      if (!this._router.prototype.hasOwnProperty(alias)) {
                          Object.defineProperty(this._router.prototype, alias, descriptor);
                      }
                  } else {
                      descriptors[index] = null;
                      aliases[index] = null;
                  }
              });
              const code = [
                  "//@ sourceURL=StateMachineRouter.js",
                  "var i = this._stateIndex;"
              ];
              let cur = aliases[0];
              for (let i = 1, n = aliases.length; i < n; i++) {
                  const alias = aliases[i];
                  if (alias !== cur) {
                      if (cur) {
                          code.push(`if (i < ${i}) return this["${cur}"]; else`);
                      } else {
                          code.push(`if (i < ${i}) return ; else`);
                      }
                  }
                  cur = alias;
              }
              if (cur) {
                  code.push(`return this["${cur}"];`);
              } else {
                  code.push(`;`);
              }
              const functionBody = code.join("\n");
              const router = new Function([], functionBody);
              return router;
          }
          _getSetterRouter(member) {
              const statePaths = Object.keys(this._stateMap);
              const descriptors = [];
              const aliases = [];
              statePaths.forEach((statePath, index) => {
                  const state = this._stateMap[statePath];
                  const descriptor = this._getDescriptor(state, member, (descriptor => descriptor.set));
                  if (descriptor) {
                      descriptors[index] = descriptor;
                      const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                      aliases[index] = alias;
                      if (!this._router.prototype.hasOwnProperty(alias)) {
                          Object.defineProperty(this._router.prototype, alias, descriptor);
                      }
                  } else {
                      descriptors[index] = null;
                      aliases[index] = null;
                  }
              });
              const code = [
                  "//@ sourceURL=StateMachineRouter.js",
                  "var i = this._stateIndex;"
              ];
              let cur = aliases[0];
              for (let i = 1, n = aliases.length; i < n; i++) {
                  const alias = aliases[i];
                  if (alias !== cur) {
                      if (cur) {
                          code.push(`if (i < ${i}) this["${cur}"] = arg; else`);
                      } else {
                          code.push(`if (i < ${i}) ; else`);
                      }
                  }
                  cur = alias;
              }
              if (cur) {
                  code.push(`this["${cur}"] = arg;`);
              } else {
                  code.push(`;`);
              }
              const functionBody = code.join("\n");
              const router = new Function(["arg"], functionBody);
              return router;
          }
          static getStateMemberAlias(path, member) {
              return "$" + (path ? path + "." : "") + member;
          }
          _getAllMemberNames() {
              const stateMap = this._stateMap;
              const map = Object.keys(stateMap);
              let members = new Set();
              map.forEach(statePath => {
                  if (statePath === "") {
                      return;
                  }
                  const state = stateMap[statePath];
                  const names = this._getStateMemberNames(state);
                  names.forEach(name => {
                      members.add(name);
                  });
              });
              return [...members];
          }
          _getStateMemberNames(state) {
              let type = state;
              let members = new Set();
              const isRoot = this._type === state;
              do {
                  const names = this._getStateMemberNamesForType(type);
                  names.forEach(name => {
                      members.add(name);
                  });
                  type = Object.getPrototypeOf(type);
              } while(type && type.prototype && (!type.hasOwnProperty("__state") || isRoot));
              return members;
          }
          _getStateMemberNamesForType(type) {
              const memberNames = Object.getOwnPropertyNames(type.prototype);
              return memberNames.filter(memberName => {
                  return (memberName !== "constructor") && !StateMachineType._isStateLocalMember(memberName);
              });
          }
          static _isStateLocalMember(memberName) {
              return (memberName === "$enter") || (memberName === "$exit");
          }
          getStateByPath(statePath) {
              if (this._stateMap[statePath]) {
                  return this._stateMap[statePath];
              }
              const parts = statePath.split(".");
              while(parts.pop()) {
                  const statePath = parts.join(".");
                  if (this._stateMap[statePath]) {
                      return this._stateMap[statePath];
                  }
              }
          }
          _getStateMap() {
              if (!this._stateMap) {
                  this._stateMap = this._createStateMap();
              }
              return this._stateMap;
          }
          _createStateMap() {
              const stateMap = {};
              this._addState(this._type, null, "", stateMap);
              return stateMap;
          }
          _addState(state, parentState, name, stateMap) {
              state.__state = true;
              state.__name = name;
              this._addStaticStateProperty(state, parentState);
              const parentPath = (parentState ? parentState.__path : "");
              let path = (parentPath ? parentPath + "." : "") + name;
              state.__path = path;
              state.__level = parentState ? parentState.__level + 1 : 0;
              state.__parent = parentState;
              state.__index = Object.keys(stateMap).length;
              stateMap[path] = state;
              const states = state._states;
              if (states) {
                  const isInheritedFromParent = (parentState && parentState._states === states);
                  if (!isInheritedFromParent) {
                      const subStates = state._states();
                      subStates.forEach(subState => {
                          const stateName = StateMachineType._getStateName(subState);
                          this._addState(subState, state, stateName, stateMap);
                      });
                  }
              }
          }
          static _getStateName(state) {
              const name = state.name;
              const index = name.indexOf('$');
              if (index > 0) {
                  return name.substr(0, index);
              }
              return name;
          }
          _addStaticStateProperty(state, parentState) {
              if (parentState) {
                  const isClassStateLevel = parentState && !parentState.__parent;
                  if (isClassStateLevel) {
                      this._router[state.__name] = state;
                  } else {
                      parentState[state.__name] = state;
                  }
              }
          }
      }

      class Component extends Element {
          constructor(stage, properties) {
              super(stage);
              this.tagRoot = true;
              if (Utils.isObjectLiteral(properties)) {
                  Object.assign(this, properties);
              }
              this.__initialized = false;
              this.__firstActive = false;
              this.__firstEnable = false;
              this.__signals = undefined;
              this.__passSignals = undefined;
              this.__construct();
              const func = this.constructor.getTemplateFunc(this);
              func.f(this, func.a);
              this._build();
          }
          __start() {
              StateMachine.setupStateMachine(this);
              this._onStateChange = Component.prototype.__onStateChange;
          }
          get state() {
              return this._getState();
          }
          __onStateChange() {
              if (this.application) {
                  this.application.updateFocusPath();
              }
          }
          _refocus() {
              if (this.application) {
                  this.application.updateFocusPath();
              }
          }
          static bindProp(name, func = null) {
              return {__propertyBinding: true, __name: name, __func: func};
          }
          __bindProperty(propObj, targetObj, targetProp) {
              const obj = targetObj;
              const prop = targetProp;
              const propName = propObj.__name;
              const func = propObj.__func ? propObj.__func : (context) => context[propName];
              if (!this.hasOwnProperty(propName)) {
                  this[`__prop_bindings_${propName}`] = [{__obj: obj, __prop: prop, __func: func}];
                  Object.defineProperty(this, propName, {
                      set: (value) => {
                          this[`__prop_${propName}`] = value;
                          for (const {__obj, __prop, __func} of this[`__prop_bindings_${propName}`]) {
                              __obj[__prop] = __func(this);
                          }
                      },
                      get: () => this[`__prop_${propName}`]
                  });
              } else {
                  this[`__prop_bindings_${propName}`].push({__obj: obj, __prop: prop, __func: func});
              }
          }
          static getTemplateFunc(ctx) {
              const name = "_templateFunc";
              const hasName = '__has' + name;
              if (this[hasName] !== this) {
                  this[hasName] = this;
                  this[name] = this.parseTemplate(this._template(ctx));
              }
              return this[name];
          }
          static parseTemplate(obj) {
              const context = {
                  loc: [],
                  store: [],
                  rid: 0
              };
              this.parseTemplateRec(obj, context, "element");
              const code = context.loc.join(";\n");
              const f = new Function("element", "store", code);
              return {f: f, a: context.store};
          }
          static parseTemplateRec(obj, context, cursor) {
              const store = context.store;
              const loc = context.loc;
              const keys = Object.keys(obj);
              keys.forEach(key => {
                  let value = obj[key];
                  if (Utils.isUcChar(key.charCodeAt(0))) {
                      if (Utils.isObjectLiteral(value)) {
                          const childCursor = `r${key.replace(/[^a-z0-9]/gi, "") + context.rid}`;
                          let type = value.type ? value.type : Element;
                          if (type === Element) {
                              loc.push(`var ${childCursor} = element.stage.createElement()`);
                          } else {
                              store.push(type);
                              loc.push(`var ${childCursor} = new store[${store.length - 1}](${cursor}.stage)`);
                          }
                          loc.push(`${childCursor}.ref = "${key}"`);
                          context.rid++;
                          this.parseTemplateRec(value, context, childCursor);
                          loc.push(`${cursor}.childList.add(${childCursor})`);
                      } else if (Utils.isObject(value)) {
                          store.push(value);
                          loc.push(`${cursor}.childList.add(store[${store.length - 1}])`);
                      }
                  } else {
                      if (key === "text") {
                          const propKey = cursor + "__text";
                          loc.push(`var ${propKey} = ${cursor}.enableTextTexture()`);
                          this.parseTemplatePropRec(value, context, propKey);
                      } else if (key === "texture" && Utils.isObjectLiteral(value)) {
                          const propKey = cursor + "__texture";
                          const type = value.type;
                          if (type) {
                              store.push(type);
                              loc.push(`var ${propKey} = new store[${store.length - 1}](${cursor}.stage)`);
                              this.parseTemplatePropRec(value, context, propKey);
                              loc.push(`${cursor}["${key}"] = ${propKey}`);
                          } else {
                              loc.push(`${propKey} = ${cursor}.texture`);
                              this.parseTemplatePropRec(value, context, propKey);
                          }
                      } else if (Utils.isObjectLiteral(value) && value.__propertyBinding === true) {
                          store.push(value);
                          loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                      } else {
                          if (Utils.isNumber(value)) {
                              loc.push(`${cursor}["${key}"] = ${value}`);
                          } else if (Utils.isBoolean(value)) {
                              loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                          } else if (Utils.isObject(value) || Array.isArray(value)) {
                              store.push(value);
                              loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                          } else {
                              loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                          }
                      }
                  }
              });
          }
          static parseTemplatePropRec(obj, context, cursor) {
              const store = context.store;
              const loc = context.loc;
              const keys = Object.keys(obj);
              keys.forEach(key => {
                  if (key !== "type") {
                      const value = obj[key];
                      if (Utils.isNumber(value)) {
                          loc.push(`${cursor}["${key}"] = ${value}`);
                      } else if (Utils.isBoolean(value)) {
                          loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                      } else if (Utils.isObject(value) && value.__propertyBinding === true) {
                          store.push(value);
                          loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                      } else if (Utils.isObject(value) || Array.isArray(value)) {
                          store.push(value);
                          loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                      } else {
                          loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                      }
                  }
              });
          }
          _onSetup() {
              if (!this.__initialized) {
                  this._setup();
              }
          }
          _setup() {
          }
          _onAttach() {
              if (!this.__initialized) {
                  this.__init();
                  this.__initialized = true;
              }
              this._attach();
          }
          _attach() {
          }
          _onDetach() {
              this._detach();
          }
          _detach() {
          }
          _onEnabled() {
              if (!this.__firstEnable) {
                  this._firstEnable();
                  this.__firstEnable = true;
              }
              this._enable();
          }
          _firstEnable() {
          }
          _enable() {
          }
          _onDisabled() {
              this._disable();
          }
          _disable() {
          }
          _onActive() {
              if (!this.__firstActive) {
                  this._firstActive();
                  this.__firstActive = true;
              }
              this._active();
          }
          _firstActive() {
          }
          _active() {
          }
          _onInactive() {
              this._inactive();
          }
          _inactive() {
          }
          get application() {
              return this.stage.application;
          }
          __construct() {
              this._construct();
          }
          _construct() {
          }
          _build() {
          }
          __init() {
              this._init();
          }
          _init() {
          }
          _focus(newTarget, prevTarget) {
          }
          _unfocus(newTarget) {
          }
          _focusChange(target, newTarget) {
          }
          _getFocused() {
              return this;
          }
          _setFocusSettings(settings) {
          }
          _handleFocusSettings(settings) {
          }
          static _template() {
              return {};
          }
          hasFinalFocus() {
              let path = this.application._focusPath;
              return path && path.length && path[path.length - 1] === this;
          }
          hasFocus() {
              let path = this.application._focusPath;
              return path && (path.indexOf(this) >= 0);
          }
          get cparent() {
              return Component.getParent(this);
          }
          seekAncestorByType(type) {
              let c = this.cparent;
              while (c) {
                  if (c.constructor === type) {
                      return c;
                  }
                  c = c.cparent;
              }
          }
          getSharedAncestorComponent(element) {
              let ancestor = this.getSharedAncestor(element);
              while (ancestor && !ancestor.isComponent) {
                  ancestor = ancestor.parent;
              }
              return ancestor;
          }
          get signals() {
              return this.__signals;
          }
          set signals(v) {
              if (!Utils.isObjectLiteral(v)) {
                  this._throwError("Signals: specify an object with signal-to-fire mappings");
              }
              this.__signals = v;
          }
          set alterSignals(v) {
              if (!Utils.isObjectLiteral(v)) {
                  this._throwError("Signals: specify an object with signal-to-fire mappings");
              }
              if (!this.__signals) {
                  this.__signals = {};
              }
              for (let key in v) {
                  const d = v[key];
                  if (d === undefined) {
                      delete this.__signals[key];
                  } else {
                      this.__signals[key] = v;
                  }
              }
          }
          get passSignals() {
              return this.__passSignals || {};
          }
          set passSignals(v) {
              this.__passSignals = Object.assign(this.__passSignals || {}, v);
          }
          set alterPassSignals(v) {
              if (!Utils.isObjectLiteral(v)) {
                  this._throwError("Signals: specify an object with signal-to-fire mappings");
              }
              if (!this.__passSignals) {
                  this.__passSignals = {};
              }
              for (let key in v) {
                  const d = v[key];
                  if (d === undefined) {
                      delete this.__passSignals[key];
                  } else {
                      this.__passSignals[key] = v;
                  }
              }
          }
          signal(event, ...args) {
              return this._signal(event, args);
          }
          _signal(event, args) {
              const signalParent = this._getParentSignalHandler();
              if (signalParent) {
                  if (this.__signals) {
                      let fireEvent = this.__signals[event];
                      if (fireEvent === false) {
                          return;
                      }
                      if (fireEvent) {
                          if (fireEvent === true) {
                              fireEvent = event;
                          }
                          if (Utils.isFunction(fireEvent)) {
                              return fireEvent(...args);
                          }
                          if (signalParent._hasMethod(fireEvent)) {
                              return signalParent[fireEvent](...args);
                          }
                      }
                  }
                  let passSignal = (this.__passSignals && this.__passSignals[event]);
                  if (passSignal) {
                      if (passSignal && passSignal !== true) {
                          event = passSignal;
                      }
                      return signalParent._signal(event, args);
                  }
              }
          }
          _getParentSignalHandler() {
              return this.cparent ? this.cparent._getSignalHandler() : null;
          }
          _getSignalHandler() {
              if (this._signalProxy) {
                  return this.cparent ? this.cparent._getSignalHandler() : null;
              }
              return this;
          }
          get _signalProxy() {
              return false;
          }
          fireAncestors(name, ...args) {
              if (!name.startsWith('$')) {
                  throw new Error("Ancestor event name must be prefixed by dollar sign.");
              }
              const parent = this._getParentSignalHandler();
              if (parent) {
                  return parent._doFireAncestors(name, args);
              }
          }
          _doFireAncestors(name, args) {
              if (this._hasMethod(name)) {
                  return this.fire(name, ...args);
              } else {
                  const signalParent = this._getParentSignalHandler();
                  if (signalParent) {
                      return signalParent._doFireAncestors(name, args);
                  }
              }
          }
          static collectSubComponents(subs, element) {
              if (element.hasChildren()) {
                  const childList = element.__childList;
                  for (let i = 0, n = childList.length; i < n; i++) {
                      const child = childList.getAt(i);
                      if (child.isComponent) {
                          subs.push(child);
                      } else {
                          Component.collectSubComponents(subs, child);
                      }
                  }
              }
          }
          static getComponent(element) {
              let parent = element;
              while (parent && !parent.isComponent) {
                  parent = parent.parent;
              }
              return parent;
          }
          static getParent(element) {
              return Component.getComponent(element.parent);
          }
      }
      Component.prototype.isComponent = true;

      class CoreQuadList {
          constructor(ctx) {
              this.ctx = ctx;
              this.quadTextures = [];
              this.quadElements = [];
          }
          get length() {
              return this.quadTextures.length;
          }
          reset() {
              this.quadTextures = [];
              this.quadElements = [];
              this.dataLength = 0;
          }
          getElement(index) {
              return this.quadElements[index]._element;
          }
          getElementCore(index) {
              return this.quadElements[index];
          }
          getTexture(index) {
              return this.quadTextures[index];
          }
          getTextureWidth(index) {
              let nativeTexture = this.quadTextures[index];
              if (nativeTexture.w) {
                  return nativeTexture.w;
              } else {
                  return this.quadElements[index]._displayedTextureSource.w;
              }
          }
          getTextureHeight(index) {
              let nativeTexture = this.quadTextures[index];
              if (nativeTexture.h) {
                  return nativeTexture.h;
              } else {
                  return this.quadElements[index]._displayedTextureSource.h;
              }
          }
      }

      class WebGLCoreQuadList extends CoreQuadList {
          constructor(ctx) {
              super(ctx);
              const byteSize = ctx.stage.getOption('bufferMemory');
              this.dataLength = 0;
              this.data = new ArrayBuffer(byteSize);
              this.floats = new Float32Array(this.data);
              this.uints = new Uint32Array(this.data);
          }
          getAttribsDataByteOffset(index) {
              return index * 80;
          }
          getQuadContents() {
              let floats = this.floats;
              let uints = this.uints;
              let lines = [];
              for (let i = 1; i <= this.length; i++) {
                  let str = 'entry ' + i + ': ';
                  for (let j = 0; j < 4; j++) {
                      let b = i * 20 + j * 4;
                      str += floats[b] + ',' + floats[b+1] + ':' + floats[b+2] + ',' + floats[b+3] + '[' + uints[b+4].toString(16) + '] ';
                  }
                  lines.push(str);
              }
              return lines;
          }
      }

      class CoreQuadOperation {
          constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
              this.ctx = ctx;
              this.shader = shader;
              this.shaderOwner = shaderOwner;
              this.renderTextureInfo = renderTextureInfo;
              this.scissor = scissor;
              this.index = index;
              this.length = 0;
          }
          get quads() {
              return this.ctx.renderState.quads;
          }
          getTexture(index) {
              return this.quads.getTexture(this.index + index);
          }
          getElementCore(index) {
              return this.quads.getElementCore(this.index + index);
          }
          getElement(index) {
              return this.quads.getElement(this.index + index);
          }
          getElementWidth(index) {
              return this.getElement(index).renderWidth;
          }
          getElementHeight(index) {
              return this.getElement(index).renderHeight;
          }
          getTextureWidth(index) {
              return this.quads.getTextureWidth(this.index + index);
          }
          getTextureHeight(index) {
              return this.quads.getTextureHeight(this.index + index);
          }
          getRenderWidth() {
              if (this.renderTextureInfo) {
                  return this.renderTextureInfo.w;
              } else {
                  return this.ctx.stage.w;
              }
          }
          getRenderHeight() {
              if (this.renderTextureInfo) {
                  return this.renderTextureInfo.h;
              } else {
                  return this.ctx.stage.h;
              }
          }
      }

      class WebGLCoreQuadOperation extends CoreQuadOperation {
          constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
              super(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
              this.extraAttribsDataByteOffset = 0;
          }
          getAttribsDataByteOffset(index) {
              return this.quads.getAttribsDataByteOffset(this.index + index);
          }
          getNormalRenderTextureCoords(x, y) {
              let coords = this.shaderOwner.getRenderTextureCoords(x, y);
              coords[0] /= this.getRenderWidth();
              coords[1] /= this.getRenderHeight();
              coords[0] = coords[0] * 2 - 1;
              coords[1] = 1 - coords[1] * 2;
              return coords;
          }
          getProjection() {
              if (this.renderTextureInfo === null) {
                  return this.ctx.renderExec._projection;
              } else {
                  return this.renderTextureInfo.nativeTexture.projection;
              }
          }
      }

      class CoreRenderExecutor {
          constructor(ctx) {
              this.ctx = ctx;
              this.renderState = ctx.renderState;
              this.gl = this.ctx.stage.gl;
          }
          destroy() {
          }
          _reset() {
              this._bindRenderTexture(null);
              this._setScissor(null);
              this._clearRenderTexture();
          }
          execute() {
              this._reset();
              let qops = this.renderState.quadOperations;
              let i = 0, n = qops.length;
              while (i < n) {
                  this._processQuadOperation(qops[i]);
                  i++;
              }
          }
          _processQuadOperation(quadOperation) {
              if (quadOperation.renderTextureInfo && quadOperation.renderTextureInfo.ignore) {
                  return;
              }
              this._setupQuadOperation(quadOperation);
              this._execQuadOperation(quadOperation);
          }
          _setupQuadOperation(quadOperation) {
          }
          _execQuadOperation(op) {
              let nativeTexture = op.renderTextureInfo ? op.renderTextureInfo.nativeTexture : null;
              if (this._renderTexture !== nativeTexture) {
                  this._bindRenderTexture(nativeTexture);
              }
              if (op.renderTextureInfo && !op.renderTextureInfo.cleared) {
                  this._setScissor(null);
                  this._clearRenderTexture();
                  op.renderTextureInfo.cleared = true;
                  this._setScissor(op.scissor);
              } else {
                  this._setScissor(op.scissor);
              }
              this._renderQuadOperation(op);
          }
          _renderQuadOperation(op) {
          }
          _bindRenderTexture(renderTexture) {
              this._renderTexture = renderTexture;
          }
          _clearRenderTexture(renderTexture) {
          }
          _setScissor(area) {
          }
      }

      class WebGLCoreRenderExecutor extends CoreRenderExecutor {
          constructor(ctx) {
              super(ctx);
              this.gl = this.ctx.stage.gl;
              this.init();
          }
          init() {
              let gl = this.gl;
              this._attribsBuffer = gl.createBuffer();
              let maxQuads = Math.floor(this.renderState.quads.data.byteLength / 80);
              let allIndices = new Uint16Array(maxQuads * 6);
              for (let i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
                  allIndices[i] = j;
                  allIndices[i + 1] = j + 1;
                  allIndices[i + 2] = j + 2;
                  allIndices[i + 3] = j;
                  allIndices[i + 4] = j + 2;
                  allIndices[i + 5] = j + 3;
              }
              this._quadsBuffer = gl.createBuffer();
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, allIndices, gl.STATIC_DRAW);
              this._projection = new Float32Array([2/this.ctx.stage.coordsWidth, -2/this.ctx.stage.coordsHeight]);
          }
          destroy() {
              super.destroy();
              this.gl.deleteBuffer(this._attribsBuffer);
              this.gl.deleteBuffer(this._quadsBuffer);
          }
          _reset() {
              super._reset();
              let gl = this.gl;
              gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              gl.enable(gl.BLEND);
              gl.disable(gl.DEPTH_TEST);
              this._stopShaderProgram();
              this._setupBuffers();
          }
          _setupBuffers() {
              let gl = this.gl;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
              let element = new Float32Array(this.renderState.quads.data, 0, this.renderState.quads.dataLength);
              gl.bindBuffer(gl.ARRAY_BUFFER, this._attribsBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, element, gl.DYNAMIC_DRAW);
          }
          _setupQuadOperation(quadOperation) {
              super._setupQuadOperation(quadOperation);
              this._useShaderProgram(quadOperation.shader, quadOperation);
          }
          _renderQuadOperation(op) {
              let shader = op.shader;
              if (op.length || op.shader.addEmpty()) {
                  shader.beforeDraw(op);
                  shader.draw(op);
                  shader.afterDraw(op);
              }
          }
          _useShaderProgram(shader, operation) {
              if (!shader.hasSameProgram(this._currentShaderProgram)) {
                  if (this._currentShaderProgram) {
                      this._currentShaderProgram.stopProgram();
                  }
                  shader.useProgram();
                  this._currentShaderProgram = shader;
              }
              shader.setupUniforms(operation);
          }
          _stopShaderProgram() {
              if (this._currentShaderProgram) {
                  this._currentShaderProgram.stopProgram();
                  this._currentShaderProgram = null;
              }
          }
          _bindRenderTexture(renderTexture) {
              super._bindRenderTexture(renderTexture);
              let gl = this.gl;
              if (!this._renderTexture) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                  gl.viewport(0,0,this.ctx.stage.w,this.ctx.stage.h);
              } else {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderTexture.framebuffer);
                  gl.viewport(0,0,this._renderTexture.w, this._renderTexture.h);
              }
          }
          _clearRenderTexture() {
              super._clearRenderTexture();
              let gl = this.gl;
              if (!this._renderTexture) {
                  let glClearColor = this.ctx.stage.getClearColor();
                  if (glClearColor) {
                      gl.clearColor(glClearColor[0] * glClearColor[3], glClearColor[1] * glClearColor[3], glClearColor[2] * glClearColor[3], glClearColor[3]);
                      gl.clear(gl.COLOR_BUFFER_BIT);
                  }
              } else {
                  gl.clearColor(0, 0, 0, 0);
                  gl.clear(gl.COLOR_BUFFER_BIT);
              }
          }
          _setScissor(area) {
              super._setScissor(area);
              if (this._scissor === area) {
                  return;
              }
              this._scissor = area;
              let gl = this.gl;
              if (!area) {
                  gl.disable(gl.SCISSOR_TEST);
              } else {
                  gl.enable(gl.SCISSOR_TEST);
                  let precision = this.ctx.stage.getRenderPrecision();
                  let y = area[1];
                  if (this._renderTexture === null) {
                      y = (this.ctx.stage.h / precision - (area[1] + area[3]));
                  }
                  gl.scissor(Math.round(area[0] * precision), Math.round(y * precision), Math.round(area[2] * precision), Math.round(area[3] * precision));
              }
          }
      }

      class CoreRenderState {
          constructor(ctx) {
              this.ctx = ctx;
              this.stage = ctx.stage;
              this.defaultShader = this.stage.renderer.getDefaultShader(ctx);
              this.renderer = ctx.stage.renderer;
              this.quads = this.renderer.createCoreQuadList(ctx);
          }
          reset() {
              this._renderTextureInfo = null;
              this._scissor = null;
              this._shader = null;
              this._shaderOwner = null;
              this._realShader = null;
              this._check = false;
              this.quadOperations = [];
              this._texturizer = null;
              this._texturizerTemporary = false;
              this._quadOperation = null;
              this.quads.reset();
              this._temporaryTexturizers = [];
              this._isCachingTexturizer = false;
          }
          get length() {
              return this.quads.quadTextures.length;
          }
          setShader(shader, owner) {
              if (this._shaderOwner !== owner || this._realShader !== shader) {
                  this._realShader = shader;
                  if (shader.useDefault()) {
                      shader = this.defaultShader;
                  }
                  if (this._shader !== shader || this._shaderOwner !== owner) {
                      this._shader = shader;
                      this._shaderOwner = owner;
                      this._check = true;
                  }
              }
          }
          get renderTextureInfo() {
              return this._renderTextureInfo;
          }
          setScissor(area) {
              if (this._scissor !== area) {
                  if (area) {
                      this._scissor = area;
                  } else {
                      this._scissor = null;
                  }
                  this._check = true;
              }
          }
          getScissor() {
              return this._scissor;
          }
          setRenderTextureInfo(renderTextureInfo) {
              if (this._renderTextureInfo !== renderTextureInfo) {
                  this._renderTextureInfo = renderTextureInfo;
                  this._scissor = null;
                  this._check = true;
              }
          }
          setTexturizer(texturizer, cache = false) {
              this._texturizer = texturizer;
              this._cacheTexturizer = cache;
          }
          set isCachingTexturizer(v) {
              this._isCachingTexturizer = v;
          }
          get isCachingTexturizer() {
              return this._isCachingTexturizer;
          }
          addQuad(elementCore) {
              if (!this._quadOperation) {
                  this._createQuadOperation();
              } else if (this._check && this._hasChanges()) {
                  this._finishQuadOperation();
                  this._check = false;
              }
              let nativeTexture = null;
              if (this._texturizer) {
                  nativeTexture = this._texturizer.getResultTexture();
                  if (!this._cacheTexturizer) {
                      this._temporaryTexturizers.push(this._texturizer);
                  }
              }
              if (!nativeTexture) {
                  nativeTexture = elementCore._displayedTextureSource.nativeTexture;
              }
              if (this._renderTextureInfo) {
                  if (this._shader === this.defaultShader && this._renderTextureInfo.empty) {
                      this._renderTextureInfo.nativeTexture = nativeTexture;
                      this._renderTextureInfo.offset = this.length;
                  } else {
                      this._renderTextureInfo.nativeTexture = null;
                  }
                  this._renderTextureInfo.empty = false;
              }
              this.quads.quadTextures.push(nativeTexture);
              this.quads.quadElements.push(elementCore);
              this._quadOperation.length++;
              this.renderer.addQuad(this, this.quads, this.length - 1);
          }
          finishedRenderTexture() {
              if (this._renderTextureInfo.nativeTexture) {
                  if (!this._isRenderTextureReusable()) {
                      this._renderTextureInfo.nativeTexture = null;
                  }
              }
          }
          _isRenderTextureReusable() {
              const offset = this._renderTextureInfo.offset;
              return (this.quads.quadTextures[offset].w === this._renderTextureInfo.w) &&
                  (this.quads.quadTextures[offset].h === this._renderTextureInfo.h) &&
                  this.renderer.isRenderTextureReusable(this, this._renderTextureInfo)
          }
          _hasChanges() {
              let q = this._quadOperation;
              if (this._shader !== q.shader) return true;
              if (this._shaderOwner !== q.shaderOwner) return true;
              if (this._renderTextureInfo !== q.renderTextureInfo) return true;
              if (this._scissor !== q.scissor) {
                  if ((this._scissor[0] !== q.scissor[0]) || (this._scissor[1] !== q.scissor[1]) || (this._scissor[2] !== q.scissor[2]) || (this._scissor[3] !== q.scissor[3])) {
                      return true;
                  }
              }
              return false;
          }
          _finishQuadOperation(create = true) {
              if (this._quadOperation) {
                  if (this._quadOperation.length || this._shader.addEmpty()) {
                      if (!this._quadOperation.scissor || ((this._quadOperation.scissor[2] > 0) && (this._quadOperation.scissor[3] > 0))) {
                          this.quadOperations.push(this._quadOperation);
                      }
                  }
                  if (this._temporaryTexturizers.length) {
                      for (let i = 0, n = this._temporaryTexturizers.length; i < n; i++) {
                          this._temporaryTexturizers[i].releaseRenderTexture();
                      }
                      this._temporaryTexturizers = [];
                  }
                  this._quadOperation = null;
              }
              if (create) {
                  this._createQuadOperation();
              }
          }
          _createQuadOperation() {
              this._quadOperation = this.renderer.createCoreQuadOperation(
                  this.ctx,
                  this._shader,
                  this._shaderOwner,
                  this._renderTextureInfo,
                  this._scissor,
                  this.length
              );
              this._check = false;
          }
          finish() {
              if (this._quadOperation) {
                  this._finishQuadOperation(false);
              }
              this.renderer.finishRenderState(this);
          }
      }

      class WebGLShaderProgram {
          constructor(vertexShaderSource, fragmentShaderSource) {
              this.vertexShaderSource = vertexShaderSource;
              this.fragmentShaderSource = fragmentShaderSource;
              this._program = null;
              this._uniformLocations = new Map();
              this._attributeLocations = new Map();
              this._currentUniformValues = {};
          }
          compile(gl) {
              if (this._program) return;
              this.gl = gl;
              this._program = gl.createProgram();
              let glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexShaderSource);
              let glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentShaderSource);
              gl.attachShader(this._program, glVertShader);
              gl.attachShader(this._program, glFragShader);
              gl.linkProgram(this._program);
              if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
                  console.error('[Lightning] Error: Could not initialize shader.');
                  console.error('[Lightning] gl.VALIDATE_STATUS', gl.getProgramParameter(this._program, gl.VALIDATE_STATUS));
                  console.error('[Lightning] gl.getError()', gl.getError());
                  if (gl.getProgramInfoLog(this._program) !== '') {
                      console.warn('[Lightning] Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(this._program));
                  }
                  gl.deleteProgram(this._program);
                  this._program = null;
              }
              gl.deleteShader(glVertShader);
              gl.deleteShader(glFragShader);
          }
          _glCompile(type, src) {
              let shader = this.gl.createShader(type);
              this.gl.shaderSource(shader, src);
              this.gl.compileShader(shader);
              if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                  console.error('[Lightning]', this.constructor.name, 'Type: ' + (type === this.gl.VERTEX_SHADER ? 'vertex shader' : 'fragment shader') );
                  console.error('[Lightning]', this.gl.getShaderInfoLog(shader));
                  let idx = 0;
                  console.error('[Lightning]', "========== source ==========\n" + src.split("\n").map(line => "" + (++idx) + ": " + line).join("\n"));
                  return null;
              }
              return shader;
          }
          getUniformLocation(name) {
              let location = this._uniformLocations.get(name);
              if (location === undefined) {
                  location = this.gl.getUniformLocation(this._program, name);
                  this._uniformLocations.set(name, location);
              }
              return location;
          }
          getAttribLocation(name) {
              let location = this._attributeLocations.get(name);
              if (location === undefined) {
                  location = this.gl.getAttribLocation(this._program, name);
                  this._attributeLocations.set(name, location);
              }
              return location;
          }
          destroy() {
              if (this._program) {
                  this.gl.deleteProgram(this._program);
                  this._program = null;
              }
          }
          get glProgram() {
              return this._program;
          }
          get compiled() {
              return !!this._program;
          }
          _valueEquals(v1, v2) {
              if (v1.length && v2.length) {
                  for (let i = 0, n = v1.length; i < n; i++) {
                      if (v1[i] !== v2[i]) return false;
                  }
                  return true;
              } else {
                  return (v1 === v2);
              }
          }
          _valueClone(v) {
              if (v.length) {
                  return v.slice(0);
              } else {
                  return v;
              }
          }
          setUniformValue(name, value, glFunction) {
              let v = this._currentUniformValues[name];
              if (v === undefined || !this._valueEquals(v, value)) {
                  let clonedValue = this._valueClone(value);
                  this._currentUniformValues[name] = clonedValue;
                  let loc = this.getUniformLocation(name);
                  if (loc) {
                      let isMatrix = (glFunction === this.gl.uniformMatrix2fv || glFunction === this.gl.uniformMatrix3fv || glFunction === this.gl.uniformMatrix4fv);
                      if (isMatrix) {
                          glFunction.call(this.gl, loc, false, clonedValue);
                      } else {
                          glFunction.call(this.gl, loc, clonedValue);
                      }
                  }
              }
          }
      }

      class WebGLShader extends Shader {
          constructor(ctx) {
              super(ctx);
              const stage = ctx.stage;
              this._program = stage.renderer.shaderPrograms.get(this.constructor);
              if (!this._program) {
                  this._program = new WebGLShaderProgram(this.constructor.vertexShaderSource, this.constructor.fragmentShaderSource);
                  stage.renderer.shaderPrograms.set(this.constructor, this._program);
              }
              this.gl = stage.gl;
          }
          get glProgram() {
              return this._program.glProgram;
          }
          _init() {
              if (!this._initialized) {
                  this.initialize();
                  this._initialized = true;
              }
          }
          initialize() {
              this._program.compile(this.gl);
          }
          get initialized() {
              return this._initialized;
          }
          _uniform(name) {
              return this._program.getUniformLocation(name);
          }
          _attrib(name) {
              return this._program.getAttribLocation(name);
          }
          _setUniform(name, value, glFunction) {
              this._program.setUniformValue(name, value, glFunction);
          }
          useProgram() {
              this._init();
              this.gl.useProgram(this.glProgram);
              this.beforeUsage();
              this.enableAttribs();
          }
          stopProgram() {
              this.afterUsage();
              this.disableAttribs();
          }
          hasSameProgram(other) {
              return (other && ((other === this) || (other._program === this._program)));
          }
          beforeUsage() {
          }
          afterUsage() {
          }
          enableAttribs() {
          }
          disableAttribs() {
          }
          getExtraAttribBytesPerVertex() {
              return 0;
          }
          getVertexAttribPointerOffset(operation) {
              return operation.extraAttribsDataByteOffset - operation.index * 4 * this.getExtraAttribBytesPerVertex();
          }
          setExtraAttribsInBuffer(operation) {
          }
          setupUniforms(operation) {
          }
          _getProjection(operation) {
              return operation.getProjection();
          }
          getFlipY(operation) {
              return this._getProjection(operation)[1] < 0;
          }
          beforeDraw(operation) {
          }
          draw(operation) {
          }
          afterDraw(operation) {
          }
          cleanup() {
              this._initialized = false;
          }
      }

      class DefaultShader extends WebGLShader {
          enableAttribs() {
              let gl = this.gl;
              gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
              gl.enableVertexAttribArray(this._attrib("aVertexPosition"));
              if (this._attrib("aTextureCoord") !== -1) {
                  gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
                  gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
              }
              if (this._attrib("aColor") !== -1) {
                  gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
                  gl.enableVertexAttribArray(this._attrib("aColor"));
              }
          }
          disableAttribs() {
              let gl = this.gl;
              gl.disableVertexAttribArray(this._attrib("aVertexPosition"));
              if (this._attrib("aTextureCoord") !== -1) {
                  gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
              }
              if (this._attrib("aColor") !== -1) {
                  gl.disableVertexAttribArray(this._attrib("aColor"));
              }
          }
          setupUniforms(operation) {
              this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
          }
          draw(operation) {
              let gl = this.gl;
              let length = operation.length;
              if (length) {
                  let glTexture = operation.getTexture(0);
                  let pos = 0;
                  for (let i = 0; i < length; i++) {
                      let tx = operation.getTexture(i);
                      if (glTexture !== tx) {
                          gl.bindTexture(gl.TEXTURE_2D, glTexture);
                          gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                          glTexture = tx;
                          pos = i;
                      }
                  }
                  if (pos < length) {
                      gl.bindTexture(gl.TEXTURE_2D, glTexture);
                      gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                  }
              }
          }
      }
      DefaultShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      DefaultShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;

      class Renderer {
          constructor(stage) {
              this.stage = stage;
              this._defaultShader = undefined;
          }
          gc(aggressive) {
          }
          destroy() {
          }
          getDefaultShader(ctx = this.stage.ctx) {
              if (!this._defaultShader) {
                  this._defaultShader = this._createDefaultShader(ctx);
              }
              return this._defaultShader;
          }
          _createDefaultShader(ctx) {
          }
          isValidShaderType(shaderType) {
              return (shaderType.prototype instanceof this._getShaderBaseType());
          }
          createShader(ctx, settings) {
              const shaderType = settings.type;
              if (!this.isValidShaderType(shaderType)) {
                  const convertedShaderType = this._getShaderAlternative(shaderType);
                  if (!convertedShaderType) {
                      console.warn("[Lightning] Shader has no implementation for render target: " + shaderType.name);
                      return this._createDefaultShader(ctx);
                  }
                  return new convertedShaderType(ctx);
              } else {
                  const shader = new shaderType(ctx);
                  Base.patchObject(this, settings);
                  return shader;
              }
          }
          _getShaderBaseType() {
          }
          _getShaderAlternative(shaderType) {
              return this.getDefaultShader();
          }
          copyRenderTexture(renderTexture, nativeTexture, options) {
              console.warn('[Lightning] copyRenderTexture not supported by renderer');
          }
      }

      class WebGLRenderer extends Renderer {
          constructor(stage) {
              super(stage);
              this.shaderPrograms = new Map();
          }
          destroy() {
              this.shaderPrograms.forEach(shaderProgram => shaderProgram.destroy());
          }
          _createDefaultShader(ctx) {
              return new DefaultShader(ctx);
          }
          _getShaderBaseType() {
              return WebGLShader
          }
          _getShaderAlternative(shaderType) {
              return shaderType.getWebGL && shaderType.getWebGL();
          }
          createCoreQuadList(ctx) {
              return new WebGLCoreQuadList(ctx);
          }
          createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
              return new WebGLCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
          }
          createCoreRenderExecutor(ctx) {
              return new WebGLCoreRenderExecutor(ctx);
          }
          createCoreRenderState(ctx) {
              return new CoreRenderState(ctx);
          }
          createRenderTexture(w, h, pw, ph) {
              const gl = this.stage.gl;
              const glTexture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, glTexture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pw, ph, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              glTexture.params = {};
              glTexture.params[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
              glTexture.params[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
              glTexture.params[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
              glTexture.params[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
              glTexture.options = {format: gl.RGBA, internalFormat: gl.RGBA, type: gl.UNSIGNED_BYTE};
              glTexture.framebuffer = gl.createFramebuffer();
              glTexture.projection = new Float32Array([2/w, 2/h]);
              gl.bindFramebuffer(gl.FRAMEBUFFER, glTexture.framebuffer);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);
              return glTexture;
          }
          freeRenderTexture(glTexture) {
              let gl = this.stage.gl;
              gl.deleteFramebuffer(glTexture.framebuffer);
              gl.deleteTexture(glTexture);
          }
          uploadTextureSource(textureSource, options) {
              const gl = this.stage.gl;
              const source = options.source;
              const format = {
                  premultiplyAlpha: true,
                  hasAlpha: true
              };
              if (options && options.hasOwnProperty('premultiplyAlpha')) {
                  format.premultiplyAlpha = options.premultiplyAlpha;
              }
              if (options && options.hasOwnProperty('flipBlueRed')) {
                  format.flipBlueRed = options.flipBlueRed;
              }
              if (options && options.hasOwnProperty('hasAlpha')) {
                  format.hasAlpha = options.hasAlpha;
              }
              if (!format.hasAlpha) {
                  format.premultiplyAlpha = false;
              }
              format.texParams = options.texParams || {};
              format.texOptions = options.texOptions || {};
              let glTexture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, glTexture);
              gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, format.premultiplyAlpha);
              if (Utils.isNode) {
                  gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, !!format.flipBlueRed);
              }
              const texParams = format.texParams;
              if (!texParams[gl.TEXTURE_MAG_FILTER]) texParams[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
              if (!texParams[gl.TEXTURE_MIN_FILTER]) texParams[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
              if (!texParams[gl.TEXTURE_WRAP_S]) texParams[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
              if (!texParams[gl.TEXTURE_WRAP_T]) texParams[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
              Object.keys(texParams).forEach(key => {
                  const value = texParams[key];
                  gl.texParameteri(gl.TEXTURE_2D, parseInt(key), value);
              });
              const texOptions = format.texOptions;
              texOptions.format = texOptions.format || (format.hasAlpha ? gl.RGBA : gl.RGB);
              texOptions.type = texOptions.type || gl.UNSIGNED_BYTE;
              texOptions.internalFormat = texOptions.internalFormat || texOptions.format;
              if (options && options.imageRef) {
                  texOptions.imageRef = options.imageRef;
              }
              this.stage.platform.uploadGlTexture(gl, textureSource, source, texOptions);
              glTexture.params = Utils.cloneObjShallow(texParams);
              glTexture.options = Utils.cloneObjShallow(texOptions);
              return glTexture;
          }
          freeTextureSource(textureSource) {
              this.stage.gl.deleteTexture(textureSource.nativeTexture);
          }
          addQuad(renderState, quads, index) {
              let offset = (index * 20);
              const elementCore = quads.quadElements[index];
              let r = elementCore._renderContext;
              let floats = renderState.quads.floats;
              let uints = renderState.quads.uints;
              const mca = StageUtils.mergeColorAlpha;
              if (r.tb !== 0 || r.tc !== 0) {
                  floats[offset++] = r.px;
                  floats[offset++] = r.py;
                  floats[offset++] = elementCore._ulx;
                  floats[offset++] = elementCore._uly;
                  uints[offset++] = mca(elementCore._colorUl, r.alpha);
                  floats[offset++] = r.px + elementCore._w * r.ta;
                  floats[offset++] = r.py + elementCore._w * r.tc;
                  floats[offset++] = elementCore._brx;
                  floats[offset++] = elementCore._uly;
                  uints[offset++] = mca(elementCore._colorUr, r.alpha);
                  floats[offset++] = r.px + elementCore._w * r.ta + elementCore._h * r.tb;
                  floats[offset++] = r.py + elementCore._w * r.tc + elementCore._h * r.td;
                  floats[offset++] = elementCore._brx;
                  floats[offset++] = elementCore._bry;
                  uints[offset++] = mca(elementCore._colorBr, r.alpha);
                  floats[offset++] = r.px + elementCore._h * r.tb;
                  floats[offset++] = r.py + elementCore._h * r.td;
                  floats[offset++] = elementCore._ulx;
                  floats[offset++] = elementCore._bry;
                  uints[offset] = mca(elementCore._colorBl, r.alpha);
              } else {
                  let cx = r.px + elementCore._w * r.ta;
                  let cy = r.py + elementCore._h * r.td;
                  floats[offset++] = r.px;
                  floats[offset++] = r.py;
                  floats[offset++] = elementCore._ulx;
                  floats[offset++] = elementCore._uly;
                  uints[offset++] = mca(elementCore._colorUl, r.alpha);
                  floats[offset++] = cx;
                  floats[offset++] = r.py;
                  floats[offset++] = elementCore._brx;
                  floats[offset++] = elementCore._uly;
                  uints[offset++] = mca(elementCore._colorUr, r.alpha);
                  floats[offset++] = cx;
                  floats[offset++] = cy;
                  floats[offset++] = elementCore._brx;
                  floats[offset++] = elementCore._bry;
                  uints[offset++] = mca(elementCore._colorBr, r.alpha);
                  floats[offset++] = r.px;
                  floats[offset++] = cy;
                  floats[offset++] = elementCore._ulx;
                  floats[offset++] = elementCore._bry;
                  uints[offset] = mca(elementCore._colorBl, r.alpha);
              }
          }
          isRenderTextureReusable(renderState, renderTextureInfo) {
              let offset = (renderState._renderTextureInfo.offset * 80) / 4;
              let floats = renderState.quads.floats;
              let uints = renderState.quads.uints;
              return ((floats[offset] === 0) &&
                  (floats[offset + 1] === 0) &&
                  (floats[offset + 2] === 0) &&
                  (floats[offset + 3] === 0) &&
                  (uints[offset + 4] === 0xFFFFFFFF) &&
                  (floats[offset + 5] === renderTextureInfo.w) &&
                  (floats[offset + 6] === 0) &&
                  (floats[offset + 7] === 1) &&
                  (floats[offset + 8] === 0) &&
                  (uints[offset + 9] === 0xFFFFFFFF) &&
                  (floats[offset + 10] === renderTextureInfo.w) &&
                  (floats[offset + 11] === renderTextureInfo.h) &&
                  (floats[offset + 12] === 1) &&
                  (floats[offset + 13] === 1) &&
                  (uints[offset + 14] === 0xFFFFFFFF) &&
                  (floats[offset + 15] === 0) &&
                  (floats[offset + 16] === renderTextureInfo.h) &&
                  (floats[offset + 17] === 0) &&
                  (floats[offset + 18] === 1) &&
                  (uints[offset + 19] === 0xFFFFFFFF));
          }
          finishRenderState(renderState) {
              let offset = renderState.length * 80;
              for (let i = 0, n = renderState.quadOperations.length; i < n; i++) {
                  renderState.quadOperations[i].extraAttribsDataByteOffset = offset;
                  let extra = renderState.quadOperations[i].shader.getExtraAttribBytesPerVertex() * 4 * renderState.quadOperations[i].length;
                  offset += extra;
                  if (extra) {
                      renderState.quadOperations[i].shader.setExtraAttribsInBuffer(renderState.quadOperations[i], renderState.quads);
                  }
              }
              renderState.quads.dataLength = offset;
          }
          copyRenderTexture(renderTexture, nativeTexture, options) {
              const gl = this.stage.gl;
              gl.bindTexture(gl.TEXTURE_2D, nativeTexture);
              gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture.framebuffer);
              const precision = renderTexture.precision;
              gl.copyTexSubImage2D(
                  gl.TEXTURE_2D,
                  0,
                  precision * (options.sx || 0),
                  precision * (options.sy || 0),
                  precision * (options.x || 0),
                  precision * (options.y || 0),
                  precision * (options.w || renderTexture.ow),
                  precision * (options.h || renderTexture.oh));
          }
      }

      class C2dCoreQuadList extends CoreQuadList {
          constructor(ctx) {
              super(ctx);
              this.renderContexts = [];
              this.modes = [];
          }
          setRenderContext(index, v) {
              this.renderContexts[index] = v;
          }
          setSimpleTc(index, v) {
              if (v) {
                  this.modes[index] |= 1;
              } else {
                  this.modes[index] -= (this.modes[index] & 1);
              }
          }
          setWhite(index, v) {
              if (v) {
                  this.modes[index] |= 2;
              } else {
                  this.modes[index] -= (this.modes[index] & 2);
              }
          }
          getRenderContext(index) {
              return this.renderContexts[index];
          }
          getSimpleTc(index) {
              return (this.modes[index] & 1);
          }
          getWhite(index) {
              return (this.modes[index] & 2);
          }
      }

      class C2dCoreQuadOperation extends CoreQuadOperation {
          getRenderContext(index) {
              return this.quads.getRenderContext(this.index + index);
          }
          getSimpleTc(index) {
              return this.quads.getSimpleTc(this.index + index);
          }
          getWhite(index) {
              return this.quads.getWhite(this.index + index);
          }
      }

      class C2dCoreRenderExecutor extends CoreRenderExecutor {
          init() {
              this._mainRenderTexture = this.ctx.stage.getCanvas();
          }
          _renderQuadOperation(op) {
              console.log('_renderQuadOperation')
              let shader = op.shader;
              if (op.length || op.shader.addEmpty()) {
                  const target = this._renderTexture || this._mainRenderTexture;
                  shader.beforeDraw(op, target);
                  shader.draw(op, target);
                  shader.afterDraw(op, target);
              }
          }
          _clearRenderTexture() {
              console.log('_clearRenderTexture')
              const ctx = this._getContext();
              let clearColor = [0, 0, 0, 0];
              if (this._mainRenderTexture.ctx === ctx) {
                  clearColor = this.ctx.stage.getClearColor();
              }
              const renderTexture = ctx.canvas;
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              console.log('clear color', clearColor)
              if (!clearColor[0] && !clearColor[1] && !clearColor[2] && !clearColor[3]) {
                  ctx.clearRect(0, 0, renderTexture.width, renderTexture.height);
              } else {
                  ctx.fillStyle = StageUtils.getRgbaStringFromArray(clearColor);
                  ctx.globalCompositeOperation = 'copy';
                  ctx.beginPath();
                  ctx.rect(0, 0, renderTexture.width, renderTexture.height);
                  ctx.closePath();
                  ctx.fill();
                  ctx.globalCompositeOperation = 'source-over';
              }
          }
          _getContext() {
              console.log('_getContext')
              if (this._renderTexture) {
                  return this._renderTexture.ctx;
              } else {
                  return this._mainRenderTexture.ctx;
              }
          }
          _restoreContext() {
              console.log('_restoreContext')
              const ctx = this._getContext();
              ctx.restore();
              ctx.save();
              ctx._scissor = null;
          }
          _setScissor(area) {
              const ctx = this._getContext();
              if (!C2dCoreRenderExecutor._equalScissorAreas(ctx.canvas, ctx._scissor, area)) {
                  this._restoreContext();
                  let precision = this.ctx.stage.getRenderPrecision();
                  if (area) {
                      ctx.beginPath();
                      ctx.rect(Math.round(area[0] * precision), Math.round(area[1] * precision), Math.round(area[2] * precision), Math.round(area[3] * precision));
                      ctx.closePath();
                      ctx.clip();
                  }
                  ctx._scissor = area;
              }
          }
          static _equalScissorAreas(canvas, area, current) {
              if (!area) {
                  area = [0, 0, canvas.width, canvas.height];
              }
              if (!current) {
                  current = [0, 0, canvas.width, canvas.height];
              }
              return Utils.equalValues(area, current)
          }
      }

      class C2dShader extends Shader {
          beforeDraw(operation) {
          }
          draw(operation) {
          }
          afterDraw(operation) {
          }
      }

      class DefaultShader$1 extends C2dShader {
          constructor(ctx) {
              super(ctx);
              this._rectangleTexture = ctx.stage.rectangleTexture.source.nativeTexture;
              this._tintManager = this.ctx.stage.renderer.tintManager;
          }
          draw(operation, target) {
              console.log('DefaultShader.draw')
              const ctx = target.ctx;
              let length = operation.length;
              for (let i = 0; i < length; i++) {
                  const tx = operation.getTexture(i);
                  const vc = operation.getElementCore(i);
                  const rc = operation.getRenderContext(i);
                  const white = operation.getWhite(i);
                  const stc = operation.getSimpleTc(i);
                  const precision = this.ctx.stage.getRenderPrecision();
                  ctx.setTransform(rc.ta * precision, rc.tc * precision, rc.tb * precision, rc.td * precision, rc.px * precision, rc.py * precision);
                  const rect = (tx === this._rectangleTexture);
                  const info = {operation, target, index: i, rect};
                  if (rect) {
                      if (white) {
                          ctx.fillStyle = 'white';
                      } else {
                          this._setColorGradient(ctx, vc);
                      }
                      ctx.globalAlpha = rc.alpha;
                      this._beforeDrawEl(info);
                      ctx.fillRect(0, 0, vc.w, vc.h);
                      this._afterDrawEl(info);
                      ctx.globalAlpha = 1.0;
                  } else {
                      ctx.globalAlpha = rc.alpha;
                      this._beforeDrawEl(info);
                      const sourceX = stc ? 0 : (vc._ulx * tx.w);
                      const sourceY = stc ? 0 : (vc._uly * tx.h);
                      const sourceW = (stc ? 1 : (vc._brx - vc._ulx)) * tx.w;
                      const sourceH = (stc ? 1 : (vc._bry - vc._uly)) * tx.h;
                      let colorize = !white;
                      if (colorize) {
                          let color = vc._colorUl;
                          if (vc._colorUl !== vc._colorUr || vc._colorUr !== vc._colorBl || vc._colorBr !== vc._colorBl) {
                              color = StageUtils.mergeMultiColorsEqual([vc._colorUl, vc._colorUr, vc._colorBl, vc._colorBr]);
                          }
                          const alpha = ((color / 16777216) | 0) / 255.0;
                          ctx.globalAlpha *= alpha;
                          const rgb = color & 0x00FFFFFF;
                          const tintTexture = this._tintManager.getTintTexture(tx, rgb);
                          ctx.fillStyle = 'white';
                          ctx.drawImage(tintTexture, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                      } else {
                          ctx.fillStyle = 'white';
                          ctx.drawImage(tx, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                      }
                      this._afterDrawEl(info);
                      ctx.globalAlpha = 1.0;
                  }
              }
          }
          _setColorGradient(ctx, vc, w = vc.w, h = vc.h, transparency = true) {
              console.log('DefaultShader._setColorGradient')
              let color = vc._colorUl;
              let gradient;
              if (vc._colorUl === vc._colorUr) {
                  if (vc._colorBl === vc._colorBr) {
                      if (vc._colorUl === vc.colorBl) ; else {
                          gradient = ctx.createLinearGradient(0, 0, 0, h);
                          if (transparency) {
                              gradient.addColorStop(0, StageUtils.getRgbaString(vc._colorUl));
                              gradient.addColorStop(1, StageUtils.getRgbaString(vc._colorBl));
                          } else {
                              gradient.addColorStop(0, StageUtils.getRgbString(vc._colorUl));
                              gradient.addColorStop(1, StageUtils.getRgbString(vc._colorBl));
                          }
                      }
                  }
              } else {
                  if (vc._colorUl === vc._colorBl && vc._colorUr === vc._colorBr) {
                      gradient = ctx.createLinearGradient(0, 0, w, 0);
                      if (transparency) {
                          gradient.addColorStop(0, StageUtils.getRgbaString(vc._colorUl));
                          gradient.addColorStop(1, StageUtils.getRgbaString(vc._colorBr));
                      } else {
                          gradient.addColorStop(0, StageUtils.getRgbString(vc._colorUl));
                          gradient.addColorStop(1, StageUtils.getRgbString(vc._colorBr));
                      }
                  }
              }
              if (gradient) {
                  ctx.fillStyle = gradient;
              } else {
                  ctx.fillStyle = transparency ? StageUtils.getRgbaString(color) : StageUtils.getRgbString(color);
              }
          }
          _beforeDrawEl(info) {
          }
          _afterDrawEl(info) {
          }
      }

      class C2dTextureTintManager {
          constructor(stage) {
              this.stage = stage;
              this._usedMemory = 0;
              this._cachedNativeTextures = new Set();
          }
          destroy() {
              this.gc(true);
          }
          _addMemoryUsage(delta) {
              this._usedMemory += delta;
              this.stage.addMemoryUsage(delta);
          }
          delete(nativeTexture) {
              if (this._hasCache(nativeTexture)) {
                  const cache = this._getCache(nativeTexture);
                  const prevMemUsage = cache.memoryUsage;
                  cache.clear();
                  this._cachedNativeTextures.delete(nativeTexture);
                  this._addMemoryUsage(cache.memoryUsage - prevMemUsage);
              }
          }
          getTintTexture(nativeTexture, color) {
              console.log('getTintTexture')
              const frame = this.stage.frameCounter;
              this._cachedNativeTextures.add(nativeTexture);
              const cache = this._getCache(nativeTexture);
              const item = cache.get(color);
              item.lf = frame;
              if (item.tx) {
                  if (nativeTexture.update > item.u) {
                      this._tintTexture(item.tx, nativeTexture, color);
                  }
                  return item.tx;
              } else {
                  const before = cache.memoryUsage;
                  let target = cache.reuseTexture(frame);
                  if (target) {
                      target.ctx.clearRect(0, 0, target.width, target.height);
                  } else {
                      target = document.createElement('canvas');
                      target.width = nativeTexture.w;
                      target.height = nativeTexture.h;
                      target.ctx = target.getContext('2d');
                  }
                  this._tintTexture(target, nativeTexture, color);
                  cache.set(color, target, frame);
                  const after = cache.memoryUsage;
                  if (after !== before) {
                      this._addMemoryUsage(after - before);
                  }
                  return target;
              }
          }
          _tintTexture(target, source, color) {
              let col = color.toString(16);
              while (col.length < 6) {
                  col = "0" + col;
              }
              target.ctx.fillStyle = '#' + col;
              target.ctx.globalCompositeOperation = 'copy';
              target.ctx.fillRect(0, 0, source.w, source.h);
              target.ctx.globalCompositeOperation = 'multiply';
              target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
              target.ctx.globalCompositeOperation = 'destination-in';
              target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
          }
          _hasCache(nativeTexture) {
              return !!nativeTexture._tintCache;
          }
          _getCache(nativeTexture) {
              if (!nativeTexture._tintCache) {
                  nativeTexture._tintCache = new C2dTintCache(nativeTexture);
              }
              return nativeTexture._tintCache;
          }
          gc(aggressive = false) {
              const frame = this.stage.frameCounter;
              let delta = 0;
              this._cachedNativeTextures.forEach(texture => {
                  const cache = this._getCache(texture);
                  if (aggressive) {
                      delta += cache.memoryUsage;
                      cache.clear();
                  } else {
                      const before = cache.memoryUsage;
                      cache.cleanup(frame);
                      cache.releaseBlancoTextures();
                      delta += (cache.memoryUsage - before);
                  }
              });
              if (aggressive) {
                  this._cachedNativeTextures.clear();
              }
              if (delta) {
                  this._addMemoryUsage(delta);
              }
          }
      }
      class C2dTintCache {
          constructor(nativeTexture) {
              this._tx = nativeTexture;
              this._colors = new Map();
              this._blancoTextures = null;
              this._lastCleanupFrame = 0;
              this._memTextures = 0;
          }
          get memoryUsage() {
              return this._memTextures * this._tx.w * this._tx.h;
          }
          releaseBlancoTextures() {
              this._memTextures -= this._blancoTextures.length;
              this._blancoTextures = [];
          }
          clear() {
              this._blancoTextures = null;
              this._colors.clear();
              this._memTextures = 0;
          }
          get(color) {
              let item = this._colors.get(color);
              if (!item) {
                  item = {lf: -1, tx: undefined, u: -1};
                  this._colors.set(color, item);
              }
              return item;
          }
          set(color, texture, frame) {
              const item = this.get(color);
              item.lf = frame;
              item.tx = texture;
              item.u = frame;
              this._memTextures++;
          }
          cleanup(frame) {
              if (this._lastCleanupFrame !== frame) {
                  this._blancoTextures = [];
                  this._colors.forEach((item, color) => {
                      if (item.lf < frame - 1) {
                          if (item.tx) {
                              this._blancoTextures.push(item.tx);
                          }
                          this._colors.delete(color);
                      }
                  });
                  this._lastCleanupFrame = frame;
              }
          }
          reuseTexture(frame) {
              this.cleanup(frame);
              if (this._blancoTextures && this._blancoTextures.length) {
                  this._memTextures--;
                  return this._blancoTextures.pop();
              }
          }
      }

      class C2dRenderer extends Renderer {
          constructor(stage) {
              super(stage);
              this.tintManager = new C2dTextureTintManager(stage);
              this.setupC2d(this.stage.c2d.canvas);
          }
          destroy() {
              this.tintManager.destroy();
          }
          _createDefaultShader(ctx) {
              return new DefaultShader$1(ctx);
          }
          _getShaderBaseType() {
              return C2dShader
          }
          _getShaderAlternative(shaderType) {
              return shaderType.getC2d && shaderType.getC2d();
          }
          createCoreQuadList(ctx) {
              return new C2dCoreQuadList(ctx);
          }
          createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
              return new C2dCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
          }
          createCoreRenderExecutor(ctx) {
              return new C2dCoreRenderExecutor(ctx);
          }
          createCoreRenderState(ctx) {
              return new CoreRenderState(ctx);
          }
          createRenderTexture(w, h, pw, ph) {
              console.log('createRenderTexture')
              const canvas = document.createElement('canvas');
              canvas.width = pw;
              canvas.height = ph;
              this.setupC2d(canvas);
              return canvas;
          }
          freeRenderTexture(nativeTexture) {
              this.tintManager.delete(nativeTexture);
          }
          gc(aggressive) {
              this.tintManager.gc(aggressive);
          }
          uploadTextureSource(textureSource, options) {
              console.log('uploadTextureSource')
              if (options.source.buffer) {
                  const canvas = document.createElement('canvas');
                  canvas.width = options.w;
                  canvas.height = options.h;
                  const imageData = new ImageData(new Uint8ClampedArray(options.source.buffer), options.w, options.h);
                  canvas.getContext('2d').putImageData(imageData, 0, 0);
                  return canvas;
              }
              return options.source;
          }
          freeTextureSource(textureSource) {
              this.tintManager.delete(textureSource.nativeTexture);
          }
          addQuad(renderState, quads, index) {
              console.log('addQuad')
              const elementCore = quads.quadElements[index];
              quads.setRenderContext(index, elementCore._renderContext);
              quads.setWhite(index, elementCore.isWhite());
              quads.setSimpleTc(index, elementCore.hasSimpleTexCoords());
          }
          isRenderTextureReusable(renderState, renderTextureInfo) {
              return false;
          }
          finishRenderState(renderState) {
          }
          setupC2d(canvas) {
              const ctx = canvas.getContext('2d');
              canvas.ctx = ctx;
              ctx._scissor = null;
              canvas.ctx.save();
          }
      }

      class SparkShader extends WebGLShader {
          enableAttribs() {
              let gl = this.gl;
              gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
              gl.enableVertexAttribArray(this._attrib("aVertexPosition"));
              if (this._attrib("aTextureCoord") !== -1) {
                  gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
                  gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
              }
              if (this._attrib("aColor") !== -1) {
                  gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
                  gl.enableVertexAttribArray(this._attrib("aColor"));
              }
          }
          disableAttribs() {
              let gl = this.gl;
              gl.disableVertexAttribArray(this._attrib("aVertexPosition"));
              if (this._attrib("aTextureCoord") !== -1) {
                  gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
              }
              if (this._attrib("aColor") !== -1) {
                  gl.disableVertexAttribArray(this._attrib("aColor"));
              }
          }
          setupUniforms(operation) {
              this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
          }
          draw(operation) {
              let gl = this.gl;
              let length = operation.length;
              if (length) {
                  let glTexture = operation.getTexture(0);
                  let pos = 0;
                  for (let i = 0; i < length; i++) {
                      let tx = operation.getTexture(i);
                      if (glTexture !== tx) {
                          if (glTexture.options && glTexture.options.imageRef) {
                              let elementPostion = (i > 0) ? (i - 1) : i;
                              const precision = this.ctx.stage.getOption('precision');
                              let vc = operation.getElementCore(elementPostion);
                              this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px*precision, vc._worldContext.py*precision, vc._colorUl, vc);
                          } else {
                              gl.bindTexture(gl.TEXTURE_2D, glTexture);
                              gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                          }
                          glTexture = tx;
                          pos = i;
                      }
                  }
                  if (pos < length) {
                      if (glTexture.options && glTexture.options.imageRef) {
                          const precision = this.ctx.stage.getOption('precision');
                          let vc = operation.getElementCore(pos);
                          this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px*precision, vc._worldContext.py*precision, vc._colorUl, vc);
                      } else {
                          gl.bindTexture(gl.TEXTURE_2D, glTexture);
                          gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                      }
                  }
              }
          }
      }
      SparkShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      SparkShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;

      class SparkRenderer extends WebGLRenderer {
          constructor(stage) {
              super(stage);
          }
          _createDefaultShader(ctx) {
              return new SparkShader(ctx);
          }
          createCoreRenderExecutor(ctx) {
              commonjsGlobal.beginDrawing();
              let ret = super.createCoreRenderExecutor(ctx);
              commonjsGlobal.endDrawing();
              return ret;
          }
      }

      class ImageWorker {
          constructor(options = {}) {
              this._items = new Map();
              this._id = 0;
              this._initWorker();
          }
          destroy() {
              if (this._worker) {
                  this._worker.terminate();
              }
          }
          _initWorker() {
              const code = `(${createWorker.toString()})()`;
              const blob = new Blob([code.replace('"use strict";', '')]);
              const blobURL = (window.URL ? URL : webkitURL).createObjectURL(blob, {
                  type: 'application/javascript; charset=utf-8'
              });
              this._worker = new Worker(blobURL);
              this._worker.postMessage({type: 'config', config: {path: window.location.href, protocol: window.location.protocol}});
              this._worker.onmessage = (e) => {
                  if (e.data && e.data.id) {
                      const id = e.data.id;
                      const item = this._items.get(id);
                      if (item) {
                          if (e.data.type == 'data') {
                              this.finish(item, e.data.info);
                          } else {
                              this.error(item, e.data.info);
                          }
                      }
                  }
              };
          }
          create(src) {
              const id = ++this._id;
              const item = new ImageWorkerImage(this, id, src);
              this._items.set(id, item);
              this._worker.postMessage({type: "add", id: id, src: src});
              return item;
          }
          cancel(image) {
              this._worker.postMessage({type: "cancel", id: image.id});
              this._items.delete(image.id);
          }
          error(image, info) {
              image.error(info);
              this._items.delete(image.id);
          }
          finish(image, info) {
              image.load(info);
              this._items.delete(image.id);
          }
      }
      class ImageWorkerImage {
          constructor(manager, id, src) {
              this._manager = manager;
              this._id = id;
              this._src = src;
              this._onError = null;
              this._onLoad = null;
          }
          get id() {
              return this._id;
          }
          get src() {
              return this._src;
          }
          set onError(f) {
              this._onError = f;
          }
          set onLoad(f) {
              this._onLoad = f;
          }
          cancel() {
              this._manager.cancel(this);
          }
          load(info) {
              if (this._onLoad) {
                  this._onLoad(info);
              }
          }
          error(info) {
              if (this._onError) {
                  this._onError(info);
              }
          }
      }
      const createWorker = function() {
          function ImageWorkerServer() {
              this.items = new Map();
              var t = this;
              onmessage = function(e) {
                  t._receiveMessage(e);
              };
          }
          ImageWorkerServer.isPathAbsolute = function(path) {
              return /^(?:\/|[a-z]+:\/\/)/.test(path) || path.substr(0, 5) == 'data:';
          };
          ImageWorkerServer.prototype._receiveMessage = function(e) {
              if (e.data.type === 'config') {
                  this.config = e.data.config;
                  var base = this.config.path;
                  var hasHashPath = /#.*?\//;
                  if(hasHashPath.test(base)){
                      base = base.replace(/#.*$/,'');
                  }
                  var parts = base.split("/");
                  parts.pop();
                  this._relativeBase = parts.join("/") + "/";
              } else if (e.data.type === 'add') {
                  this.add(e.data.id, e.data.src);
              } else if (e.data.type === 'cancel') {
                  this.cancel(e.data.id);
              }
          };
          ImageWorkerServer.prototype.add = function(id, src) {
              if (!ImageWorkerServer.isPathAbsolute(src)) {
                  src = this._relativeBase + src;
              }
              if (src.substr(0,2) === "//") {
                  src = this.config.protocol + src;
              }
              var item = new ImageWorkerServerItem(id, src);
              var t = this;
              item.onFinish = function(result) {
                  t.finish(item, result);
              };
              item.onError = function(info) {
                  t.error(item, info);
              };
              this.items.set(id, item);
              item.start();
          };
          ImageWorkerServer.prototype.cancel = function(id) {
              var item = this.items.get(id);
              if (item) {
                  item.cancel();
                  this.items.delete(id);
              }
          };
          ImageWorkerServer.prototype.finish = function(item, {imageBitmap, hasAlphaChannel}) {
              postMessage({
                  type: "data",
                  id: item.id,
                  info: {
                      imageBitmap,
                      hasAlphaChannel
                  }
              }, [imageBitmap]);
              this.items.delete(item.id);
          };
          ImageWorkerServer.prototype.error = function(item, {type, message}) {
              postMessage({
                  type: "error",
                  id: item.id,
                  info: {
                      type,
                      message
                  }
              });
              this.items.delete(item.id);
          };
          ImageWorkerServer.isWPEBrowser = function() {
              return (navigator.userAgent.indexOf("WPE") !== -1);
          };
          function ImageWorkerServerItem(id, src) {
              this._onError = undefined;
              this._onFinish = undefined;
              this._id = id;
              this._src = src;
              this._xhr = undefined;
              this._mimeType = undefined;
              this._canceled = false;
          }
          Object.defineProperty(ImageWorkerServerItem.prototype, 'id', {
              get: function() {
                  return this._id;
              }
          });
          Object.defineProperty(ImageWorkerServerItem.prototype, 'onFinish', {
              get: function() {
                  return this._onFinish;
              },
              set: function(f) {
                  this._onFinish = f;
              }
          });
          Object.defineProperty(ImageWorkerServerItem.prototype, 'onError', {
              get: function() {
                  return this._onError;
              },
              set: function(f) {
                  this._onError = f;
              }
          });
          ImageWorkerServerItem.prototype.start = function() {
              this._xhr = new XMLHttpRequest();
              this._xhr.open("GET", this._src, true);
              this._xhr.responseType = "blob";
              var t = this;
              this._xhr.onerror = function(oEvent) {
                  t.error({type: "connection", message: "Connection error"});
              };
              this._xhr.onload = function(oEvent) {
                  var blob = t._xhr.response;
                  t._mimeType = blob.type;
                  t._createImageBitmap(blob);
              };
              this._xhr.send();
          };
          ImageWorkerServerItem.prototype._createImageBitmap = function(blob) {
              var t = this;
              createImageBitmap(blob, {premultiplyAlpha: 'premultiply', colorSpaceConversion: 'none', imageOrientation: 'none'}).then(function(imageBitmap) {
                  t.finish({
                      imageBitmap,
                      hasAlphaChannel: t._hasAlphaChannel()
                  });
              }).catch(function(e) {
                  t.error({type: "parse", message: "Error parsing image data"});
              });
          };
          ImageWorkerServerItem.prototype._hasAlphaChannel = function() {
              if (ImageWorkerServer.isWPEBrowser()) {
                  return true;
              } else {
                  return (this._mimeType.indexOf("image/png") !== -1);
              }
          };
          ImageWorkerServerItem.prototype.cancel = function() {
              if (this._canceled) return;
              if (this._xhr) {
                  this._xhr.abort();
              }
              this._canceled = true;
          };
          ImageWorkerServerItem.prototype.error = function(type, message) {
              if (!this._canceled && this._onError) {
                  this._onError({type, message});
              }
          };
          ImageWorkerServerItem.prototype.finish = function(info) {
              if (!this._canceled && this._onFinish) {
                  this._onFinish(info);
              }
          };
          new ImageWorkerServer();
      };

      class WebPlatform {
          init(stage) {
              this.stage = stage;
              this._looping = false;
              this._awaitingLoop = false;
              if (this.stage.getOption("useImageWorker")) {
                  if (!window.createImageBitmap || !window.Worker) {
                      console.warn("[Lightning] Can't use image worker because browser does not have createImageBitmap and Web Worker support");
                  } else {
                      this._imageWorker = new ImageWorker();
                  }
              }
          }
          destroy() {
              if (this._imageWorker) {
                  this._imageWorker.destroy();
              }
              this._removeKeyHandler();
          }
          startLoop() {
              this._looping = true;
              if (!this._awaitingLoop) {
                  this.loop();
              }
          }
          stopLoop() {
              this._looping = false;
          }
          loop() {
              let self = this;
              let lp = function() {
                  self._awaitingLoop = false;
                  if (self._looping) {
                      self.stage.drawFrame();
                      requestAnimationFrame(lp);
                      self._awaitingLoop = true;
                  }
              };
              requestAnimationFrame(lp);
          }
          uploadGlTexture(gl, textureSource, source, options) {
              if (source instanceof ImageData || source instanceof HTMLImageElement || source instanceof HTMLCanvasElement || source instanceof HTMLVideoElement || (window.ImageBitmap && source instanceof ImageBitmap)) {
                  gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
              } else {
                  gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, textureSource.w, textureSource.h, 0, options.format, options.type, source);
              }
          }
          loadSrcTexture({src, hasAlpha}, cb) {
              console.log('loadSrcTex', src)
              let cancelCb = undefined;
              let isPng = (src.indexOf(".png") >= 0) || src.substr(0, 21) == 'data:image/png;base64';
              if (this._imageWorker) {
                  const image = this._imageWorker.create(src);
                  image.onError = function(err) {
                      return cb("Image load error");
                  };
                  image.onLoad = function({imageBitmap, hasAlphaChannel}) {
                      cb(null, {
                          source: imageBitmap,
                          renderInfo: {src: src},
                          hasAlpha: hasAlphaChannel,
                          premultiplyAlpha: true
                      });
                  };
                  cancelCb = function() {
                      image.cancel();
                  };
              } else {
                  console.log('load Image')
                  let image = new Image();
                  if (!(src.substr(0,5) == "data:") && !Utils.isPS4) {
                      image.crossOrigin = "Anonymous";
                  }
                  image.onerror = function(err) {
                      if (image.src) {
                          return cb("Image load error");
                      }
                  };
                  image.onload = function() {
                      cb(null, {
                          source: image,
                          renderInfo: {src: src},
                          hasAlpha: isPng || hasAlpha
                      });
                  };
                  image.src = src;
                  cancelCb = function() {
                      image.onerror = null;
                      image.onload = null;
                      image.removeAttribute('src');
                  };
              }
              return cancelCb;
          }
          createWebGLContext(w, h) {
              let canvas = this.stage.getOption('canvas') || document.createElement('canvas');
              if (w && h) {
                  canvas.width = w;
                  canvas.height = h;
              }
              let opts = {
                  alpha: true,
                  antialias: false,
                  premultipliedAlpha: true,
                  stencil: true,
                  preserveDrawingBuffer: false
              };
              let gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);
              if (!gl) {
                  throw new Error('This browser does not support webGL.');
              }
              return gl;
          }
          createCanvasContext(w, h) {
              let canvas = this.stage.getOption('canvas') || document.createElement('canvas');
              if (w && h) {
                  canvas.width = w;
                  canvas.height = h;
              }
              let c2d = canvas.getContext('2d');
              if (!c2d) {
                  throw new Error('This browser does not support 2d canvas.');
              }
              return c2d;
          }
          getHrTime() {
              return window.performance ? window.performance.now() : (new Date()).getTime();
          }
          getDrawingCanvas() {
              return document.createElement('canvas');
          }
          getTextureOptionsForDrawingCanvas(canvas) {
              let options = {};
              options.source = canvas;
              return options;
          }
          nextFrame(changes) {
          }
          registerKeydownHandler(keyhandler) {
              this._keydownListener = (e) => {
                  keyhandler(e);
              };
              window.addEventListener('keydown', this._keydownListener);
          }
          registerKeyupHandler(keyhandler) {
              this._keyupListener = (e) => {
                  keyhandler(e);
              };
              window.addEventListener('keyup', this._keyupListener);
          }
          _removeKeyHandler() {
              if (this._keydownListener) {
                  window.removeEventListener('keydown', this._keydownListener);
              }
              if (this._keyupListener) {
                  window.removeEventListener('keyup', this._keyupListener);
              }
          }
      }

      class PlatformLoader {
          static load(options) {
              if (options.platform) {
                  return options.platform;
              } else {
                  return WebPlatform;
              }
          }
      }

      class Utils$1 {
          static isFunction(value) {
              return typeof value === 'function';
          }
          static isNumber(value) {
              return typeof value === 'number';
          }
          static isInteger(value) {
              return (typeof value === 'number' && (value % 1) === 0);
          }
          static isBoolean(value) {
              return value === true || value === false;
          }
          static isString(value) {
              return typeof value == 'string';
          }
          static isObject(value) {
              let type = typeof value;
              return !!value && (type == 'object' || type == 'function');
          }
          static isPlainObject(value) {
              let type = typeof value;
              return !!value && (type == 'object');
          }
          static isObjectLiteral(value){
              return typeof value === 'object' && value && value.constructor === Object
          }
          static getArrayIndex(index, arr) {
              return Utils$1.getModuloIndex(index, arr.length);
          }
          static equalValues(v1, v2) {
              if ((typeof v1) !== (typeof v2)) return false
              if (Utils$1.isObjectLiteral(v1)) {
                  return Utils$1.isObjectLiteral(v2) && Utils$1.equalObjectLiterals(v1, v2)
              } else if (Array.isArray(v1)) {
                  return Array.isArray(v2) && Utils$1.equalArrays(v1, v2)
              } else {
                  return v1 === v2
              }
          }
          static equalObjectLiterals(obj1, obj2) {
              let keys1 = Object.keys(obj1);
              let keys2 = Object.keys(obj2);
              if (keys1.length !== keys2.length) {
                  return false
              }
              for (let i = 0, n = keys1.length; i < n; i++) {
                  const k1 = keys1[i];
                  const k2 = keys2[i];
                  if (k1 !== k2) {
                      return false
                  }
                  const v1 = obj1[k1];
                  const v2 = obj2[k2];
                  if (!Utils$1.equalValues(v1, v2)) {
                      return false
                  }
              }
              return true;
          }
          static equalArrays(v1, v2) {
              if (v1.length !== v2.length) {
                  return false
              }
              for (let i = 0, n = v1.length; i < n; i++) {
                  if (!this.equalValues(v1[i], v2[i])) {
                      return false
                  }
              }
              return true
          }
      }
      class WebGLState {
          constructor(id, gl) {
              this._id = id;
              this._gl = gl;
              this._program = undefined;
              this._buffers = new Map();
              this._framebuffers = new Map();
              this._renderbuffers = new Map();
              this._vertexAttribs = new Array(16);
              this._nonDefaultFlags = new Set();
              this._settings = new Map();
              this._textures = new Array(8);
              this._maxTexture = 0;
              this._activeTexture = gl.TEXTURE0;
              this._pixelStorei = new Array(5);
          }
          _getDefaultFlag(cap) {
              return (cap === this._gl.DITHER);
          }
          setFlag(cap, v) {
              const def = this._getDefaultFlag(cap);
              if (v === def) {
                  return this._nonDefaultFlags.delete(cap);
              } else {
                  if (!this._nonDefaultFlags.has(cap)) {
                      this._nonDefaultFlags.add(cap);
                      return true;
                  } else {
                      return false;
                  }
              }
          }
          setBuffer(target, buffer) {
              const change = this._buffers.get(target) !== buffer;
              this._buffers.set(target, buffer);
              if (change && (target === this._gl.ARRAY_BUFFER)) {
                  this._vertexAttribs = [];
              }
              return change;
          }
          setFramebuffer(target, buffer) {
              const change = this._framebuffers.get(target) !== buffer;
              this._framebuffers.set(target, buffer);
              return change;
          }
          setRenderbuffer(target, buffer) {
              const change = this._renderbuffers.get(target) !== buffer;
              this._renderbuffers.set(target, buffer);
              return change;
          }
          setProgram(program) {
              const change = this._program !== program;
              this._program = program;
              return change
          }
          setSetting(func, v) {
              const s = this._settings.get(func);
              const change = !s || !Utils$1.equalValues(s, v);
              this._settings.set(func, v);
              return change
          }
          disableVertexAttribArray(index) {
              const va = this._vertexAttribs[index];
              if (va && va[5]) {
                  va[5] = false;
                  return true;
              }
              return false;
          }
          enableVertexAttribArray(index) {
              const va = this._vertexAttribs[index];
              if (va) {
                  if (!va[0]) {
                      va[0] = true;
                      return true;
                  }
              } else {
                  this._vertexAttribs[index] = [0, 0, 0, 0, 0, true];
                  return true;
              }
              return false;
          }
          vertexAttribPointer(index, props) {
              let va = this._vertexAttribs[index];
              let equal = false;
              if (va) {
                  equal = va[0] === props[0] &&
                      va[1] === props[1] &&
                      va[2] === props[2] &&
                      va[3] === props[3] &&
                      va[4] === props[4];
              }
              if (equal) {
                  return false;
              } else {
                  props[5] = va ? va[5] : false;
                  return true;
              }
          }
          setActiveTexture(texture) {
              const changed = this._activeTexture !== texture;
              this._activeTexture = texture;
              return changed;
          }
          bindTexture(target, texture) {
              const activeIndex = WebGLState._getTextureIndex(this._activeTexture);
              this._maxTexture = Math.max(this._maxTexture, activeIndex + 1);
              const current = this._textures[activeIndex];
              const targetIndex = WebGLState._getTextureTargetIndex(target);
              if (current) {
                  if (current[targetIndex] === texture) {
                      return false;
                  }
                  current[targetIndex] = texture;
                  return true;
              } else {
                  if (texture) {
                      this._textures[activeIndex] = [];
                      this._textures[activeIndex][targetIndex] = texture;
                      return true
                  } else {
                      return false
                  }
              }
          }
          setPixelStorei(pname, param) {
              const i = WebGLState._getPixelStoreiIndex(pname);
              const change = !Utils$1.equalValues(this._pixelStorei[i], param);
              this._pixelStorei[i] = param;
              return change;
          }
          migrate(s) {
              const t = this;
              this._migrateFlags(t, s);
              if (s._program !== t._program) {
                  this._gl._useProgram(s._program);
              }
              this._migrateFramebuffers(t, s);
              this._migrateRenderbuffers(t, s);
              const buffersChanged = this._migrateBuffers(t, s);
              this._migrateAttributes(t, s, buffersChanged);
              this._migrateFlags(t, s);
              this._migrateSettings(t, s);
              this._migratePixelStorei(t, s);
              this._migrateTextures(t, s);
          }
          _migratePixelStorei(t, s) {
              for (let i = 0, n = t._pixelStorei.length; i < n; i++) {
                  if (t._pixelStorei[i] !== s._pixelStorei[i]) {
                      const value = s._pixelStorei[i] !== undefined ? s._pixelStorei[i] : WebGLState._getDefaultPixelStoreiByIndex(i);
                      this._gl._pixelStorei(WebGLState._getPixelStoreiByIndex(i), value);
                  }
              }
          }
          _migrateTextures(t, s) {
              const max = Math.max(t._maxTexture, s._maxTexture);
              let activeTexture = t._activeTexture;
              for (let i = 0; i < max; i++) {
                  const sTargets = s._textures[i];
                  const tTargets = t._textures[i];
                  const textureNumb = WebGLState._getTextureByIndex(i);
                  const targetMax = Math.max(tTargets ? tTargets.length : 0, sTargets ? sTargets.length : 0);
                  for (let j = 0, n = targetMax; j < n; j++) {
                      const target = WebGLState._getTextureTargetByIndex(j);
                      if (activeTexture !== textureNumb) {
                          this._gl._activeTexture(textureNumb);
                          activeTexture = textureNumb;
                      }
                      const texture = (sTargets && sTargets[j]) || null;
                      this._gl._bindTexture(target, texture);
                  }
              }
              if (s._activeTexture !== activeTexture) {
                  this._gl._activeTexture(s._activeTexture);
              }
          }
          _migrateBuffers(t, s) {
              s._buffers.forEach((framebuffer, target) => {
                  if (t._buffers.get(target) !== framebuffer) {
                      this._gl._bindBuffer(target, framebuffer);
                  }
              });
              t._buffers.forEach((buffer, target) => {
                  const b = s._buffers.get(target);
                  if (b === undefined) {
                      this._gl._bindBuffer(target, null);
                  }
              });
              return (s._buffers.get(this._gl.ARRAY_BUFFER) !== t._buffers.get(this._gl.ARRAY_BUFFER))
          }
          _migrateFramebuffers(t, s) {
              s._framebuffers.forEach((framebuffer, target) => {
                  if (t._framebuffers.get(target) !== framebuffer) {
                      this._gl._bindFramebuffer(target, framebuffer);
                  }
              });
              t._framebuffers.forEach((framebuffer, target) => {
                  const fb = s._framebuffers.get(target);
                  if (fb === undefined) {
                      this._gl._bindFramebuffer(target, null);
                  }
              });
          }
          _migrateRenderbuffers(t, s) {
              s._renderbuffers.forEach((renderbuffer, target) => {
                  if (t._renderbuffers.get(target) !== renderbuffer) {
                      this._gl._bindRenderbuffer(target, renderbuffer);
                  }
              });
              t._renderbuffers.forEach((renderbuffer, target) => {
                  const fb = s._renderbuffers.get(target);
                  if (fb === undefined) {
                      this._gl._bindRenderbuffer(target, null);
                  }
              });
          }
          _migrateAttributes(t, s, buffersChanged) {
              if (!buffersChanged) {
                  t._vertexAttribs.forEach((attrib, index) => {
                      if (!s._vertexAttribs[index]) {
                          this._gl._disableVertexAttribArray(index);
                      }
                  });
                  s._vertexAttribs.forEach((attrib, index) => {
                      this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[4]);
                      if (attrib[5]) {
                          this._gl._enableVertexAttribArray(index);
                      } else {
                          this._gl._disableVertexAttribArray(index);
                      }
                  });
              } else {
                  s._vertexAttribs.forEach((attrib, index) => {
                      if (attrib[0]) {
                          this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[3], attrib[4]);
                      }
                      if (attrib[5]) {
                          this._gl._enableVertexAttribArray(index);
                      }
                  });
              }
          }
          _migrateSettings(t, s) {
              const defaults = this.constructor.getDefaultSettings();
              t._settings.forEach((value, func) => {
                  const name = func.name || func.xname;
                  if (!s._settings.has(func)) {
                      let args = defaults.get(name);
                      if (Utils$1.isFunction(args)) {
                          args = args(this._gl);
                      }
                      s._settings.set(func, args);
                      func.apply(this._gl, args);
                  }
              });
              s._settings.forEach((value, func) => {
                  const tValue = t._settings.get(func);
                  if (!tValue || !Utils$1.equalValues(tValue, value)) {
                      func.apply(this._gl, value);
                  }
              });
          }
          _migrateFlags(t, s) {
              t._nonDefaultFlags.forEach(setting => {
                  if (!s._nonDefaultFlags.has(setting)) {
                      if (this._getDefaultFlag(setting)) {
                          this._gl._enable(setting);
                      } else {
                          this._gl._disable(setting);
                      }
                  }
              });
              s._nonDefaultFlags.forEach(setting => {
                  if (!t._nonDefaultFlags.has(setting)) {
                      if (this._getDefaultFlag(setting)) {
                          this._gl._disable(setting);
                      } else {
                          this._gl._enable(setting);
                      }
                  }
              });
          }
          static getDefaultSettings() {
              if (!this._defaultSettings) {
                  this._defaultSettings = new Map();
                  const d = this._defaultSettings;
                  const g = WebGLRenderingContext.prototype;
                  d.set("viewport", function(gl) {return [0,0,gl.canvas.width, gl.canvas.height]});
                  d.set("scissor", function(gl) {return [0,0,gl.canvas.width, gl.canvas.height]});
                  d.set("blendColor", [0, 0, 0, 0]);
                  d.set("blendEquation", [g.FUNC_ADD]);
                  d.set("blendEquationSeparate", [g.FUNC_ADD, g.FUNC_ADD]);
                  d.set("blendFunc", [g.ONE, g.ZERO]);
                  d.set("blendFuncSeparate", [g.ONE, g.ZERO, g.ONE, g.ZERO]);
                  d.set("clearColor", [0, 0, 0, 0]);
                  d.set("clearDepth", [1]);
                  d.set("clearStencil", [0]);
                  d.set("colorMask", [true, true, true, true]);
                  d.set("cullFace", [g.BACK]);
                  d.set("depthFunc", [g.LESS]);
                  d.set("depthMask", [true]);
                  d.set("depthRange", [0, 1]);
                  d.set("frontFace", [g.CCW]);
                  d.set("lineWidth", [1]);
                  d.set("polygonOffset", [0, 0]);
                  d.set("sampleCoverage", [1, false]);
                  d.set("stencilFunc", [g.ALWAYS, 0, 1]);
                  d.set("_stencilFuncSeparateFront", [g.ALWAYS, 0, 1]);
                  d.set("_stencilFuncSeparateBack", [g.ALWAYS, 0, 1]);
                  d.set("_stencilFuncSeparateFrontAndBack", [g.ALWAYS, 0, 1]);
                  d.set("stencilMask", [1]);
                  d.set("_stencilMaskSeparateFront", [1]);
                  d.set("_stencilMaskSeparateBack", [1]);
                  d.set("_stencilMaskSeparateFrontAndBack", [1]);
                  d.set("stencilOp", [g.KEEP, g.KEEP, g.KEEP]);
                  d.set("_stencilOpSeparateFront", [g.KEEP, g.KEEP, g.KEEP]);
                  d.set("_stencilOpSeparateBack", [g.KEEP, g.KEEP, g.KEEP]);
                  d.set("_stencilOpSeparateFrontAndBack", [g.KEEP, g.KEEP, g.KEEP]);
                  d.set("vertexAttrib1f", []);
                  d.set("vertexAttrib1fv", []);
                  d.set("vertexAttrib2f", []);
                  d.set("vertexAttrib2fv", []);
                  d.set("vertexAttrib3f", []);
                  d.set("vertexAttrib3fv", []);
                  d.set("vertexAttrib4f", []);
                  d.set("vertexAttrib4fv", []);
              }
              return this._defaultSettings
          }
          static _getTextureTargetIndex(target) {
              switch(target) {
                  case 0x0DE1:
                      return 0;
                  case 0x8513:
                      return 1;
                  default:
                      throw new Error('Unknown texture target: ' + target);
              }
          }
          static _getTextureTargetByIndex(index) {
              if (!this._textureTargetIndices) {
                  this._textureTargetIndices = [0x0DE1, 0x8513];
              }
              return this._textureTargetIndices[index]
          }
          static _getTextureIndex(index) {
              return index - 0x84C0 ;
          }
          static _getTextureByIndex(index) {
              return index + 0x84C0;
          }
          static _getPixelStoreiIndex(pname) {
              switch(pname) {
                  case 0x0D05:
                      return 0;
                  case 0x0CF5:
                      return 1;
                  case 0x9240:
                      return 2;
                  case 0x9241:
                      return 3;
                  case 0x9243:
                      return 4;
                  case 0x9245:
                      return 5;
                  default:
                      throw new Error('Unknown pixelstorei: ' + pname);
              }
          }
          static _getPixelStoreiByIndex(index) {
              if (!this._pixelStoreiIndices) {
                  this._pixelStoreiIndices = [0x0D05, 0x0CF5, 0x9240, 0x9241, 0x9243];
              }
              return this._pixelStoreiIndices[index]
          }
          static _getDefaultPixelStoreiByIndex(index) {
              if (!this._pixelStoreiDefaults) {
                  this._pixelStoreiDefaults = [4, 4, false, false, WebGLRenderingContext.prototype.BROWSER_DEFAULT_WEBGL];
              }
              return this._pixelStoreiDefaults[index]
          }
      }
      class WebGLStateManager {
          _initStateManager(id = "default") {
              this._states = {};
              this._state = this._getState(id);
          }
          _getState(id) {
              if (!this._states[id]) {
                  this._states[id] = new WebGLState(id, this);
              }
              return this._states[id];
          }
          switchState(id = "default") {
              if (this._state._id !== id) {
                  const newState = this._getState(id);
                  this._state.migrate(newState);
                  this._state = newState;
              }
          }
          $useProgram(program) {
              if (this._state.setProgram(program))
                  this._useProgram(program);
          }
          $bindBuffer(target, fb) {
              if (this._state.setBuffer(target, fb))
                  this._bindBuffer(target, fb);
          }
          $bindFramebuffer(target, fb) {
              if (this._state.setFramebuffer(target, fb))
                  this._bindFramebuffer(target, fb);
          }
          $bindRenderbuffer(target, fb) {
              if (this._state.setRenderbuffer(target, fb))
                  this._bindRenderbuffer(target, fb);
          }
          $enable(cap) {
              if (this._state.setFlag(cap, true))
                  this._enable(cap);
          }
          $disable(cap) {
              if (this._state.setFlag(cap, false))
                  this._disable(cap);
          }
          $viewport(x, y, w, h) {
              if (this._state.setSetting(this._viewport, [x, y, w, h]))
                  this._viewport(x, y, w, h);
          }
          $scissor(x, y, w, h) {
              if (this._state.setSetting(this._scissor, [x, y, w, h]))
                  this._scissor(x, y, w, h);
          }
          $disableVertexAttribArray(index) {
              if (this._state.disableVertexAttribArray(index))
                  this._disableVertexAttribArray(index);
          }
          $enableVertexAttribArray(index) {
              if (this._state.enableVertexAttribArray(index))
                  this._enableVertexAttribArray(index);
          }
          $vertexAttribPointer(index, size, type, normalized, stride, offset) {
              if (this._state.vertexAttribPointer(index, [size, type, normalized, stride, offset]))
                  this._vertexAttribPointer(index, size, type, normalized, stride, offset);
          }
          $activeTexture(texture) {
              if (this._state.setActiveTexture(texture))
                  this._activeTexture(texture);
          }
          $bindTexture(target, texture) {
              if (this._state.bindTexture(target, texture))
                  this._bindTexture(target, texture);
          }
          $pixelStorei(pname, param) {
              if (this._state.setPixelStorei(pname, param)) {
                  this._pixelStorei(pname, param);
              }
          }
          $stencilFuncSeparate(face, func, ref, mask) {
              let f;
              switch(face) {
                  case this.FRONT:
                      f = this._stencilFuncSeparateFront;
                      break;
                  case this.BACK:
                      f = this._stencilFuncSeparateBack;
                      break;
                  case this.FRONT_AND_BACK:
                      f = this._stencilFuncSeparateFrontAndBack;
                      break;
              }
              if (this._state.setSetting(f, [func, ref, mask]))
                  f.apply(this, [func, ref, mask]);
          }
          _stencilFuncSeparateFront(func, ref, mask) {
              this._stencilFuncSeparate(this.FRONT, func, ref, mask);
          }
          _stencilFuncSeparateBack(func, ref, mask) {
              this._stencilFuncSeparate(this.BACK, func, ref, mask);
          }
          _stencilFuncSeparateFrontAndBack(func, ref, mask) {
              this._stencilFuncSeparate(this.FRONT_AND_BACK, func, ref, mask);
          }
          $stencilMaskSeparate(face, mask) {
              let f;
              switch(face) {
                  case this.FRONT:
                      f = this._stencilMaskSeparateFront;
                      break;
                  case this.BACK:
                      f = this._stencilMaskSeparateBack;
                      break;
                  case this.FRONT_AND_BACK:
                      f = this._stencilMaskSeparateFrontAndBack;
                      break;
              }
              if (this._state.setSetting(f, [mask]))
                  f.apply(this, [mask]);
          }
          _stencilMaskSeparateFront(mask) {
              this._stencilMaskSeparate(this.FRONT, mask);
          }
          _stencilMaskSeparateBack(mask) {
              this._stencilMaskSeparate(this.BACK, mask);
          }
          _stencilMaskSeparateFrontAndBack(mask) {
              this._stencilMaskSeparate(this.FRONT_AND_BACK, mask);
          }
          $stencilOpSeparate(face, fail, zfail, zpass) {
              let f;
              switch(face) {
                  case this.FRONT:
                      f = this._stencilOpSeparateFront;
                      break;
                  case this.BACK:
                      f = this._stencilOpSeparateBack;
                      break;
                  case this.FRONT_AND_BACK:
                      f = this._stencilOpSeparateFrontAndBack;
                      break;
              }
              if (this._state.setSetting(f, [fail, zfail, zpass]))
                  f.apply(this, [fail, zfail, zpass]);
          }
          _stencilOpSeparateFront(fail, zfail, zpass) {
              this._stencilOpSeparate(this.FRONT, fail, zfail, zpass);
          }
          _stencilOpSeparateBack(fail, zfail, zpass) {
              this._stencilOpSeparate(this.BACK, fail, zfail, zpass);
          }
          _stencilOpSeparateFrontAndBack(fail, zfail, zpass) {
              this._stencilOpSeparate(this.FRONT_AND_BACK, fail, zfail, zpass);
          }
          $blendColor(red, green, blue, alpha) {
              if (this._state.setSetting(this._blendColor, [red, green, blue, alpha]))
                  this._blendColor(red, green, blue, alpha);
          }
          $blendEquation(mode) {
              if (this._state.setSetting(this._blendEquation, [mode]))
                  this._blendEquation(mode);
          }
          $blendEquationSeparate(modeRGB, modeAlpha) {
              if (this._state.setSetting(this._blendEquationSeparate, [modeRGB, modeAlpha]))
                  this._blendEquationSeparate(modeRGB, modeAlpha);
          }
          $blendFunc(sfactor, dfactor) {
              if (this._state.setSetting(this._blendFunc, [sfactor, dfactor]))
                  this._blendFunc(sfactor, dfactor);
          }
          $blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
              if (this._state.setSetting(this._blendFuncSeparate, [srcRGB, dstRGB, srcAlpha, dstAlpha]))
                  this._blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
          }
          $clearColor(red, green, blue, alpha) {
              if (this._state.setSetting(this._clearColor, [red, green, blue, alpha]))
                  this._clearColor(red, green, blue, alpha);
          }
          $clearDepth(depth) {
              if (this._state.setSetting(this._clearDepth, [depth]))
                  this._clearDepth(depth);
          }
          $clearStencil(s) {
              if (this._state.setSetting(this._clearStencil, [s]))
                  this._clearStencil(s);
          }
          $colorMask(red, green, blue, alpha) {
              if (this._state.setSetting(this._colorMask, [red, green, blue, alpha]))
                  this._colorMask(red, green, blue, alpha);
          }
          $cullFace(mode) {
              if (this._state.setSetting(this._cullFace, [mode]))
                  this._cullFace(mode);
          }
          $depthFunc(func) {
              if (this._state.setSetting(this._depthFunc, [func]))
                  this._depthFunc(func);
          }
          $depthMask(flag) {
              if (this._state.setSetting(this._depthMask, [flag]))
                  this._depthMask(flag);
          }
          $depthRange(zNear, zFar) {
              if (this._state.setSetting(this._depthRange, [zNear, zFar]))
                  this._depthRange(zNear, zFar);
          }
          $frontFace(mode) {
              if (this._state.setSetting(this._frontFace, [mode]))
                  this._frontFace(mode);
          }
          $lineWidth(width) {
              if (this._state.setSetting(this._lineWidth, [width]))
                  this._lineWidth(width);
          }
          $polygonOffset(factor, units) {
              if (this._state.setSetting(this._polygonOffset, [factor, units]))
                  this._polygonOffset(factor, units);
          }
          $sampleCoverage(value, invert) {
              if (this._state.setSetting(this._sampleCoverage, [value, invert]))
                  this._sampleCoverage(value, invert);
          }
          $stencilFunc(func, ref, mask) {
              if (this._state.setSetting(this._stencilFunc, [func, ref, mask]))
                  this._stencilFunc(func, ref, mask);
          }
          $stencilMask(mask) {
              if (this._state.setSetting(this._stencilMask, [mask]))
                  this._stencilMask(mask);
          }
          $stencilOp(fail, zfail, zpass) {
              if (this._state.setSetting(this._stencilOp, [fail, zfail, zpass]))
                  this._stencilOp(fail, zfail, zpass);
          }
          $vertexAttrib1f(indx, x) {
              if (this._state.setSetting(this._vertexAttrib1f, [indx, x]))
                  this._vertexAttrib1f(indx, x);
          }
          $vertexAttrib1fv(indx, values) {
              if (this._state.setSetting(this._vertexAttrib1fv, [indx, values]))
                  this._vertexAttrib1fv(indx, values);
          }
          $vertexAttrib2f(indx, x, y) {
              if (this._state.setSetting(this._vertexAttrib2f, [indx, x, y]))
                  this._vertexAttrib2f(indx, x, y);
          }
          $vertexAttrib2fv(indx, values) {
              if (this._state.setSetting(this._vertexAttrib2fv, [indx, values]))
                  this._vertexAttrib2fv(indx, values);
          }
          $vertexAttrib3f(indx, x, y, z) {
              if (this._state.setSetting(this._vertexAttrib3f, [indx, x, y, z]))
                  this._vertexAttrib3f(indx, x, y, z);
          }
          $vertexAttrib3fv(indx, values) {
              if (this._state.setSetting(this._vertexAttrib3fv, [indx, values]))
                  this._vertexAttrib3fv(indx, values);
          }
          $vertexAttrib4f(indx, x, y, z, w) {
              if (this._state.setSetting(this._vertexAttrib4f, [indx, x, y, z, w]))
                  this._vertexAttrib4f(indx, x, y, z, w);
          }
          $vertexAttrib4fv(indx, values) {
              if (this._state.setSetting(this._vertexAttrib4fv, [indx, values]))
                  this._vertexAttrib4fv(indx, values);
          }
          static enable(gl, id = "default") {
              const names = Object.getOwnPropertyNames(WebGLStateManager.prototype);
              gl.__proto__;
              names.forEach(name => {
                  if (name !== "constructor") {
                      const method = WebGLStateManager.prototype[name];
                      if (name.charAt(0) === "$") {
                          name = name.substr(1);
                      }
                      if (gl[name] !== method) {
                          if (gl[name]) {
                              if (!gl[name].name) {
                                  gl[name].xname = name;
                              }
                              gl['_' + name] = gl[name];
                          }
                          gl[name] = method;
                      }
                  }
              });
              WebGLStateManager.prototype._initStateManager.call(gl, id);
              return gl;
          }
      }

      class TextureManager {
          constructor(stage) {
              this.stage = stage;
              this._usedMemory = 0;
              this._uploadedTextureSources = [];
              this.textureSourceHashmap = new Map();
          }
          get usedMemory() {
              return this._usedMemory;
          }
          destroy() {
              for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
                  this._nativeFreeTextureSource(this._uploadedTextureSources[i]);
              }
              this.textureSourceHashmap.clear();
              this._usedMemory = 0;
          }
          getReusableTextureSource(id) {
              return this.textureSourceHashmap.get(id);
          }
          getTextureSource(func, id) {
              let textureSource = id ? this.textureSourceHashmap.get(id) : null;
              if (!textureSource) {
                  textureSource = new TextureSource(this, func);
                  if (id) {
                      textureSource.lookupId = id;
                      this.textureSourceHashmap.set(id, textureSource);
                  }
              }
              return textureSource;
          }
          uploadTextureSource(textureSource, options) {
              console.log('uploadTextureSource')
              if (textureSource.isLoaded()) return;
              this._addMemoryUsage(textureSource.w * textureSource.h);
              const nativeTexture = this._nativeUploadTextureSource(textureSource, options);
              textureSource._nativeTexture = nativeTexture;
              nativeTexture.w = textureSource.w;
              nativeTexture.h = textureSource.h;
              nativeTexture.update = this.stage.frameCounter;
              this._uploadedTextureSources.push(textureSource);
              this.addToLookupMap(textureSource);
          }
          _addMemoryUsage(delta) {
              this._usedMemory += delta;
              this.stage.addMemoryUsage(delta);
          }
          addToLookupMap(textureSource) {
              const lookupId = textureSource.lookupId;
              if (lookupId) {
                  if (!this.textureSourceHashmap.has(lookupId)) {
                      this.textureSourceHashmap.set(lookupId, textureSource);
                  }
              }
          }
          gc() {
              this.freeUnusedTextureSources();
              this._cleanupLookupMap();
          }
          freeUnusedTextureSources() {
              let remainingTextureSources = [];
              for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
                  let ts = this._uploadedTextureSources[i];
                  if (ts.allowCleanup()) {
                      this._freeManagedTextureSource(ts);
                  } else {
                      remainingTextureSources.push(ts);
                  }
              }
              this._uploadedTextureSources = remainingTextureSources;
              this._cleanupLookupMap();
          }
          _freeManagedTextureSource(textureSource) {
              if (textureSource.isLoaded()) {
                  this._nativeFreeTextureSource(textureSource);
                  this._addMemoryUsage(-textureSource.w * textureSource.h);
              }
              textureSource.loadingSince = null;
          }
          _cleanupLookupMap() {
              this.textureSourceHashmap.forEach((textureSource, lookupId) => {
                  if (!(textureSource.isLoaded() || textureSource.isLoading()) && !textureSource.isUsed()) {
                      this.textureSourceHashmap.delete(lookupId);
                  }
              });
          }
          freeTextureSource(textureSource) {
              const index = this._uploadedTextureSources.indexOf(textureSource);
              const managed = (index !== -1);
              if (textureSource.isLoaded()) {
                  if (managed) {
                      this._addMemoryUsage(-textureSource.w * textureSource.h);
                      this._uploadedTextureSources.splice(index, 1);
                  }
                  this._nativeFreeTextureSource(textureSource);
              }
              textureSource.loadingSince = null;
          }
          _nativeUploadTextureSource(textureSource, options) {
              return this.stage.renderer.uploadTextureSource(textureSource, options);
          }
          _nativeFreeTextureSource(textureSource) {
              this.stage.renderer.freeTextureSource(textureSource);
              textureSource.clearNativeTexture();
          }
      }

      class TextureThrottler {
          constructor(stage) {
              this.stage = stage;
              this.genericCancelCb = (textureSource) => {
                  this._remove(textureSource);
              };
              this._sources = [];
              this._data = [];
          }
          destroy() {
              this._sources = [];
              this._data = [];
          }
          processSome() {
              if (this._sources.length) {
                  const start = Date.now();
                  do {
                      this._processItem();
                  } while(this._sources.length && (Date.now() - start < TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME));
              }
          }
          _processItem() {
              const source = this._sources.pop();
              const data = this._data.pop();
              if (source.isLoading()) {
                  source.processLoadedSource(data);
              }
          }
          add(textureSource, data) {
              this._sources.push(textureSource);
              this._data.push(data);
          }
          _remove(textureSource) {
              const index = this._sources.indexOf(textureSource);
              if (index >= 0) {
                  this._sources.splice(index, 1);
                  this._data.splice(index, 1);
              }
          }
      }
      TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME = 10;

      class CoreContext {
          constructor(stage) {
              this.stage = stage;
              this.root = null;
              this.updateTreeOrder = 0;
              this.renderState = this.stage.renderer.createCoreRenderState(this);
              this.renderExec = this.stage.renderer.createCoreRenderExecutor(this);
              this.renderExec.init();
              this._usedMemory = 0;
              this._renderTexturePool = [];
              this._renderTextureId = 1;
              this._zSorts = [];
          }
          get usedMemory() {
              return this._usedMemory;
          }
          destroy() {
              this._renderTexturePool.forEach(texture => this._freeRenderTexture(texture));
              this._usedMemory = 0;
          }
          hasRenderUpdates() {
              return !!this.root._parent._hasRenderUpdates;
          }
          render() {
              this.root._parent._hasRenderUpdates = 0;
              this._render();
          }
          update() {
              this._update();
              if (this.root._hasUpdates) {
                  this._update();
              }
              this._performForcedZSorts();
          }
          _performForcedZSorts() {
              const n = this._zSorts.length;
              if (n) {
                  for (let i = 0, n = this._zSorts.length; i < n; i++) {
                      if (this._zSorts[i].zSort) {
                          this._zSorts[i].sortZIndexedChildren();
                      }
                  }
                  this._zSorts = [];
              }
          }
          _update() {
              this.updateTreeOrder = 0;
              this.root.update();
          }
          _render() {
              this._fillRenderState();
              if (this.stage.getOption('readPixelsBeforeDraw')) {
                  const pixels = new Uint8Array(4);
                  const gl = this.stage.gl;
                  gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
              }
              this._performRender();
          }
          _fillRenderState() {
              this.renderState.reset();
              this.root.render();
              this.renderState.finish();
          }
          _performRender() {
              this.renderExec.execute();
          }
          _addMemoryUsage(delta) {
              this._usedMemory += delta;
              this.stage.addMemoryUsage(delta);
          }
          allocateRenderTexture(w, h) {
              let prec = this.stage.getRenderPrecision();
              let pw = Math.max(1, Math.round(w * prec));
              let ph = Math.max(1, Math.round(h * prec));
              const n = this._renderTexturePool.length;
              for (let i = n - 1; i >= 0; i--) {
                  const texture = this._renderTexturePool[i];
                  if (texture.w === pw && texture.h === ph && (texture.update !== this.stage.frameCounter)) {
                      texture.f = this.stage.frameCounter;
                      this._renderTexturePool.splice(i, 1);
                      return texture;
                  }
              }
              const texture = this._createRenderTexture(w, h, pw, ph);
              texture.precision = prec;
              return texture;
          }
          releaseRenderTexture(texture) {
              this._renderTexturePool.push(texture);
          }
          freeUnusedRenderTextures(maxAge = 60) {
              let limit = this.stage.frameCounter - maxAge;
              this._renderTexturePool = this._renderTexturePool.filter(texture => {
                  if (texture.f <= limit) {
                      this._freeRenderTexture(texture);
                      return false;
                  }
                  return true;
              });
          }
          _createRenderTexture(w, h, pw, ph) {
              this._addMemoryUsage(pw * ph);
              const texture = this.stage.renderer.createRenderTexture(w, h, pw, ph);
              texture.id = this._renderTextureId++;
              texture.f = this.stage.frameCounter;
              texture.ow = w;
              texture.oh = h;
              texture.w = pw;
              texture.h = ph;
              return texture;
          }
          _freeRenderTexture(nativeTexture) {
              this.stage.renderer.freeRenderTexture(nativeTexture);
              this._addMemoryUsage(-nativeTexture.w * nativeTexture.h);
          }
          copyRenderTexture(renderTexture, nativeTexture, options) {
              this.stage.renderer.copyRenderTexture(renderTexture, nativeTexture, options);
          }
          forceZSort(elementCore) {
              this._zSorts.push(elementCore);
          }
      }

      class TransitionSettings {
          constructor(stage) {
              this.stage = stage;
              this._timingFunction = 'ease';
              this._timingFunctionImpl = StageUtils.getTimingFunction(this._timingFunction);
              this.delay = 0;
              this.duration = 0.2;
              this.merger = null;
          }
          get timingFunction() {
              return this._timingFunction;
          }
          set timingFunction(v) {
              this._timingFunction = v;
              this._timingFunctionImpl = StageUtils.getTimingFunction(v);
          }
          get timingFunctionImpl() {
              return this._timingFunctionImpl;
          }
          patch(settings) {
              Base.patchObject(this, settings);
          }
      }
      TransitionSettings.prototype.isTransitionSettings = true;

      class TransitionManager {
          constructor(stage) {
              this.stage = stage;
              this.stage.on('frameStart', () => this.progress());
              this.active = new Set();
              this.defaultTransitionSettings = new TransitionSettings(this.stage);
          }
          progress() {
              if (this.active.size) {
                  let dt = this.stage.dt;
                  let filter = false;
                  this.active.forEach(function(a) {
                      a.progress(dt);
                      if (!a.isRunning()) {
                          filter = true;
                      }
                  });
                  if (filter) {
                      this.active = new Set([...this.active].filter(t => (t.isRunning())));
                  }
              }
          }
          createSettings(settings) {
              const transitionSettings = new TransitionSettings();
              Base.patchObject(transitionSettings, settings);
              return transitionSettings;
          }
          addActive(transition) {
              this.active.add(transition);
          }
          removeActive(transition) {
              this.active.delete(transition);
          }
      }

      class MultiSpline {
          constructor() {
              this._clear();
          }
          _clear() {
              this._p = [];
              this._pe = [];
              this._idp = [];
              this._f = [];
              this._v = [];
              this._lv = [];
              this._sm = [];
              this._s = [];
              this._ve = [];
              this._sme = [];
              this._se = [];
              this._length = 0;
          }
          parse(rgba, def) {
              let i, n;
              if (!Utils.isObjectLiteral(def)) {
                  def = {0: def};
              }
              let defaultSmoothness = 0.5;
              let items = [];
              for (let key in def) {
                  if (def.hasOwnProperty(key)) {
                      let obj = def[key];
                      if (!Utils.isObjectLiteral(obj)) {
                          obj = {v: obj};
                      }
                      let p = parseFloat(key);
                      if (key === "sm") {
                          defaultSmoothness = obj.v;
                      } else if (!isNaN(p) && p >= 0 && p <= 2) {
                          obj.p = p;
                          obj.f = Utils.isFunction(obj.v);
                          obj.lv = obj.f ? obj.v(0, 0) : obj.v;
                          items.push(obj);
                      }
                  }
              }
              items = items.sort(function(a, b) {return a.p - b.p});
              n = items.length;
              for (i = 0; i < n; i++) {
                  let last = (i === n - 1);
                  if (!items[i].hasOwnProperty('pe')) {
                      items[i].pe = last ? (items[i].p <= 1 ? 1 : 2 ) : items[i + 1].p;
                  } else {
                      const max = i < n - 1 ? items[i + 1].p : 1;
                      if (items[i].pe > max) {
                          items[i].pe = max;
                      }
                  }
                  if (items[i].pe === items[i].p) {
                      items[i].idp = 0;
                  } else {
                      items[i].idp = 1 / (items[i].pe - items[i].p);
                  }
              }
              for (i = 0; i < n; i++) {
                  if (!items[i].hasOwnProperty('sm')) {
                      items[i].sm = defaultSmoothness;
                  }
                  if (!items[i].hasOwnProperty('s')) {
                      if (i === 0 || i === n - 1 || (items[i].p === 1 )) {
                          items[i].s = rgba ? [0, 0, 0, 0] : 0;
                      } else {
                          const pi = items[i - 1];
                          const ni = items[i + 1];
                          if (pi.p === ni.p) {
                              items[i].s = rgba ? [0, 0, 0, 0] : 0;
                          } else {
                              if (rgba) {
                                  const nc = MultiSpline.getRgbaComponents(ni.lv);
                                  const pc = MultiSpline.getRgbaComponents(pi.lv);
                                  const d = 1 / (ni.p - pi.p);
                                  items[i].s = [
                                      d * (nc[0] - pc[0]),
                                      d * (nc[1] - pc[1]),
                                      d * (nc[2] - pc[2]),
                                      d * (nc[3] - pc[3])
                                  ];
                              } else {
                                  items[i].s = (ni.lv - pi.lv) / (ni.p - pi.p);
                              }
                          }
                      }
                  }
              }
              for (i = 0; i < n - 1; i++) {
                  if (!items[i].f) {
                      let last = (i === n - 1);
                      if (!items[i].hasOwnProperty('ve')) {
                          items[i].ve = last ? items[i].lv : items[i + 1].lv;
                      }
                      if (Utils.isNumber(items[i].v) && Utils.isNumber(items[i].lv)) {
                          if (!items[i].hasOwnProperty('sme')) {
                              items[i].sme = last ? defaultSmoothness : items[i + 1].sm;
                          }
                          if (!items[i].hasOwnProperty('se')) {
                              items[i].se = last ? (rgba ? [0, 0, 0, 0] : 0) : items[i + 1].s;
                          }
                          if (rgba) {
                              items[i].v = MultiSpline.getSplineRgbaValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                          } else {
                              items[i].v = MultiSpline.getSplineValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                          }
                          items[i].f = true;
                      }
                  }
              }
              if (this.length) {
                  this._clear();
              }
              for (i = 0, n = items.length; i < n; i++) {
                  this._add(items[i]);
              }
          }
          _add(item) {
              this._p.push(item.p || 0);
              this._pe.push(item.pe || 0);
              this._idp.push(item.idp || 0);
              this._f.push(item.f || false);
              this._v.push(item.hasOwnProperty('v') ? item.v : 0  );
              this._lv.push(item.lv || 0);
              this._sm.push(item.sm || 0);
              this._s.push(item.s || 0);
              this._ve.push(item.ve || 0);
              this._sme.push(item.sme || 0);
              this._se.push(item.se || 0);
              this._length++;
          }
          _getItem(p) {
              const n = this._length;
              if (!n) {
                  return -1;
              }
              if (p < this._p[0]) {
                  return 0;
              }
              for (let i = 0; i < n; i++) {
                  if (this._p[i] <= p && p < this._pe[i]) {
                      return i;
                  }
              }
              return n - 1;
          }
          getValue(p) {
              const i = this._getItem(p);
              if (i === -1) {
                  return undefined;
              } else {
                  if (this._f[i]) {
                      const o = Math.min(1, Math.max(0, (p - this._p[i]) * this._idp[i]));
                      return this._v[i](o);
                  } else {
                      return this._v[i];
                  }
              }
          }
          get length() {
              return this._length;
          }
          static getRgbaComponents(argb) {
              let r = ((argb / 65536) | 0) % 256;
              let g = ((argb / 256) | 0) % 256;
              let b = argb % 256;
              let a = ((argb / 16777216) | 0);
              return [r, g, b, a];
          };
          static getSplineValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
              let dp = p2 - p1;
              s1 *= dp;
              s2 *= dp;
              let helpers = MultiSpline.getSplineHelpers(v1, v2, o1, i2, s1, s2);
              if (!helpers) {
                  return function (p) {
                      if (p === 0) return v1;
                      if (p === 1) return v2;
                      return v2 * p + v1 * (1 - p);
                  };
              } else {
                  return function (p) {
                      if (p === 0) return v1;
                      if (p === 1) return v2;
                      return MultiSpline.calculateSpline(helpers, p);
                  };
              }
          };
          static getSplineRgbaValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
              let dp = p2 - p1;
              s1[0] *= dp;
              s1[1] *= dp;
              s1[2] *= dp;
              s1[3] *= dp;
              s2[0] *= dp;
              s2[1] *= dp;
              s2[2] *= dp;
              s2[3] *= dp;
              let cv1 = MultiSpline.getRgbaComponents(v1);
              let cv2 = MultiSpline.getRgbaComponents(v2);
              let helpers = [
                  MultiSpline.getSplineHelpers(cv1[0], cv2[0], o1, i2, s1[0], s2[0]),
                  MultiSpline.getSplineHelpers(cv1[1], cv2[1], o1, i2, s1[1], s2[1]),
                  MultiSpline.getSplineHelpers(cv1[2], cv2[2], o1, i2, s1[2], s2[2]),
                  MultiSpline.getSplineHelpers(cv1[3], cv2[3], o1, i2, s1[3], s2[3])
              ];
              if (!helpers[0]) {
                  return function (p) {
                      if (p === 0) return v1;
                      if (p === 1) return v2;
                      return MultiSpline.mergeColors(v2, v1, p);
                  };
              } else {
                  return function (p) {
                      if (p === 0) return v1;
                      if (p === 1) return v2;
                      return MultiSpline.getArgbNumber([
                          Math.min(255, MultiSpline.calculateSpline(helpers[0], p)),
                          Math.min(255, MultiSpline.calculateSpline(helpers[1], p)),
                          Math.min(255, MultiSpline.calculateSpline(helpers[2], p)),
                          Math.min(255, MultiSpline.calculateSpline(helpers[3], p))
                      ]);
                  };
              }
          };
          static getSplineHelpers(v1, v2, o1, i2, s1, s2) {
              if (!o1 && !i2) {
                  return null;
              }
              let csx = o1;
              let csy = v1 + s1 * o1;
              let cex = 1 - i2;
              let cey = v2 - s2 * i2;
              let xa = 3 * csx - 3 * cex + 1;
              let xb = -6 * csx + 3 * cex;
              let xc = 3 * csx;
              let ya = 3 * csy - 3 * cey + v2 - v1;
              let yb = 3 * (cey + v1) - 6 * csy;
              let yc = 3 * (csy - v1);
              let yd = v1;
              return [xa, xb, xc, ya, yb, yc, yd];
          };
          static calculateSpline(helpers, p) {
              let xa = helpers[0];
              let xb = helpers[1];
              let xc = helpers[2];
              let ya = helpers[3];
              let yb = helpers[4];
              let yc = helpers[5];
              let yd = helpers[6];
              if (xa === -2 && ya === -2 && xc === 0 && yc === 0) {
                  return p;
              }
              let t = 0.5, cbx, dx;
              for (let it = 0; it < 20; it++) {
                  cbx = t * (t * (t * xa + xb) + xc);
                  dx = p - cbx;
                  if (dx > -1e-8 && dx < 1e-8) {
                      return t * (t * (t * ya + yb) + yc) + yd;
                  }
                  let cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
                  if (cbxd > 1e-10 && cbxd < 1e-10) {
                      break;
                  }
                  t += dx / cbxd;
              }
              let minT = 0;
              let maxT = 1;
              for (let it = 0; it < 20; it++) {
                  t = 0.5 * (minT + maxT);
                  cbx = t * (t * (t * xa + xb) + xc);
                  dx = p - cbx;
                  if (dx > -1e-8 && dx < 1e-8) {
                      return t * (t * (t * ya + yb) + yc) + yd;
                  }
                  if (dx < 0) {
                      maxT = t;
                  } else {
                      minT = t;
                  }
              }
              return t;
          };
          static mergeColors(c1, c2, p) {
              let r1 = ((c1 / 65536) | 0) % 256;
              let g1 = ((c1 / 256) | 0) % 256;
              let b1 = c1 % 256;
              let a1 = ((c1 / 16777216) | 0);
              let r2 = ((c2 / 65536) | 0) % 256;
              let g2 = ((c2 / 256) | 0) % 256;
              let b2 = c2 % 256;
              let a2 = ((c2 / 16777216) | 0);
              let r = r1 * p + r2 * (1 - p);
              let g = g1 * p + g2 * (1 - p);
              let b = b1 * p + b2 * (1 - p);
              let a = a1 * p + a2 * (1 - p);
              return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
          };
          static getArgbNumber(rgba) {
              rgba[0] = Math.max(0, Math.min(255, rgba[0]));
              rgba[1] = Math.max(0, Math.min(255, rgba[1]));
              rgba[2] = Math.max(0, Math.min(255, rgba[2]));
              rgba[3] = Math.max(0, Math.min(255, rgba[3]));
              let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
              if (v < 0) {
                  v = 0xFFFFFFFF + v + 1;
              }
              return v;
          };
      }

      class AnimationActionSettings {
          constructor(animationSettings) {
              this.animationSettings = animationSettings;
              this._selector = "";
              this._items = new MultiSpline();
              this._props = [];
              this._propSetters = [];
              this._resetValue = undefined;
              this._hasResetValue = false;
              this._hasColorProperty = undefined;
          }
          getResetValue() {
              if (this._hasResetValue) {
                  return this._resetValue;
              } else {
                  return this._items.getValue(0);
              }
          }
          apply(element, p, factor) {
              const elements = this.getAnimatedElements(element);
              let v = this._items.getValue(p);
              if (v === undefined || !elements.length) {
                  return;
              }
              if (factor !== 1) {
                  let sv = this.getResetValue();
                  if (Utils.isNumber(v) && Utils.isNumber(sv)) {
                      if (this.hasColorProperty()) {
                          v = StageUtils.mergeColors(v, sv, factor);
                      } else {
                          v = StageUtils.mergeNumbers(v, sv, factor);
                      }
                  }
              }
              const n = this._propSetters.length;
              const m = elements.length;
              for (let j = 0; j < m; j++) {
                  for (let i = 0; i < n; i++) {
                      this._propSetters[i](elements[j], v);
                  }
              }
          }
          getAnimatedElements(element) {
              return element.select(this._selector);
          }
          reset(element) {
              const elements = this.getAnimatedElements(element);
              let v = this.getResetValue();
              if (v === undefined || !elements.length) {
                  return;
              }
              const n = this._propSetters.length;
              const m = elements.length;
              for (let j = 0; j < m; j++) {
                  for (let i = 0; i < n; i++) {
                      this._propSetters[i](elements[j], v);
                  }
              }
          }
          set selector(v) {
              this._selector = v;
          }
          set t(v) {
              this.selector = v;
          }
          get resetValue() {
              return this._resetValue;
          }
          set resetValue(v) {
              this._resetValue = v;
              this._hasResetValue = (v !== undefined);
          }
          set rv(v) {
              this.resetValue = v;
          }
          set value(v) {
              this._items.parse(this.hasColorProperty(), v);
          }
          set v(v) {
              this.value = v;
          }
          set properties(v) {
              if (!Array.isArray(v)) {
                  v = [v];
              }
              this._props = [];
              v.forEach((prop) => {
                  this._props.push(prop);
                  this._propSetters.push(Element.getSetter(prop));
              });
          }
          set property(v) {
              this._hasColorProperty = undefined;
              this.properties = v;
          }
          set p(v) {
              this.properties = v;
          }
          patch(settings) {
              Base.patchObject(this, settings);
          }
          hasColorProperty() {
              if (this._hasColorProperty === undefined) {
                  this._hasColorProperty = this._props.length ? Element.isColorProperty(this._props[0]) : false;
              }
              return this._hasColorProperty;
          }
      }
      AnimationActionSettings.prototype.isAnimationActionSettings = true;

      class AnimationSettings {
          constructor() {
              this._actions = [];
              this.delay = 0;
              this.duration = 1;
              this.repeat = 0;
              this.repeatOffset = 0;
              this.repeatDelay = 0;
              this.autostop = false;
              this.stopMethod = AnimationSettings.STOP_METHODS.FADE;
              this._stopTimingFunction = 'ease';
              this._stopTimingFunctionImpl = StageUtils.getTimingFunction(this._stopTimingFunction);
              this.stopDuration = 0;
              this.stopDelay = 0;
          }
          get actions() {
              return this._actions;
          }
          set actions(v) {
              this._actions = [];
              for (let i = 0, n = v.length; i < n; i++) {
                  const e = v[i];
                  if (!e.isAnimationActionSettings) {
                      const aas = new AnimationActionSettings(this);
                      aas.patch(e);
                      this._actions.push(aas);
                  } else {
                      this._actions.push(e);
                  }
              }
          }
          apply(element, p, factor = 1) {
              this._actions.forEach(function(action) {
                  action.apply(element, p, factor);
              });
          }
          reset(element) {
              this._actions.forEach(function(action) {
                  action.reset(element);
              });
          }
          get stopTimingFunction() {
              return this._stopTimingFunction;
          }
          set stopTimingFunction(v) {
              this._stopTimingFunction = v;
              this._stopTimingFunctionImpl = StageUtils.getTimingFunction(v);
          }
          get stopTimingFunctionImpl() {
              return this._stopTimingFunctionImpl;
          }
          patch(settings) {
              Base.patchObject(this, settings);
          }
      }
      AnimationSettings.STOP_METHODS = {
          FADE: 'fade',
          REVERSE: 'reverse',
          FORWARD: 'forward',
          IMMEDIATE: 'immediate',
          ONETOTWO: 'onetotwo'
      };

      class Animation extends EventEmitter {
          constructor(manager, settings, element) {
              super();
              this.manager = manager;
              this._settings = settings;
              this._element = element;
              this._state = Animation.STATES.IDLE;
              this._p = 0;
              this._delayLeft = 0;
              this._repeatsLeft = 0;
              this._stopDelayLeft = 0;
              this._stopP = 0;
          }
          start() {
              if (this._element && this._element.attached) {
                  this._p = 0;
                  this._delayLeft = this.settings.delay;
                  this._repeatsLeft = this.settings.repeat;
                  this._state = Animation.STATES.PLAYING;
                  this.emit('start');
                  this.checkActive();
              } else {
                  console.warn("[Lightning] Element must be attached before starting animation");
              }
          }
          play() {
              if (this._state === Animation.STATES.PAUSED) {
                  this._state = Animation.STATES.PLAYING;
                  this.checkActive();
                  this.emit('resume');
              } else if (this._state == Animation.STATES.STOPPING && this.settings.stopMethod == AnimationSettings.STOP_METHODS.REVERSE) {
                  this._state = Animation.STATES.PLAYING;
                  this.emit('stopContinue');
              } else if (this._state != Animation.STATES.PLAYING && this._state != Animation.STATES.FINISHED) {
                  this.start();
              }
          }
          pause() {
              if (this._state === Animation.STATES.PLAYING) {
                  this._state = Animation.STATES.PAUSED;
                  this.emit('pause');
              }
          }
          replay() {
              if (this._state == Animation.STATES.FINISHED) {
                  this.start();
              } else {
                  this.play();
              }
          }
          skipDelay() {
              this._delayLeft = 0;
              this._stopDelayLeft = 0;
          }
          finish() {
              if (this._state === Animation.STATES.PLAYING) {
                  this._delayLeft = 0;
                  this._p = 1;
              } else if (this._state === Animation.STATES.STOPPING) {
                  this._stopDelayLeft = 0;
                  this._p = 0;
              }
          }
          stop() {
              if (this._state === Animation.STATES.STOPPED || this._state === Animation.STATES.IDLE) return;
              this._stopDelayLeft = this.settings.stopDelay || 0;
              if (((this.settings.stopMethod === AnimationSettings.STOP_METHODS.IMMEDIATE) && !this._stopDelayLeft) || this._delayLeft > 0) {
                  this._state = Animation.STATES.STOPPING;
                  this.emit('stop');
              } else {
                  if (this.settings.stopMethod === AnimationSettings.STOP_METHODS.FADE) {
                      this._stopP = 0;
                  }
                  this._state = Animation.STATES.STOPPING;
                  this.emit('stop');
              }
              this.checkActive();
          }
          stopNow() {
              if (this._state !== Animation.STATES.STOPPED || this._state !== Animation.STATES.IDLE) {
                  this._state = Animation.STATES.STOPPING;
                  this._p = 0;
                  this.emit('stop');
                  this.reset();
                  this._state = Animation.STATES.STOPPED;
                  this.emit('stopFinish');
              }
          }
          isPaused() {
              return this._state === Animation.STATES.PAUSED;
          }
          isPlaying() {
              return this._state === Animation.STATES.PLAYING;
          }
          isStopping() {
              return this._state === Animation.STATES.STOPPING;
          }
          isFinished() {
              return this._state === Animation.STATES.FINISHED;
          }
          checkActive() {
              if (this.isActive()) {
                  this.manager.addActive(this);
              }
          }
          isActive() {
              return (this._state == Animation.STATES.PLAYING || this._state == Animation.STATES.STOPPING) && this._element && this._element.attached;
          }
          progress(dt) {
              if (!this._element) return;
              this._progress(dt);
              this.apply();
          }
          _progress(dt) {
              if (this._state == Animation.STATES.STOPPING) {
                  this._stopProgress(dt);
                  return;
              }
              if (this._state != Animation.STATES.PLAYING) {
                  return;
              }
              if (this._delayLeft > 0) {
                  this._delayLeft -= dt;
                  if (this._delayLeft < 0) {
                      dt = -this._delayLeft;
                      this._delayLeft = 0;
                      this.emit('delayEnd');
                  } else {
                      return;
                  }
              }
              if (this.settings.duration === 0) {
                  this._p = 1;
              } else if (this.settings.duration > 0) {
                  this._p += dt / this.settings.duration;
              }
              if (this._p >= 1) {
                  if (this.settings.repeat == -1 || this._repeatsLeft > 0) {
                      if (this._repeatsLeft > 0) {
                          this._repeatsLeft--;
                      }
                      this._p = this.settings.repeatOffset;
                      this.emit('progress', this._p);
                      if (this.settings.repeatDelay) {
                          this._delayLeft = this.settings.repeatDelay;
                      }
                      this.emit('repeat', this._repeatsLeft);
                  } else {
                      this._p = 1;
                      this.emit('progress', this._p);
                      this._state = Animation.STATES.FINISHED;
                      this.emit('finish');
                      if (this.settings.autostop) {
                          this.stop();
                      }
                  }
              } else {
                  this.emit('progress', this._p);
              }
          }
          _stopProgress(dt) {
              let duration = this._getStopDuration();
              if (this._stopDelayLeft > 0) {
                  this._stopDelayLeft -= dt;
                  if (this._stopDelayLeft < 0) {
                      dt = -this._stopDelayLeft;
                      this._stopDelayLeft = 0;
                      this.emit('stopDelayEnd');
                  } else {
                      return;
                  }
              }
              if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.IMMEDIATE) {
                  this._state = Animation.STATES.STOPPED;
                  this.emit('stopFinish');
              } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.REVERSE) {
                  if (duration === 0) {
                      this._p = 0;
                  } else if (duration > 0) {
                      this._p -= dt / duration;
                  }
                  if (this._p <= 0) {
                      this._p = 0;
                      this._state = Animation.STATES.STOPPED;
                      this.emit('stopFinish');
                  }
              } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FADE) {
                  this._progressStopTransition(dt);
                  if (this._stopP >= 1) {
                      this._p = 0;
                      this._state = Animation.STATES.STOPPED;
                      this.emit('stopFinish');
                  }
              } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.ONETOTWO) {
                  if (this._p < 2) {
                      if (duration === 0) {
                          this._p = 2;
                      } else if (duration > 0) {
                          if (this._p < 1) {
                              this._p += dt / this.settings.duration;
                          } else {
                              this._p += dt / duration;
                          }
                      }
                      if (this._p >= 2) {
                          this._p = 2;
                          this._state = Animation.STATES.STOPPED;
                          this.emit('stopFinish');
                      } else {
                          this.emit('progress', this._p);
                      }
                  }
              } else if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FORWARD) {
                  if (this._p < 1) {
                      if (this.settings.duration == 0) {
                          this._p = 1;
                      } else {
                          this._p += dt / this.settings.duration;
                      }
                      if (this._p >= 1) {
                          if (this.settings.stopMethod == AnimationSettings.STOP_METHODS.FORWARD) {
                              this._p = 1;
                              this._state = Animation.STATES.STOPPED;
                              this.emit('stopFinish');
                          } else {
                              if (this._repeatsLeft > 0) {
                                  this._repeatsLeft--;
                                  this._p = 0;
                                  this.emit('repeat', this._repeatsLeft);
                              } else {
                                  this._p = 1;
                                  this._state = Animation.STATES.STOPPED;
                                  this.emit('stopFinish');
                              }
                          }
                      } else {
                          this.emit('progress', this._p);
                      }
                  }
              }
          }
          _progressStopTransition(dt) {
              if (this._stopP < 1) {
                  if (this._stopDelayLeft > 0) {
                      this._stopDelayLeft -= dt;
                      if (this._stopDelayLeft < 0) {
                          dt = -this._stopDelayLeft;
                          this._stopDelayLeft = 0;
                          this.emit('delayEnd');
                      } else {
                          return;
                      }
                  }
                  const duration = this._getStopDuration();
                  if (duration == 0) {
                      this._stopP = 1;
                  } else {
                      this._stopP += dt / duration;
                  }
                  if (this._stopP >= 1) {
                      this._stopP = 1;
                  }
              }
          }
          _getStopDuration() {
              return this.settings.stopDuration || this.settings.duration;
          }
          apply() {
              if (this._state === Animation.STATES.STOPPED) {
                  this.reset();
              } else {
                  let factor = 1;
                  if (this._state === Animation.STATES.STOPPING && this.settings.stopMethod === AnimationSettings.STOP_METHODS.FADE) {
                      factor = (1 - this.settings.stopTimingFunctionImpl(this._stopP));
                  }
                  this._settings.apply(this._element, this._p, factor);
              }
          }
          reset() {
              this._settings.reset(this._element);
          }
          get state() {
              return this._state;
          }
          get p() {
              return this._p;
          }
          get delayLeft() {
              return this._delayLeft;
          }
          get element() {
              return this._element;
          }
          get frame() {
              return Math.round(this._p * this._settings.duration * 60);
          }
          get settings() {
              return this._settings;
          }
      }
      Animation.STATES = {
          IDLE: 0,
          PLAYING: 1,
          STOPPING: 2,
          STOPPED: 3,
          FINISHED: 4,
          PAUSED: 5
      };

      class AnimationManager {
          constructor(stage) {
              this.stage = stage;
              this.stage.on('frameStart', () => this.progress());
              this.active = new Set();
          }
          progress() {
              if (this.active.size) {
                  let dt = this.stage.dt;
                  let filter = false;
                  this.active.forEach(function(a) {
                      if (a.isActive()) {
                          a.progress(dt);
                      } else {
                          filter = true;
                      }
                  });
                  if (filter) {
                      this.active = new Set([...this.active].filter(t => t.isActive()));
                  }
              }
          }
          createAnimation(element, settings) {
              if (Utils.isObjectLiteral(settings)) {
                  settings = this.createSettings(settings);
              }
              return new Animation(
                  this,
                  settings,
                  element
              );
          }
          createSettings(settings) {
              const animationSettings = new AnimationSettings();
              Base.patchObject(animationSettings, settings);
              return animationSettings;
          }
          addActive(transition) {
              this.active.add(transition);
          }
      }

      class RectangleTexture extends Texture {
          _getLookupId() {
              return '__whitepix';
          }
          _getSourceLoader() {
              return function(cb) {
                  var whitePixel = new Uint8Array([255, 255, 255, 255]);
                  cb(null, {source: whitePixel, w: 1, h: 1, permanent: true});
              }
          }
          isAutosizeTexture() {
              return false;
          }
      }

      class Stage extends EventEmitter {
          constructor(options = {}) {
              super();
              this._setOptions(options);
              this._usedMemory = 0;
              this._lastGcFrame = 0;
              const platformType = Stage.platform ? Stage.platform : PlatformLoader.load(options);
              this.platform = new platformType();
              if (this.platform.init) {
                  this.platform.init(this);
              }
              this.gl = null;
              this.c2d = null;
              const context = this.getOption('context');
              if (context) {
                  if (context.useProgram) {
                      this.gl = context;
                  } else {
                      this.c2d = context;
                  }
              } else {
                  if (Utils.isWeb && (!Stage.isWebglSupported() || this.getOption('canvas2d'))) {
                      this.c2d = this.platform.createCanvasContext(this.getOption('w'), this.getOption('h'));
                  } else {
                      this.gl = this.platform.createWebGLContext(this.getOption('w'), this.getOption('h'));
                  }
              }
              if (this.gl) {
                  WebGLStateManager.enable(this.gl, "lightning");
              }
              this._mode = this.gl ? 0 : 1;
              if (this.getCanvas()) {
                  this._options.w = this.getCanvas().width;
                  this._options.h = this.getCanvas().height;
              }
              if (this._mode === 0) {
                  if (Utils.isSpark) {
                      this._renderer = new SparkRenderer(this);
                  } else {
                      this._renderer = new WebGLRenderer(this);
                  }
              } else {
                  this._renderer = new C2dRenderer(this);
              }
              this.setClearColor(this.getOption('clearColor'));
              this.frameCounter = 0;
              this.transitions = new TransitionManager(this);
              this.animations = new AnimationManager(this);
              this.textureManager = new TextureManager(this);
              this.textureThrottler = new TextureThrottler(this);
              this.startTime = 0;
              this.currentTime = 0;
              this.dt = 0;
              this.rectangleTexture = new RectangleTexture(this);
              this.rectangleTexture.load();
              this.rectangleTexture.source.permanent = true;
              this.ctx = new CoreContext(this);
              this._updateSourceTextures = new Set();
          }
          get renderer() {
              return this._renderer;
          }
          static isWebglSupported() {
              if (Utils.isNode) {
                  return true;
              }
              try {
                  return !!window.WebGLRenderingContext;
              } catch(e) {
                  return false;
              }
          }
          get mode() {
              return this._mode;
          }
          isWebgl() {
              return this.mode === 0;
          }
          isC2d() {
              return this.mode === 1;
          }
          getOption(name) {
              return this._options[name];
          }
          _setOptions(o) {
              this._options = {};
              let opt = (name, def) => {
                  let value = o[name];
                  if (value === undefined) {
                      this._options[name] = def;
                  } else {
                      this._options[name] = value;
                  }
              };
              opt('canvas', null);
              opt('context', null);
              opt('w', 1920);
              opt('h', 1080);
              opt('srcBasePath', null);
              opt('memoryPressure', 24e6);
              opt('bufferMemory', 2e6);
              opt('textRenderIssueMargin', 0);
              opt('clearColor', [0, 0, 0, 0]);
              opt('defaultFontFace', 'sans-serif');
              opt('fixedDt', 0);
              opt('useImageWorker', true);
              opt('autostart', true);
              opt('precision', 1);
              opt('canvas2d', false);
              opt('platform', null);
              opt('readPixelsBeforeDraw', false);
          }
          setApplication(app) {
              this.application = app;
          }
          init() {
              if (this.application.getOption('debug') && this.platform._imageWorker) {
                  console.log('[Lightning] Using image worker!');
              }
              if (this.application.getOption('debug') && this.c2d) {
                  console.log('[Lightning] Using canvas2d renderer');
              }
              this.application.setAsRoot();
              if (this.getOption('autostart')) {
                  this.platform.startLoop();
              }
          }
          destroy() {
              this.platform.stopLoop();
              this.platform.destroy();
              this.ctx.destroy();
              this.textureManager.destroy();
              this._renderer.destroy();
          }
          stop() {
              this.platform.stopLoop();
          }
          resume() {
              this.platform.startLoop();
          }
          get root() {
              return this.application;
          }
          getCanvas() {
              return this._mode ? this.c2d.canvas : this.gl.canvas;
          }
          getRenderPrecision() {
              return this._options.precision;
          }
          addUpdateSourceTexture(texture) {
              if (this._updatingFrame) {
                  texture._performUpdateSource();
              } else {
                  this._updateSourceTextures.add(texture);
              }
          }
          removeUpdateSourceTexture(texture) {
              if (this._updateSourceTextures) {
                  this._updateSourceTextures.delete(texture);
              }
          }
          hasUpdateSourceTexture(texture) {
              return (this._updateSourceTextures && this._updateSourceTextures.has(texture));
          }
          drawFrame() {
              this.startTime = this.currentTime;
              this.currentTime = this.platform.getHrTime();
              if (this._options.fixedDt) {
                  this.dt = this._options.fixedDt;
              } else {
                  this.dt = (!this.startTime) ? .02 : .001 * (this.currentTime - this.startTime);
              }
              this.emit('frameStart');
              if (this._updateSourceTextures.size) {
                  this._updateSourceTextures.forEach(texture => {
                      texture._performUpdateSource();
                  });
                  this._updateSourceTextures = new Set();
              }
              this.emit('update');
              const changes = this.ctx.hasRenderUpdates();
              this.textureThrottler.processSome();
              if (changes) {
                  this._updatingFrame = true;
                  this.ctx.update();
                  this.ctx.render();
                  this._updatingFrame = false;
              }
              this.platform.nextFrame(changes);
              this.emit('frameEnd');
              this.frameCounter++;
          }
          isUpdatingFrame() {
              return this._updatingFrame;
          }
          renderFrame() {
              this.ctx.frame();
          }
          forceRenderUpdate() {
              if (this.root) {
                  this.root.core._parent.setHasRenderUpdates(1);
              }
          }
          setClearColor(clearColor) {
              this.forceRenderUpdate();
              if (clearColor === null) {
                  this._clearColor = null;
              } else if (Array.isArray(clearColor)) {
                  this._clearColor = clearColor;
              } else {
                  this._clearColor = StageUtils.getRgbaComponentsNormalized(clearColor);
              }
          }
          getClearColor() {
              return this._clearColor;
          }
          createElement(settings) {
              if (settings) {
                  return this.element(settings);
              } else {
                  return new Element(this);
              }
          }
          createShader(settings) {
              return Shader.create(this, settings);
          }
          element(settings) {
              if (settings.isElement) return settings;
              let element;
              if (settings.type) {
                  element = new settings.type(this);
              } else {
                  element = new Element(this);
              }
              element.patch(settings);
              return element;
          }
          c(settings) {
              return this.element(settings);
          }
          get w() {
              return this._options.w;
          }
          get h() {
              return this._options.h;
          }
          get coordsWidth() {
              return this.w / this._options.precision;
          }
          get coordsHeight() {
              return this.h / this._options.precision;
          }
          addMemoryUsage(delta) {
              this._usedMemory += delta;
              if (this._lastGcFrame !== this.frameCounter) {
                  if (this._usedMemory > this.getOption('memoryPressure')) {
                      this.gc(false);
                      if (this._usedMemory > this.getOption('memoryPressure') - 2e6) {
                          this.gc(true);
                      }
                  }
              }
          }
          get usedMemory() {
              return this._usedMemory;
          }
          gc(aggressive) {
              if (this._lastGcFrame !== this.frameCounter) {
                  this._lastGcFrame = this.frameCounter;
                  const memoryUsageBefore = this._usedMemory;
                  this.gcTextureMemory(aggressive);
                  this.gcRenderTextureMemory(aggressive);
                  this.renderer.gc(aggressive);
                  if (this.application.getOption('debug')) {
                      console.log(`[Lightning] GC${aggressive ? "[aggressive]" : ""}! Frame ${this._lastGcFrame} Freed ${((memoryUsageBefore - this._usedMemory) / 1e6).toFixed(2)}MP from GPU memory. Remaining: ${(this._usedMemory / 1e6).toFixed(2)}MP`);
                      const other = this._usedMemory - this.textureManager.usedMemory - this.ctx.usedMemory;
                      console.log(`[Lightning] Textures: ${(this.textureManager.usedMemory / 1e6).toFixed(2)}MP, Render Textures: ${(this.ctx.usedMemory / 1e6).toFixed(2)}MP, Renderer caches: ${(other / 1e6).toFixed(2)}MP`);
                  }
              }
          }
          gcTextureMemory(aggressive = false) {
              if (aggressive && this.ctx.root.visible) {
                  this.ctx.root.visible = false;
                  this.textureManager.gc();
                  this.ctx.root.visible = true;
              } else {
                  this.textureManager.gc();
              }
          }
          gcRenderTextureMemory(aggressive = false) {
              if (aggressive && this.root.visible) {
                  this.root.visible = false;
                  this.ctx.freeUnusedRenderTextures(0);
                  this.root.visible = true;
              } else {
                  this.ctx.freeUnusedRenderTextures(0);
              }
          }
          getDrawingCanvas() {
              return this.platform.getDrawingCanvas();
          }
          update() {
              this.ctx.update();
          }
          addServiceProvider(serviceprovider) {
              if (Utils.isSpark) {
                  this.platform.addServiceProvider(serviceprovider);
              }
          }
          getChildrenByPosition(x, y){
              const children = [];
              this.root.core.update();
              this.root.core.collectAtCoord(x,y,children);
              return children;
          }
      }

      class Application extends Component {
          constructor(options = {}, properties) {
              Application._temp_options = options;
              Application.booting = true;
              const stage = new Stage(options.stage);
              super(stage, properties);
              Application.booting = false;
              this.__updateFocusCounter = 0;
              this.__keypressTimers = new Map();
              this.stage.init();
              this.updateFocusSettings();
              this.__keymap = this.getOption('keys');
              if (this.__keymap) {
                  this.stage.platform.registerKeydownHandler((e) => {
                      this._receiveKeydown(e);
                  });
                  this.stage.platform.registerKeyupHandler((e) => {
                      this._receiveKeyup(e);
                  });
              }
          }
          getOption(name) {
              return this.__options[name];
          }
          _setOptions(o) {
              this.__options = {};
              let opt = (name, def) => {
                  let value = o[name];
                  if (value === undefined) {
                      this.__options[name] = def;
                  } else {
                      this.__options[name] = value;
                  }
              };
              opt('debug', false);
              opt('keys', {
                  38: "Up",
                  40: "Down",
                  37: "Left",
                  39: "Right",
                  13: "Enter",
                  8: "Back",
                  27: "Exit"
              });
          }
          __construct() {
              this.stage.setApplication(this);
              this._setOptions(Application._temp_options);
              delete Application._temp_options;
              super.__construct();
          }
          __init() {
              super.__init();
              this.__updateFocus();
          }
          updateFocusPath() {
              this.__updateFocus();
          }
          __updateFocus() {
              const notOverridden = this.__updateFocusRec();
              if (!Application.booting && notOverridden) {
                  this.updateFocusSettings();
              }
          }
          __updateFocusRec() {
              const updateFocusId = ++this.__updateFocusCounter;
              this.__updateFocusId = updateFocusId;
              const newFocusPath = this.__getFocusPath();
              const newFocusedComponent = newFocusPath[newFocusPath.length - 1];
              const prevFocusedComponent = this._focusPath ? this._focusPath[this._focusPath.length - 1] : undefined;
              if (!prevFocusedComponent) {
                  this._focusPath = [];
                  for (let i = 0, n = newFocusPath.length; i < n; i++) {
                      this._focusPath.push(newFocusPath[i]);
                      this._focusPath[i]._focus(newFocusedComponent, undefined);
                      const focusOverridden = (this.__updateFocusId !== updateFocusId);
                      if (focusOverridden) {
                          return false;
                      }
                  }
                  return true;
              } else {
                  let m = Math.min(this._focusPath.length, newFocusPath.length);
                  let index;
                  for (index = 0; index < m; index++) {
                      if (this._focusPath[index] !== newFocusPath[index]) {
                          break;
                      }
                  }
                  if (this._focusPath.length !== newFocusPath.length || index !== newFocusPath.length) {
                      for (let i = this._focusPath.length - 1; i >= index; i--) {
                          const unfocusedElement = this._focusPath.pop();
                          unfocusedElement._unfocus(newFocusedComponent, prevFocusedComponent);
                          const focusOverridden = (this.__updateFocusId !== updateFocusId);
                          if (focusOverridden) {
                              return false;
                          }
                      }
                      for (let i = index, n = newFocusPath.length; i < n; i++) {
                          this._focusPath.push(newFocusPath[i]);
                          this._focusPath[i]._focus(newFocusedComponent, prevFocusedComponent);
                          const focusOverridden = (this.__updateFocusId !== updateFocusId);
                          if (focusOverridden) {
                              return false;
                          }
                      }
                      for (let i = 0; i < index; i++) {
                          this._focusPath[i]._focusChange(newFocusedComponent, prevFocusedComponent);
                      }
                  }
              }
              return true;
          }
          updateFocusSettings() {
              const focusedComponent = this._focusPath[this._focusPath.length - 1];
              const focusSettings = {};
              const defaultSetFocusSettings = Component.prototype._setFocusSettings;
              for (let i = 0, n = this._focusPath.length; i < n; i++) {
                  if (this._focusPath[i]._setFocusSettings !== defaultSetFocusSettings) {
                      this._focusPath[i]._setFocusSettings(focusSettings);
                  }
              }
              const defaultHandleFocusSettings = Component.prototype._handleFocusSettings;
              for (let i = 0, n = this._focusPath.length; i < n; i++) {
                  if (this._focusPath[i]._handleFocusSettings !== defaultHandleFocusSettings) {
                      this._focusPath[i]._handleFocusSettings(focusSettings, this.__prevFocusSettings, focusedComponent);
                  }
              }
              this.__prevFocusSettings = focusSettings;
          }
          _handleFocusSettings(settings, prevSettings, focused, prevFocused) {
          }
          __getFocusPath() {
              const path = [this];
              let current = this;
              do {
                  const nextFocus = current._getFocused();
                  if (!nextFocus || (nextFocus === current)) {
                      break;
                  }
                  let ptr = nextFocus.cparent;
                  if (ptr === current) {
                      path.push(nextFocus);
                  } else {
                      const newParts = [nextFocus];
                      do {
                          if (!ptr) {
                              current._throwError("Return value for _getFocused must be an attached descendant component but its '" + nextFocus.getLocationString() + "'");
                          }
                          newParts.push(ptr);
                          ptr = ptr.cparent;
                      } while (ptr !== current);
                      for (let i = 0, n = newParts.length; i < n; i++) {
                          path.push(newParts[n - i - 1]);
                      }
                  }
                  current = nextFocus;
              } while(true);
              return path;
          }
          get focusPath() {
              return this._focusPath;
          }
          focusTopDownEvent(events, ...args) {
              const path = this.focusPath;
              const n = path.length;
              for (let i = 0; i < n; i++) {
                  const event = path[i]._getMostSpecificHandledMember(events);
                  if (event !== undefined) {
                      const returnValue = path[i][event](...args);
                      if (returnValue !== false) {
                          return true;
                      }
                  }
              }
              return false;
          }
          focusBottomUpEvent(events, ...args) {
              const path = this.focusPath;
              const n = path.length;
              for (let i = n - 1; i >= 0; i--) {
                  const event = path[i]._getMostSpecificHandledMember(events);
                  if (event !== undefined) {
                      const returnValue = path[i][event](...args);
                      if (returnValue !== false) {
                          return true;
                      }
                  }
              }
              return false;
          }
          _receiveKeydown(e) {
              const obj = e;
              const key = this.__keymap[e.keyCode];
              const path = this.focusPath;
              let keys;
              if (key) {
                  keys = Array.isArray(key) ? key : [key];
              }
              if (keys) {
                  for (let i = 0, n = keys.length; i < n; i++) {
                      const hasTimer = this.__keypressTimers.has(keys[i]);
                      if (path[path.length - 1].longpress && hasTimer) {
                          return;
                      }
                      if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}`, "_captureKey"], obj)) {
                          this.stage.application.focusBottomUpEvent([`_handle${keys[i]}`, "_handleKey"], obj);
                      }
                  }
              } else {
                  if (!this.stage.application.focusTopDownEvent(["_captureKey"], obj)) {
                      this.stage.application.focusBottomUpEvent(["_handleKey"], obj);
                  }
              }
              this.updateFocusPath();
              const consumer = path[path.length - 1];
              if (keys && consumer.longpress) {
                  for (let i = 0, n = keys.length; i < n; i++) {
                      this._startLongpressTimer(keys[i], consumer);
                  }
              }
          }
          _receiveKeyup(e) {
              const obj = e;
              const key = this.__keymap[e.keyCode];
              let keys;
              if (key) {
                  keys = Array.isArray(key) ? key : [key];
              }
              if (keys) {
                  for (let i = 0, n = keys.length; i < n; i++) {
                      if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}Release`, "_captureKeyRelease"], obj)) {
                          this.stage.application.focusBottomUpEvent([`_handle${keys[i]}Release`, "_handleKeyRelease"], obj);
                      }
                  }
              } else {
                  if (!this.stage.application.focusTopDownEvent(["_captureKeyRelease"], obj)) {
                      this.stage.application.focusBottomUpEvent(["_handleKeyRelease"], obj);
                  }
              }
              this.updateFocusPath();
              if (keys) {
                  for (let i = 0, n = keys.length; i < n; i++) {
                      if (this.__keypressTimers.has(keys[i])) {
                          clearTimeout(this.__keypressTimers.get(keys[i]));
                          this.__keypressTimers.delete(keys[i]);
                      }
                  }
              }
          }
          _startLongpressTimer(key, element) {
              const config = element.longpress;
              const lookup = key.toLowerCase();
              if (config[lookup]) {
                  const timeout = config[lookup];
                  if (!Utils.isNumber(timeout)) {
                      element._throwError("config value for longpress must be a number");
                  } else {
                      this.__keypressTimers.set(key, setTimeout(() => {
                          if (!this.stage.application.focusTopDownEvent([`_capture${key}Long`, "_captureKey"], {})) {
                              this.stage.application.focusBottomUpEvent([`_handle${key}Long`, "_handleKey"], {});
                          }
                          this.__keypressTimers.delete(key);
                      }, timeout || 500 ));
                  }
              }
              return;
          }
          destroy() {
              if (!this._destroyed) {
                  this._destroy();
                  this.stage.destroy();
                  this._destroyed = true;
              }
          }
          _destroy() {
              this.stage.setApplication(undefined);
              this._updateAttachedFlag();
              this._updateEnabledFlag();
              if (this.__keypressTimers.size) {
                  for (const timer of this.__keypressTimers.values()) {
                      clearTimeout(timer);
                  }
                  this.__keypressTimers.clear();
              }
          }
          getCanvas() {
              return this.stage.getCanvas();
          }
      }

      class StaticCanvasTexture extends Texture {
          constructor(stage) {
              super(stage);
              this._factory = undefined;
              this._lookupId = undefined;
          }
          set content({factory, lookupId = undefined}) {
              this._factory = factory;
              this._lookupId = lookupId;
              this._changed();
          }
          _getIsValid() {
              return !!this._factory;
          }
          _getLookupId() {
              return this._lookupId;
          }
          _getSourceLoader() {
              const f = this._factory;
              return (cb) => {
                  return f((err, canvas) => {
                      if (err) {
                          return cb(err);
                      }
                      cb(null, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas));
                  }, this.stage);
              }
          }
      }

      class Tools {
          static getCanvasTexture(canvasFactory, lookupId) {
              return {type: StaticCanvasTexture, content: {factory: canvasFactory, lookupId: lookupId}}
          }
          static getRoundRect(w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
              if (!Array.isArray(radius)){
                  radius = [radius, radius, radius, radius];
              }
              let factory = (cb, stage) => {
                  if (Utils.isSpark) {
                      stage.platform.createRoundRect(cb, stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor);
                  } else {
                      cb(null, this.createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor));
                  }
              };
              let id = 'rect' + [w, h, strokeWidth, strokeColor, fill ? 1 : 0, fillColor].concat(radius).join(",");
              return Tools.getCanvasTexture(factory, id);
          }
          static createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
              if (fill === undefined) fill = true;
              if (strokeWidth === undefined) strokeWidth = 0;
              let canvas = stage.platform.getDrawingCanvas();
              let ctx = canvas.getContext('2d');
              ctx.imageSmoothingEnabled = true;
              canvas.width = w + strokeWidth + 2;
              canvas.height = h + strokeWidth + 2;
              ctx.beginPath();
              let x = 0.5 * strokeWidth + 1, y = 0.5 * strokeWidth + 1;
              ctx.moveTo(x + radius[0], y);
              ctx.lineTo(x + w - radius[1], y);
              ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
              ctx.lineTo(x + w, y + h - radius[2]);
              ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
              ctx.lineTo(x + radius[3], y + h);
              ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
              ctx.lineTo(x, y + radius[0]);
              ctx.arcTo(x, y, x + radius[0], y, radius[0]);
              ctx.closePath();
              if (fill) {
                  if (Utils.isNumber(fillColor)) {
                      ctx.fillStyle = StageUtils.getRgbaString(fillColor);
                  } else {
                      ctx.fillStyle = "white";
                  }
                  ctx.fill();
              }
              if (strokeWidth) {
                  if (Utils.isNumber(strokeColor)) {
                      ctx.strokeStyle = StageUtils.getRgbaString(strokeColor);
                  } else {
                      ctx.strokeStyle = "white";
                  }
                  ctx.lineWidth = strokeWidth;
                  ctx.stroke();
              }
              return canvas;
          }
          static getShadowRect(w, h, radius = 0, blur = 5, margin = blur * 2) {
              if (!Array.isArray(radius)){
                  radius = [radius, radius, radius, radius];
              }
              let factory = (cb, stage) => {
                  if (Utils.isSpark) {
                      stage.platform.createShadowRect(cb, stage, w, h, radius, blur, margin);
                  } else {
                      cb(null, this.createShadowRect(stage, w, h, radius, blur, margin));
                  }
              };
              let id = 'shadow' + [w, h, blur, margin].concat(radius).join(",");
              return Tools.getCanvasTexture(factory, id);
          }
          static createShadowRect(stage, w, h, radius, blur, margin) {
              let canvas = stage.platform.getDrawingCanvas();
              let ctx = canvas.getContext('2d');
              ctx.imageSmoothingEnabled = true;
              canvas.width = w + margin * 2;
              canvas.height = h + margin * 2;
              ctx.globalAlpha = 0.01;
              ctx.fillRect(0, 0, 0.01, 0.01);
              ctx.globalAlpha = 1.0;
              ctx.shadowColor = StageUtils.getRgbaString(0xFFFFFFFF);
              ctx.fillStyle = StageUtils.getRgbaString(0xFFFFFFFF);
              ctx.shadowBlur = blur;
              ctx.shadowOffsetX = (w + 10) + margin;
              ctx.shadowOffsetY = margin;
              ctx.beginPath();
              const x = -(w + 10);
              const y = 0;
              ctx.moveTo(x + radius[0], y);
              ctx.lineTo(x + w - radius[1], y);
              ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
              ctx.lineTo(x + w, y + h - radius[2]);
              ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
              ctx.lineTo(x + radius[3], y + h);
              ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
              ctx.lineTo(x, y + radius[0]);
              ctx.arcTo(x, y, x + radius[0], y, radius[0]);
              ctx.closePath();
              ctx.fill();
              return canvas;
          }
          static getSvgTexture(url, w, h) {
              let factory = (cb, stage) => {
                  if (Utils.isSpark) {
                      stage.platform.createSvg(cb, stage, url, w, h);
                  } else {
                      this.createSvg(cb, stage, url, w, h);
                  }
              };
              let id = 'svg' + [w, h, url].join(",");
              return Tools.getCanvasTexture(factory, id);
          }
          static createSvg(cb, stage, url, w, h) {
              console.log('createsvg')
              let canvas = stage.platform.getDrawingCanvas();
              let ctx = canvas.getContext('2d');
              ctx.imageSmoothingEnabled = true;
              let img = new Image();
              img.onload = () => {
                  canvas.width = w;
                  canvas.height = h;
                  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                  cb(null, canvas);
              };
              img.onError = (err) => {
                  cb(err);
              };
              if (!Utils.isPS4) {
                  img.crossOrigin = "Anonymous";
              }
              img.src = url;
          }
      }

      class ObjMerger {
          static isMf(f) {
              return Utils.isFunction(f) && f.__mf;
          }
          static mf(f) {
              f.__mf = true;
              return f;
          }
          static merge(a, b) {
              const aks = Object.keys(a);
              const bks = Object.keys(b);
              if (!bks.length) {
                  return a;
              }
              const ai = {};
              const bi = {};
              for (let i = 0, n = bks.length; i < n; i++) {
                  const key = bks[i];
                  ai[key] = -1;
                  bi[key] = i;
              }
              for (let i = 0, n = aks.length; i < n; i++) {
                  const key = aks[i];
                  ai[key] = i;
                  if (bi[key] === undefined) {
                      bi[key] = -1;
                  }
              }
              const aksl = aks.length;
              const result = {};
              for (let i = 0, n = bks.length; i < n; i++) {
                  const key = bks[i];
                  const aIndex = ai[key];
                  let curIndex = aIndex;
                  while(--curIndex >= 0) {
                      const akey = aks[curIndex];
                      if (bi[akey] !== -1) {
                          break;
                      }
                  }
                  while(++curIndex < aIndex) {
                      const akey = aks[curIndex];
                      result[akey] = a[akey];
                  }
                  const bv = b[key];
                  const av = a[key];
                  let r;
                  if (this.isMf(bv)) {
                      r = bv(av);
                  } else {
                      if (!Utils.isObjectLiteral(av) || !Utils.isObjectLiteral(bv)) {
                          r = bv;
                      } else {
                          r = ObjMerger.merge(av, bv);
                      }
                  }
                  if (r !== undefined) {
                      result[key] = r;
                  }
              }
              let curIndex = aksl;
              while(--curIndex >= 0) {
                  const akey = aks[curIndex];
                  if (bi[akey] !== -1) {
                      break;
                  }
              }
              while(++curIndex < aksl) {
                  const akey = aks[curIndex];
                  result[akey] = a[akey];
              }
              return result;
          }
      }

      class ObjectListProxy extends ObjectList {
          constructor(target) {
              super();
              this._target = target;
          }
          onAdd(item, index) {
              this._target.addAt(item, index);
          }
          onRemove(item, index) {
              this._target.removeAt(index);
          }
          onSync(removed, added, order) {
              this._target._setByArray(order);
          }
          onSet(item, index) {
              this._target.setAt(item, index);
          }
          onMove(item, fromIndex, toIndex) {
              this._target.setAt(item, toIndex);
          }
          createItem(object) {
              return this._target.createItem(object);
          }
          isItem(object) {
              return this._target.isItem(object);
          }
      }

      class ObjectListWrapper extends ObjectListProxy {
          constructor(target, wrap) {
              super(target);
              this._wrap = wrap;
          }
          wrap(item) {
              let wrapper = this._wrap(item);
              item._wrapper = wrapper;
              return wrapper;
          }
          onAdd(item, index) {
              item = this.wrap(item);
              super.onAdd(item, index);
          }
          onRemove(item, index) {
              super.onRemove(item, index);
          }
          onSync(removed, added, order) {
              added.forEach(a => this.wrap(a));
              order = order.map(a => a._wrapper);
              super.onSync(removed, added, order);
          }
          onSet(item, index) {
              item = this.wrap(item);
              super.onSet(item, index);
          }
          onMove(item, fromIndex, toIndex) {
              super.onMove(item, fromIndex, toIndex);
          }
      }

      class NoiseTexture extends Texture {
          _getLookupId() {
              return '__noise';
          }
          _getSourceLoader() {
              const gl = this.stage.gl;
              return function(cb) {
                  const noise = new Uint8Array(128 * 128 * 4);
                  for (let i = 0; i < 128 * 128 * 4; i+=4) {
                      const v = Math.floor(Math.random() * 256);
                      noise[i] = v;
                      noise[i+1] = v;
                      noise[i+2] = v;
                      noise[i+3] = 255;
                  }
                  const texParams = {};
                  if (gl) {
                      texParams[gl.TEXTURE_WRAP_S] = gl.REPEAT;
                      texParams[gl.TEXTURE_WRAP_T] = gl.REPEAT;
                      texParams[gl.TEXTURE_MIN_FILTER] = gl.NEAREST;
                      texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
                  }
                  cb(null, {source: noise, w: 128, h: 128, texParams: texParams});
              }
          }
      }

      class HtmlTexture extends Texture {
          constructor(stage) {
              super(stage);
              this._htmlElement = undefined;
              this._scale = 1;
          }
          set htmlElement(v) {
              this._htmlElement = v;
              this._changed();
          }
          get htmlElement() {
              return this._htmlElement;
          }
          set scale(v) {
              this._scale = v;
              this._changed();
          }
          get scale() {
              return this._scale;
          }
          set html(v) {
              if (!v) {
                  this.htmlElement = undefined;
              } else {
                  const d = document.createElement('div');
                  d.innerHTML = "<div>" + v + "</div>";
                  this.htmlElement = d.firstElementChild;
              }
          }
          get html() {
              return this._htmlElement.innerHTML;
          }
          _getIsValid() {
              return this.htmlElement;
          }
          _getLookupId() {
              return this._scale + ":" + this._htmlElement.innerHTML;
          }
          _getSourceLoader() {
              console.log('htmltexture loader')
              const htmlElement = this._htmlElement;
              const scale = this._scale;
              return function(cb) {
                  if (!window.html2canvas) {
                      return cb(new Error("Please include html2canvas (https://html2canvas.hertzen.com/)"));
                  }
                  const area = HtmlTexture.getPreloadArea();
                  area.appendChild(htmlElement);
                  html2canvas(htmlElement, {backgroundColor: null, scale: scale}).then(function(canvas) {
                      area.removeChild(htmlElement);
                      if (canvas.height === 0) {
                          return cb(new Error("Canvas height is 0"));
                      }
                      cb(null, {source: canvas, width: canvas.width, height: canvas.height});
                  }).catch(e => {
                      console.error('[Lightning]', e);
                  });
              }
          }
          static getPreloadArea() {
              if (!this._preloadArea) {
                  this._preloadArea = document.createElement('div');
                  if (this._preloadArea.attachShadow) {
                      this._preloadArea.attachShadow({mode: 'closed'});
                  }
                  this._preloadArea.style.opacity = 0;
                  this._preloadArea.style.pointerEvents = 'none';
                  this._preloadArea.style.position = 'fixed';
                  this._preloadArea.style.display = 'block';
                  this._preloadArea.style.top = '100vh';
                  this._preloadArea.style.overflow = 'hidden';
                  document.body.appendChild(this._preloadArea);
              }
              return this._preloadArea;
          }
      }

      class StaticTexture extends Texture {
          constructor(stage, options) {
              super(stage);
              this._options = options;
          }
          set options(v) {
              if (this._options !== v) {
                  this._options = v;
                  this._changed();
              }
          }
          get options() {
              return this._options;
          }
          _getIsValid() {
              return !!this._options;
          }
          _getSourceLoader() {
              return (cb) => {
                  cb(null, this._options);
              }
          }
      }

      class ListComponent extends Component {
          constructor(stage) {
              super(stage);
              this._wrapper = super._children.a({});
              this._reloadVisibleElements = false;
              this._visibleItems = new Set();
              this._index = 0;
              this._started = false;
              this._scrollTransitionSettings = this.stage.transitions.createSettings({});
              this._itemSize = 100;
              this._viewportScrollOffset = 0;
              this._itemScrollOffset = 0;
              this._roll = false;
              this._rollMin = 0;
              this._rollMax = 0;
              this._progressAnimation = null;
              this._invertDirection = false;
              this._horizontal = true;
              this.itemList = new ListItems(this);
          }
          _allowChildrenAccess() {
              return false;
          }
          get items() {
              return this.itemList.get();
          }
          set items(children) {
              this.itemList.patch(children);
          }
          start() {
              this._wrapper.transition(this.property, this._scrollTransitionSettings);
              this._scrollTransition = this._wrapper.transition(this.property);
              this._scrollTransition.on('progress', p => this.update());
              this.setIndex(0, true, true);
              this._started = true;
              this.update();
          }
          setIndex(index, immediate = false, closest = false) {
              let nElements = this.length;
              if (!nElements) return;
              this.emit('unfocus', this.getElement(this.realIndex), this._index, this.realIndex);
              if (closest) {
                  let offset = Utils.getModuloIndex(index, nElements);
                  let o = Utils.getModuloIndex(this.index, nElements);
                  let diff = offset - o;
                  if (diff > 0.5 * nElements) {
                      diff -= nElements;
                  } else if (diff < -0.5 * nElements) {
                      diff += nElements;
                  }
                  this._index += diff;
              } else {
                  this._index = index;
              }
              if (this._roll || (this.viewportSize > this._itemSize * nElements)) {
                  this._index = Utils.getModuloIndex(this._index, nElements);
              }
              let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);
              let value = direction * this._index * this._itemSize;
              if (this._roll) {
                  let min, max, scrollDelta;
                  if (direction == 1) {
                      max = (nElements - 1) * this._itemSize;
                      scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;
                      max -= scrollDelta;
                      min = this.viewportSize - (this._itemSize + scrollDelta);
                      if (this._rollMin) min -= this._rollMin;
                      if (this._rollMax) max += this._rollMax;
                      value = Math.max(Math.min(value, max), min);
                  } else {
                      max = (nElements * this._itemSize - this.viewportSize);
                      scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;
                      max += scrollDelta;
                      let min = scrollDelta;
                      if (this._rollMin) min -= this._rollMin;
                      if (this._rollMax) max += this._rollMax;
                      value = Math.min(Math.max(-max, value), -min);
                  }
              }
              this._scrollTransition.start(value);
              if (immediate) {
                  this._scrollTransition.finish();
              }
              this.emit('focus', this.getElement(this.realIndex), this._index, this.realIndex);
          }
          getAxisPosition() {
              let target = -this._scrollTransition._targetValue;
              let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);
              let value = -direction * this._index * this._itemSize;
              return this._viewportScrollOffset * this.viewportSize + (value - target);
          }
          update() {
              if (!this._started) return;
              let nElements = this.length;
              if (!nElements) return;
              let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);
              let v = (this._horizontal ? this._wrapper.x : this._wrapper.y);
              let viewportSize = this.viewportSize;
              let scrollDelta = this._viewportScrollOffset * viewportSize - this._itemScrollOffset * this._itemSize;
              v += scrollDelta;
              let s, e, ps, pe;
              if (direction == -1) {
                  s = Math.floor(-v / this._itemSize);
                  ps = 1 - ((-v / this._itemSize) - s);
                  e = Math.floor((viewportSize - v) / this._itemSize);
                  pe = (((viewportSize - v) / this._itemSize) - e);
              } else {
                  s = Math.ceil(v / this._itemSize);
                  ps = 1 + (v / this._itemSize) - s;
                  e = Math.ceil((v - viewportSize) / this._itemSize);
                  pe = e - ((v - viewportSize) / this._itemSize);
              }
              if (this._roll || (viewportSize > this._itemSize * nElements)) {
                  if (e >= nElements) {
                      e = nElements - 1;
                      pe = 1;
                  }
                  if (s >= nElements) {
                      s = nElements - 1;
                      ps = 1;
                  }
                  if (e <= -1) {
                      e = 0;
                      pe = 1;
                  }
                  if (s <= -1) {
                      s = 0;
                      ps = 1;
                  }
              }
              let offset = -direction * s * this._itemSize;
              let item;
              for (let index = s; (direction == -1 ? index <= e : index >= e); (direction == -1 ? index++ : index--)) {
                  let realIndex = Utils.getModuloIndex(index, nElements);
                  let element = this.getElement(realIndex);
                  item = element.parent;
                  this._visibleItems.delete(item);
                  if (this._horizontal) {
                      item.x = offset + scrollDelta;
                  } else {
                      item.y = offset + scrollDelta;
                  }
                  let wasVisible = item.visible;
                  item.visible = true;
                  if (!wasVisible || this._reloadVisibleElements) {
                      this.emit('visible', index, realIndex);
                  }
                  if (this._progressAnimation) {
                      let p = 1;
                      if (index == s) {
                          p = ps;
                      } else if (index == e) {
                          p = pe;
                      }
                      this._progressAnimation.apply(element, p);
                  }
                  offset += this._itemSize;
              }
              let self = this;
              this._visibleItems.forEach(function(invisibleItem) {
                  invisibleItem.visible = false;
                  self._visibleItems.delete(invisibleItem);
              });
              for (let index = s; (direction == -1 ? index <= e : index >= e); (direction == -1 ? index++ : index--)) {
                  let realIndex = Utils.getModuloIndex(index, nElements);
                  this._visibleItems.add(this.getWrapper(realIndex));
              }
              this._reloadVisibleElements = false;
          }
          setPrevious() {
              this.setIndex(this._index - 1);
          }
          setNext() {
              this.setIndex(this._index + 1);
          }
          getWrapper(index) {
              return this._wrapper.children[index];
          }
          getElement(index) {
              let e = this._wrapper.children[index];
              return e ? e.children[0] : null;
          }
          reload() {
              this._reloadVisibleElements = true;
              this.update();
          }
          get element() {
              let e = this._wrapper.children[this.realIndex];
              return e ? e.children[0] : null;
          }
          get length() {
              return this._wrapper.children.length;
          }
          get property() {
              return this._horizontal ? 'x' : 'y';
          }
          get viewportSize() {
              return this._horizontal ? this.w : this.h;
          }
          get index() {
              return this._index;
          }
          get realIndex() {
              return Utils.getModuloIndex(this._index, this.length);
          }
          get itemSize() {
              return this._itemSize;
          }
          set itemSize(v) {
              this._itemSize = v;
              this.update();
          }
          get viewportScrollOffset() {
              return this._viewportScrollOffset;
          }
          set viewportScrollOffset(v) {
              this._viewportScrollOffset = v;
              this.update();
          }
          get itemScrollOffset() {
              return this._itemScrollOffset;
          }
          set itemScrollOffset(v) {
              this._itemScrollOffset = v;
              this.update();
          }
          get scrollTransitionSettings() {
              return this._scrollTransitionSettings;
          }
          set scrollTransitionSettings(v) {
              this._scrollTransitionSettings.patch(v);
          }
          set scrollTransition(v) {
              this._scrollTransitionSettings.patch(v);
          }
          get scrollTransition() {
              return this._scrollTransition;
          }
          get progressAnimation() {
              return this._progressAnimation;
          }
          set progressAnimation(v) {
              if (Utils.isObjectLiteral(v)) {
                  this._progressAnimation = this.stage.animations.createSettings(v);
              } else {
                  this._progressAnimation = v;
              }
              this.update();
          }
          get roll() {
              return this._roll;
          }
          set roll(v) {
              this._roll = v;
              this.update();
          }
          get rollMin() {
              return this._rollMin;
          }
          set rollMin(v) {
              this._rollMin = v;
              this.update();
          }
          get rollMax() {
              return this._rollMax;
          }
          set rollMax(v) {
              this._rollMax = v;
              this.update();
          }
          get invertDirection() {
              return this._invertDirection;
          }
          set invertDirection(v) {
              if (!this._started) {
                  this._invertDirection = v;
              }
          }
          get horizontal() {
              return this._horizontal;
          }
          set horizontal(v) {
              if (v !== this._horizontal) {
                  if (!this._started) {
                      this._horizontal = v;
                  }
              }
          }
      }
      class ListItems extends ObjectListWrapper {
          constructor(list) {
              let wrap = (item => {
                  let parent = item.stage.createElement();
                  parent.add(item);
                  parent.visible = false;
                  return parent;
              });
              super(list._wrapper._children, wrap);
              this.list = list;
          }
          onAdd(item, index) {
              super.onAdd(item, index);
              this.checkStarted(index);
          }
          checkStarted(index) {
              this.list._reloadVisibleElements = true;
              if (!this.list._started) {
                  this.list.start();
              } else {
                  if (this.list.length === 1) {
                      this.list.setIndex(0, true, true);
                  } else {
                      if (this.list._index >= this.list.length) {
                          this.list.setIndex(0);
                      }
                  }
                  this.list.update();
              }
          }
          onRemove(item, index) {
              super.onRemove(item, index);
              let ri = this.list.realIndex;
              if (ri === index) {
                  if (ri === this.list.length) {
                      ri--;
                  }
                  if (ri >= 0) {
                      this.list.setIndex(ri);
                  }
              } else if (ri > index) {
                  this.list.setIndex(ri - 1);
              }
              this.list._reloadVisibleElements = true;
          }
          onSet(item, index) {
              super.onSet(item, index);
              this.checkStarted(index);
          }
          onSync(removed, added, order) {
              super.onSync(removed, added, order);
              this.checkStarted(0);
          }
          get _signalProxy() {
              return true;
          }
      }

      class LinearBlurShader extends DefaultShader {
          constructor(context) {
              super(context);
              this._direction = new Float32Array([1, 0]);
              this._kernelRadius = 1;
          }
          get x() {
              return this._direction[0];
          }
          set x(v) {
              this._direction[0] = v;
              this.redraw();
          }
          get y() {
              return this._direction[1];
          }
          set y(v) {
              this._direction[1] = v;
              this.redraw();
          }
          get kernelRadius() {
              return this._kernelRadius;
          }
          set kernelRadius(v) {
              this._kernelRadius = v;
              this.redraw();
          }
          useDefault() {
              return (this._kernelRadius === 0);
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              this._setUniform("direction", this._direction, this.gl.uniform2fv);
              this._setUniform("kernelRadius", this._kernelRadius, this.gl.uniform1i);
              const w = operation.getRenderWidth();
              const h = operation.getRenderHeight();
              this._setUniform("resolution", new Float32Array([w, h]), this.gl.uniform2fv);
          }
      }
      LinearBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 resolution;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 direction;
    uniform int kernelRadius;
    
    vec4 blur1(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3333333333333333) * direction;
        color += texture2D(image, uv) * 0.29411764705882354;
        color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
        color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
        return color; 
    }
    
    vec4 blur2(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2D(image, uv) * 0.2270270270;
        color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;
        color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;
        return color;
    }
    
    vec4 blur3(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.411764705882353) * direction;
        vec2 off2 = vec2(3.2941176470588234) * direction;
        vec2 off3 = vec2(5.176470588235294) * direction;
        color += texture2D(image, uv) * 0.1964825501511404;
        color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
        color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
        return color;
    }    

    void main(void){
        if (kernelRadius == 1) {
            gl_FragColor = blur1(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else if (kernelRadius == 2) {
            gl_FragColor = blur2(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else {
            gl_FragColor = blur3(uSampler, vTextureCoord, resolution, direction) * vColor;
        }
    }
`;

      class BoxBlurShader extends DefaultShader {
          setupUniforms(operation) {
              super.setupUniforms(operation);
              const dx = 1.0 / operation.getTextureWidth(0);
              const dy = 1.0 / operation.getTextureHeight(0);
              this._setUniform("stepTextureCoord", new Float32Array([dx, dy]), this.gl.uniform2fv);
          }
      }
      BoxBlurShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 stepTextureCoord;
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec4 vColor;
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoordUl = aTextureCoord - stepTextureCoord;
        vTextureCoordBr = aTextureCoord + stepTextureCoord;
        vTextureCoordUr = vec2(vTextureCoordBr.x, vTextureCoordUl.y);
        vTextureCoordBl = vec2(vTextureCoordUl.x, vTextureCoordBr.y);
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      BoxBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = 0.25 * (texture2D(uSampler, vTextureCoordUl) + texture2D(uSampler, vTextureCoordUr) + texture2D(uSampler, vTextureCoordBl) + texture2D(uSampler, vTextureCoordBr));
        gl_FragColor = color * vColor;
    }
`;

      class BlurShader extends DefaultShader$1 {
          constructor(context) {
              super(context);
              this._kernelRadius = 1;
          }
          get kernelRadius() {
              return this._kernelRadius;
          }
          set kernelRadius(v) {
              this._kernelRadius = v;
              this.redraw();
          }
          useDefault() {
              return this._amount === 0;
          }
          _beforeDrawEl({target}) {
              target.ctx.filter = "blur(" + this._kernelRadius + "px)";
          }
          _afterDrawEl({target}) {
              target.ctx.filter = "none";
          }
      }

      class FastBlurComponent extends Component {
          static _template() {
              return {}
          }
          get wrap() {
              return this.tag("Wrap");
          }
          set content(v) {
              return this.wrap.content = v;
          }
          get content() {
              return this.wrap.content;
          }
          set padding(v) {
              this.wrap._paddingX = v;
              this.wrap._paddingY = v;
              this.wrap._updateBlurSize();
          }
          set paddingX(v) {
              this.wrap._paddingX = v;
              this.wrap._updateBlurSize();
          }
          set paddingY(v) {
              this.wrap._paddingY = v;
              this.wrap._updateBlurSize();
          }
          set amount(v) {
              return this.wrap.amount = v;
          }
          get amount() {
              return this.wrap.amount;
          }
          _onResize() {
              this.wrap.w = this.renderWidth;
              this.wrap.h = this.renderHeight;
          }
          get _signalProxy() {
              return true;
          }
          _build() {
              this.patch({
                  Wrap: {type: this.stage.gl ? WebGLFastBlurComponent : C2dFastBlurComponent}
              });
          }
      }
      class C2dFastBlurComponent extends Component {
          static _template() {
              return {
                  forceZIndexContext: true,
                  rtt: true,
                  Textwrap: {shader: {type: BlurShader}, Content: {}}
              }
          }
          constructor(stage) {
              super(stage);
              this._textwrap = this.sel("Textwrap");
              this._wrapper = this.sel("Textwrap>Content");
              this._amount = 0;
              this._paddingX = 0;
              this._paddingY = 0;
          }
          static getSpline() {
              if (!this._multiSpline) {
                  this._multiSpline = new MultiSpline();
                  this._multiSpline.parse(false, {0: 0, 0.25: 1.5, 0.5: 5.5, 0.75: 18, 1: 39});
              }
              return this._multiSpline;
          }
          get content() {
              return this.sel('Textwrap>Content');
          }
          set content(v) {
              this.sel('Textwrap>Content').patch(v, true);
          }
          set padding(v) {
              this._paddingX = v;
              this._paddingY = v;
              this._updateBlurSize();
          }
          set paddingX(v) {
              this._paddingX = v;
              this._updateBlurSize();
          }
          set paddingY(v) {
              this._paddingY = v;
              this._updateBlurSize();
          }
          _updateBlurSize() {
              let w = this.renderWidth;
              let h = this.renderHeight;
              let paddingX = this._paddingX;
              let paddingY = this._paddingY;
              this._wrapper.x = paddingX;
              this._textwrap.x = -paddingX;
              this._wrapper.y = paddingY;
              this._textwrap.y = -paddingY;
              this._textwrap.w = w + paddingX * 2;
              this._textwrap.h = h + paddingY * 2;
          }
          get amount() {
              return this._amount;
          }
          set amount(v) {
              this._amount = v;
              this._textwrap.shader.kernelRadius = C2dFastBlurComponent._amountToKernelRadius(v);
          }
          static _amountToKernelRadius(v) {
              return C2dFastBlurComponent.getSpline().getValue(Math.min(1, v * 0.25));
          }
          get _signalProxy() {
              return true;
          }
      }
      class WebGLFastBlurComponent extends Component {
          static _template() {
              const onUpdate = function(element, elementCore) {
                  if ((elementCore._recalc & (2 + 128))) {
                      const w = elementCore.w;
                      const h = elementCore.h;
                      let cur = elementCore;
                      do {
                          cur = cur._children[0];
                          cur._element.w = w;
                          cur._element.h = h;
                      } while(cur._children);
                  }
              };
              return {
                  Textwrap: {rtt: true, forceZIndexContext: true, renderOffscreen: true, Content: {}},
                  Layers: {
                      L0: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: BoxBlurShader}}},
                      L1: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: BoxBlurShader}}},
                      L2: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: BoxBlurShader}}},
                      L3: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: BoxBlurShader}}}
                  },
                  Result: {shader: {type: FastBlurOutputShader}, visible: false}
              }
          }
          get _signalProxy() {
              return true;
          }
          constructor(stage) {
              super(stage);
              this._textwrap = this.sel("Textwrap");
              this._wrapper = this.sel("Textwrap>Content");
              this._layers = this.sel("Layers");
              this._output = this.sel("Result");
              this._amount = 0;
              this._paddingX = 0;
              this._paddingY = 0;
          }
          _buildLayers() {
              const filterShaderSettings = [{x:1,y:0,kernelRadius:1},{x:0,y:1,kernelRadius:1},{x:1.5,y:0,kernelRadius:1},{x:0,y:1.5,kernelRadius:1}];
              const filterShaders = filterShaderSettings.map(s => {
                  const shader = Shader.create(this.stage, Object.assign({type: LinearBlurShader}, s));
                  return shader;
              });
              this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
              this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);
              this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
              this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
          }
          _setLayerTexture(element, texture, steps) {
              if (!steps.length) {
                  element.texture = texture;
              } else {
                  const step = steps.pop();
                  const child = element.stage.c({rtt: true, shader: step});
                  this._setLayerTexture(child, texture, steps);
                  element.childList.add(child);
              }
              return element;
          }
          get content() {
              return this.sel('Textwrap>Content');
          }
          set content(v) {
              this.sel('Textwrap>Content').patch(v, true);
          }
          set padding(v) {
              this._paddingX = v;
              this._paddingY = v;
              this._updateBlurSize();
          }
          set paddingX(v) {
              this._paddingX = v;
              this._updateBlurSize();
          }
          set paddingY(v) {
              this._paddingY = v;
              this._updateBlurSize();
          }
          getLayer(i) {
              return this._layers.sel("L" + i);
          }
          getLayerContents(i) {
              return this.getLayer(i).sel("Content");
          }
          _onResize() {
              this._updateBlurSize();
          }
          _updateBlurSize() {
              let w = this.renderWidth;
              let h = this.renderHeight;
              let paddingX = this._paddingX;
              let paddingY = this._paddingY;
              let fw = w + paddingX * 2;
              let fh = h + paddingY * 2;
              this._textwrap.w = fw;
              this._wrapper.x = paddingX;
              this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
              this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
              this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
              this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
              this._output.x = -paddingX;
              this._textwrap.x = -paddingX;
              this._output.w = fw;
              this._textwrap.h = fh;
              this._wrapper.y = paddingY;
              this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
              this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
              this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
              this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
              this._output.y = -paddingY;
              this._textwrap.y = -paddingY;
              this._output.h = fh;
              this.w = w;
              this.h = h;
          }
          set amount(v) {
              this._amount = v;
              this._update();
          }
          get amount() {
              return this._amount;
          }
          _update() {
              let v = Math.min(4, Math.max(0, this._amount));
              if (v === 0) {
                  this._textwrap.renderToTexture = false;
                  this._output.shader.otherTextureSource = null;
                  this._output.visible = false;
              } else {
                  this._textwrap.renderToTexture = true;
                  this._output.visible = true;
                  this.getLayer(0).visible = (v > 0);
                  this.getLayer(1).visible = (v > 1);
                  this.getLayer(2).visible = (v > 2);
                  this.getLayer(3).visible = (v > 3);
                  if (v <= 1) {
                      this._output.texture = this._textwrap.getTexture();
                      this._output.shader.otherTextureSource = this.getLayer(0).getTexture();
                      this._output.shader.a = v;
                  } else if (v <= 2) {
                      this._output.texture = this.getLayer(0).getTexture();
                      this._output.shader.otherTextureSource = this.getLayer(1).getTexture();
                      this._output.shader.a = v - 1;
                  } else if (v <= 3) {
                      this._output.texture = this.getLayer(1).getTexture();
                      this._output.shader.otherTextureSource = this.getLayer(2).getTexture();
                      this._output.shader.a = v - 2;
                  } else if (v <= 4) {
                      this._output.texture = this.getLayer(2).getTexture();
                      this._output.shader.otherTextureSource = this.getLayer(3).getTexture();
                      this._output.shader.a = v - 3;
                  }
              }
          }
          set shader(s) {
              super.shader = s;
              if (!this.renderToTexture) {
                  console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
              }
          }
          _firstActive() {
              this._buildLayers();
          }
      }
      class FastBlurOutputShader extends DefaultShader {
          constructor(ctx) {
              super(ctx);
              this._a = 0;
              this._otherTextureSource = null;
          }
          get a() {
              return this._a;
          }
          set a(v) {
              this._a = v;
              this.redraw();
          }
          set otherTextureSource(v) {
              this._otherTextureSource = v;
              this.redraw();
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              this._setUniform("a", this._a, this.gl.uniform1f);
              this._setUniform("uSampler2", 1, this.gl.uniform1i);
          }
          beforeDraw(operation) {
              let glTexture = this._otherTextureSource ? this._otherTextureSource.nativeTexture : null;
              let gl = this.gl;
              gl.activeTexture(gl.TEXTURE1);
              gl.bindTexture(gl.TEXTURE_2D, glTexture);
              gl.activeTexture(gl.TEXTURE0);
          }
      }
      FastBlurOutputShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uSampler2;
    uniform float a;
    void main(void){
        if (a == 1.0) {
            gl_FragColor = texture2D(uSampler2, vTextureCoord) * vColor;
        } else {
            gl_FragColor = ((1.0 - a) * texture2D(uSampler, vTextureCoord) + (a * texture2D(uSampler2, vTextureCoord))) * vColor;
        }
    }
`;

      class BloomComponent extends Component {
          static _template() {
              const onUpdate = function(element, elementCore) {
                  if ((elementCore._recalc & (2 + 128))) {
                      const w = elementCore.w;
                      const h = elementCore.h;
                      let cur = elementCore;
                      do {
                          cur = cur._children[0];
                          cur._element.w = w;
                          cur._element.h = h;
                      } while(cur._children);
                  }
              };
              return {
                  Textwrap: {rtt: true, forceZIndexContext: true, renderOffscreen: true,
                      BloomBase: {shader: {type: BloomBaseShader},
                          Content: {}
                      }
                  },
                  Layers: {
                      L0: {rtt: true, onUpdate: onUpdate, scale: 2, pivot: 0, visible: false, Content: {shader: {type: BoxBlurShader}}},
                      L1: {rtt: true, onUpdate: onUpdate, scale: 4, pivot: 0, visible: false, Content: {shader: {type: BoxBlurShader}}},
                      L2: {rtt: true, onUpdate: onUpdate, scale: 8, pivot: 0, visible: false, Content: {shader: {type: BoxBlurShader}}},
                      L3: {rtt: true, onUpdate: onUpdate, scale: 16, pivot: 0, visible: false, Content: {shader: {type: BoxBlurShader}}}
                  }
              }
          }
          get _signalProxy() {
              return true;
          }
          constructor(stage) {
              super(stage);
              this._textwrap = this.sel("Textwrap");
              this._wrapper = this.sel("Textwrap.Content");
              this._layers = this.sel("Layers");
              this._amount = 0;
              this._paddingX = 0;
              this._paddingY = 0;
          }
          _build() {
              const filterShaderSettings = [{x:1,y:0,kernelRadius:3},{x:0,y:1,kernelRadius:3},{x:1.5,y:0,kernelRadius:3},{x:0,y:1.5,kernelRadius:3}];
              const filterShaders = filterShaderSettings.map(s => {
                  const shader = this.stage.createShader(Object.assign({type: LinearBlurShader}, s));
                  return shader;
              });
              this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
              this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);
              this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
              this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
          }
          _setLayerTexture(element, texture, steps) {
              if (!steps.length) {
                  element.texture = texture;
              } else {
                  const step = steps.pop();
                  const child = element.stage.c({rtt: true, shader: step});
                  this._setLayerTexture(child, texture, steps);
                  element.childList.add(child);
              }
              return element;
          }
          get content() {
              return this.sel('Textwrap.Content');
          }
          set content(v) {
              this.sel('Textwrap.Content').patch(v);
          }
          set padding(v) {
              this._paddingX = v;
              this._paddingY = v;
              this._updateBlurSize();
          }
          set paddingX(v) {
              this._paddingX = v;
              this._updateBlurSize();
          }
          set paddingY(v) {
              this._paddingY = v;
              this._updateBlurSize();
          }
          getLayer(i) {
              return this._layers.sel("L" + i);
          }
          getLayerContents(i) {
              return this.getLayer(i).sel("Content");
          }
          _onResize() {
              this._updateBlurSize();
          }
          _updateBlurSize() {
              let w = this.renderWidth;
              let h = this.renderHeight;
              let paddingX = this._paddingX;
              let paddingY = this._paddingY;
              let fw = w + paddingX * 2;
              let fh = h + paddingY * 2;
              this._textwrap.w = fw;
              this._wrapper.x = paddingX;
              this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
              this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
              this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
              this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
              this._textwrap.x = -paddingX;
              this._textwrap.h = fh;
              this._wrapper.y = paddingY;
              this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
              this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
              this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
              this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
              this._textwrap.y = -paddingY;
              this.w = w;
              this.h = h;
          }
          set amount(v) {
              this._amount = v;
              this._update();
          }
          get amount() {
              return this._amount;
          }
          _update() {
              let v = Math.min(4, Math.max(0, this._amount));
              if (v > 0) {
                  this.getLayer(0).visible = (v > 0);
                  this.getLayer(1).visible = (v > 1);
                  this.getLayer(2).visible = (v > 2);
                  this.getLayer(3).visible = (v > 3);
              }
          }
          set shader(s) {
              super.shader = s;
              if (!this.renderToTexture) {
                  console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
              }
          }
          _firstActive() {
              this._build();
          }
      }
      class BloomBaseShader extends DefaultShader {
      }
      BloomBaseShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float m = max(max(color.r, color.g), color.b);
        float c = max(0.0, (m - 0.80)) * 5.0;
        color = color * c;
        gl_FragColor = color;
    }
`;

      class SmoothScaleComponent extends Component {
          static _template() {
              return {
                  ContentWrap: {renderOffscreen: true, forceZIndexContext: true, onAfterUpdate: SmoothScaleComponent._updateDimensions,
                      Content: {}
                  },
                  Scale: {visible: false}
              }
          }
          constructor(stage) {
              super(stage);
              this._smoothScale = 1;
              this._iterations = 0;
          }
          get content() {
              return this.tag('Content');
          }
          set content(v) {
              this.tag('Content').patch(v, true);
          }
          get smoothScale() {
              return this._smoothScale;
          }
          set smoothScale(v) {
              if (this._smoothScale !== v) {
                  let its = 0;
                  while(v < 0.5 && its < 12) {
                      its++;
                      v = v * 2;
                  }
                  this.scale = v;
                  this._setIterations(its);
                  this._smoothScale = v;
              }
          }
          _setIterations(its) {
              if (this._iterations !== its) {
                  const scalers = this.sel("Scale").childList;
                  const content = this.sel("ContentWrap");
                  while (scalers.length < its) {
                      const first = scalers.length === 0;
                      const texture = (first ? content.getTexture() : scalers.last.getTexture());
                      scalers.a({rtt: true, renderOffscreen: true, texture: texture});
                  }
                  SmoothScaleComponent._updateDimensions(this.tag("ContentWrap"), true);
                  const useScalers = (its > 0);
                  this.patch({
                      ContentWrap: {renderToTexture: useScalers},
                      Scale: {visible: useScalers}
                  });
                  for (let i = 0, n = scalers.length; i < n; i++) {
                      scalers.getAt(i).patch({
                          visible: i < its,
                          renderOffscreen: i !== its - 1
                      });
                  }
                  this._iterations = its;
              }
          }
          static _updateDimensions(contentWrap, force) {
              const content = contentWrap.children[0];
              let w = content.renderWidth;
              let h = content.renderHeight;
              if (w !== contentWrap.w || h !== contentWrap.h || force) {
                  contentWrap.w = w;
                  contentWrap.h = h;
                  const scalers = contentWrap.parent.tag("Scale").children;
                  for (let i = 0, n = scalers.length; i < n; i++) {
                      w = w * 0.5;
                      h = h * 0.5;
                      scalers[i].w = w;
                      scalers[i].h = h;
                  }
              }
          }
          get _signalProxy() {
              return true;
          }
      }

      class BorderComponent extends Component {
          static _template() {
              return {
                  Content: {},
                  Borders: {
                      Top: {rect: true, visible: false, mountY: 1},
                      Right: {rect: true, visible: false},
                      Bottom: {rect: true, visible: false},
                      Left: {rect: true, visible: false, mountX: 1}
                  }
              };
          }
          get _signalProxy() {
              return true;
          }
          constructor(stage) {
              super(stage);
              this._borderTop = this.tag("Top");
              this._borderRight = this.tag("Right");
              this._borderBottom = this.tag("Bottom");
              this._borderLeft = this.tag("Left");
              this.onAfterUpdate = function (element) {
                  const content = element.childList.first;
                  let w = element.core.w || content.renderWidth;
                  let h = element.core.h || content.renderHeight;
                  element._borderTop.w = w;
                  element._borderBottom.y = h;
                  element._borderBottom.w = w;
                  element._borderLeft.h = h + element._borderTop.h + element._borderBottom.h;
                  element._borderLeft.y = -element._borderTop.h;
                  element._borderRight.x = w;
                  element._borderRight.h = h + element._borderTop.h + element._borderBottom.h;
                  element._borderRight.y = -element._borderTop.h;
              };
              this.borderWidth = 1;
          }
          get content() {
              return this.sel('Content');
          }
          set content(v) {
              this.sel('Content').patch(v, true);
          }
          get borderWidth() {
              return this.borderWidthTop;
          }
          get borderWidthTop() {
              return this._borderTop.h;
          }
          get borderWidthRight() {
              return this._borderRight.w;
          }
          get borderWidthBottom() {
              return this._borderBottom.h;
          }
          get borderWidthLeft() {
              return this._borderLeft.w;
          }
          set borderWidth(v) {
              this.borderWidthTop = v;
              this.borderWidthRight = v;
              this.borderWidthBottom = v;
              this.borderWidthLeft = v;
          }
          set borderWidthTop(v) {
              this._borderTop.h = v;
              this._borderTop.visible = (v > 0);
          }
          set borderWidthRight(v) {
              this._borderRight.w = v;
              this._borderRight.visible = (v > 0);
          }
          set borderWidthBottom(v) {
              this._borderBottom.h = v;
              this._borderBottom.visible = (v > 0);
          }
          set borderWidthLeft(v) {
              this._borderLeft.w = v;
              this._borderLeft.visible = (v > 0);
          }
          get colorBorder() {
              return this.colorBorderTop;
          }
          get colorBorderTop() {
              return this._borderTop.color;
          }
          get colorBorderRight() {
              return this._borderRight.color;
          }
          get colorBorderBottom() {
              return this._borderBottom.color;
          }
          get colorBorderLeft() {
              return this._borderLeft.color;
          }
          set colorBorder(v) {
              this.colorBorderTop = v;
              this.colorBorderRight = v;
              this.colorBorderBottom = v;
              this.colorBorderLeft = v;
          }
          set colorBorderTop(v) {
              this._borderTop.color = v;
          }
          set colorBorderRight(v) {
              this._borderRight.color = v;
          }
          set colorBorderBottom(v) {
              this._borderBottom.color = v;
          }
          set colorBorderLeft(v) {
              this._borderLeft.color = v;
          }
          get borderTop() {
              return this._borderTop;
          }
          set borderTop(settings) {
              this.borderTop.patch(settings);
          }
          get borderRight() {
              return this._borderRight;
          }
          set borderRight(settings) {
              this.borderRight.patch(settings);
          }
          get borderBottom() {
              return this._borderBottom;
          }
          set borderBottom(settings) {
              this.borderBottom.patch(settings);
          }
          get borderLeft() {
              return this._borderLeft;
          }
          set borderLeft(settings) {
              this.borderLeft.patch(settings);
          }
          set borders(settings) {
              this.borderTop = settings;
              this.borderLeft = settings;
              this.borderBottom = settings;
              this.borderRight = settings;
          }
      }

      class WebGLGrayscaleShader extends DefaultShader {
          constructor(context) {
              super(context);
              this._amount = 1;
          }
          static getC2d() {
              return C2dGrayscaleShader;
          }
          set amount(v) {
              this._amount = v;
              this.redraw();
          }
          get amount() {
              return this._amount;
          }
          useDefault() {
              return this._amount === 0;
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              this._setUniform("amount", this._amount, this.gl.uniform1f);
          }
      }
      WebGLGrayscaleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float grayness = 0.2 * color.r + 0.6 * color.g + 0.2 * color.b;
        gl_FragColor = vec4(amount * vec3(grayness, grayness, grayness) + (1.0 - amount) * color.rgb, color.a);
    }
`;
      class C2dGrayscaleShader extends DefaultShader$1 {
          constructor(context) {
              super(context);
              this._amount = 1;
          }
          static getWebGL() {
              return WebGLGrayscaleShader;
          }
          set amount(v) {
              this._amount = v;
              this.redraw();
          }
          get amount() {
              return this._amount;
          }
          useDefault() {
              return this._amount === 0;
          }
          _beforeDrawEl({target}) {
              target.ctx.filter = "grayscale(" + this._amount + ")";
          }
          _afterDrawEl({target}) {
              target.ctx.filter = "none";
          }
      }

      class DitheringShader extends DefaultShader {
          constructor(ctx) {
              super(ctx);
              this._noiseTexture = new NoiseTexture(ctx.stage);
              this._graining = 1/256;
              this._random = false;
          }
          set graining(v) {
              this._graining = v;
              this.redraw();
          }
          set random(v) {
              this._random = v;
              this.redraw();
          }
          setExtraAttribsInBuffer(operation) {
              this._noiseTexture.load();
              let offset = operation.extraAttribsDataByteOffset / 4;
              let floats = operation.quads.floats;
              let length = operation.length;
              for (let i = 0; i < length; i++) {
                  let brx = operation.getElementWidth(i) / this._noiseTexture.getRenderWidth();
                  let bry = operation.getElementHeight(i) / this._noiseTexture.getRenderHeight();
                  let ulx = 0;
                  let uly = 0;
                  if (this._random) {
                      ulx = Math.random();
                      uly = Math.random();
                      brx += ulx;
                      bry += uly;
                      if (Math.random() < 0.5) {
                          const t = ulx;
                          ulx = brx;
                          brx = t;
                      }
                      if (Math.random() < 0.5) {
                          const t = uly;
                          uly = bry;
                          bry = t;
                      }
                  }
                  floats[offset] = ulx;
                  floats[offset + 1] = uly;
                  floats[offset + 2] = brx;
                  floats[offset + 3] = uly;
                  floats[offset + 4] = brx;
                  floats[offset + 5] = bry;
                  floats[offset + 6] = ulx;
                  floats[offset + 7] = bry;
                  offset += 8;
              }
          }
          beforeDraw(operation) {
              let gl = this.gl;
              gl.vertexAttribPointer(this._attrib("aNoiseTextureCoord"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
              let glTexture = this._noiseTexture.source.nativeTexture;
              gl.activeTexture(gl.TEXTURE1);
              gl.bindTexture(gl.TEXTURE_2D, glTexture);
              gl.activeTexture(gl.TEXTURE0);
          }
          getExtraAttribBytesPerVertex() {
              return 8;
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              this._setUniform("uNoiseSampler", 1, this.gl.uniform1i);
              this._setUniform("graining", 2 * this._graining, this.gl.uniform1f);
          }
          enableAttribs() {
              super.enableAttribs();
              let gl = this.gl;
              gl.enableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
          }
          disableAttribs() {
              super.disableAttribs();
              let gl = this.gl;
              gl.disableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
          }
          useDefault() {
              return this._graining === 0;
          }
          afterDraw(operation) {
              if (this._random) {
                  this.redraw();
              }
          }
      }
      DitheringShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec2 aNoiseTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vNoiseTextureCoord = aNoiseTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      DitheringShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uNoiseSampler;
    uniform float graining;
    void main(void){
        vec4 noise = texture2D(uNoiseSampler, vNoiseTextureCoord);
        vec4 color = texture2D(uSampler, vTextureCoord);
        gl_FragColor = (color * vColor) + graining * (noise.r - 0.5);
    }
`;

      class CircularPushShader extends DefaultShader {
          constructor(ctx) {
              super(ctx);
              this._inputValue = 0;
              this._maxDerivative = 0.01;
              this._normalizedValue = 0;
              this._offset = 0;
              this._amount = 0.1;
              this._aspectRatio = 1;
              this._offsetX = 0;
              this._offsetY = 0;
              this.buckets = 100;
          }
          get aspectRatio() {
              return this._aspectRatio;
          }
          set aspectRatio(v) {
              this._aspectRatio = v;
              this.redraw();
          }
          get offsetX() {
              return this._offsetX;
          }
          set offsetX(v) {
              this._offsetX = v;
              this.redraw();
          }
          get offsetY() {
              return this._offsetY;
          }
          set offsetY(v) {
              this._offsetY = v;
              this.redraw();
          }
          set amount(v) {
              this._amount = v;
              this.redraw();
          }
          get amount() {
              return this._amount;
          }
          set inputValue(v) {
              this._inputValue = v;
          }
          get inputValue() {
              return this._inputValue;
          }
          set maxDerivative(v) {
              this._maxDerivative = v;
          }
          get maxDerivative() {
              return this._maxDerivative;
          }
          set buckets(v) {
              if (v > 100) {
                  console.warn("[Lightning] CircularPushShader: supports max 100 buckets");
                  v = 100;
              }
              this._buckets = v;
              this._values = new Uint8Array(this._getValues(v));
              this.redraw();
          }
          get buckets() {
              return this._buckets;
          }
          _getValues(n) {
              const v = [];
              for (let i = 0; i < n; i++) {
                  v.push(this._inputValue);
              }
              return v;
          }
          progress(o) {
              this._offset += o * this._buckets;
              const full = Math.floor(this._offset);
              this._offset -= full;
              this._shiftBuckets(full);
              this.redraw();
          }
          _shiftBuckets(n) {
              for (let i = this._buckets - 1; i >= 0; i--) {
                  const targetIndex = i - n;
                  if (targetIndex < 0) {
                      this._normalizedValue = Math.min(this._normalizedValue + this._maxDerivative, Math.max(this._normalizedValue - this._maxDerivative, this._inputValue));
                      this._values[i] = 255 * this._normalizedValue;
                  } else {
                      this._values[i] = this._values[targetIndex];
                  }
              }
          }
          set offset(v) {
              this._offset = v;
              this.redraw();
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              this._setUniform("aspectRatio", this._aspectRatio, this.gl.uniform1f);
              this._setUniform("offsetX", this._offsetX, this.gl.uniform1f);
              this._setUniform("offsetY", this._offsetY, this.gl.uniform1f);
              this._setUniform("amount", this._amount, this.gl.uniform1f);
              this._setUniform("offset", this._offset, this.gl.uniform1f);
              this._setUniform("buckets", this._buckets, this.gl.uniform1f);
              this._setUniform("uValueSampler", 1, this.gl.uniform1i);
          }
          useDefault() {
              return this._amount === 0;
          }
          beforeDraw(operation) {
              const gl = this.gl;
              gl.activeTexture(gl.TEXTURE1);
              if (!this._valuesTexture) {
                  this._valuesTexture = gl.createTexture();
                  gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                  if (Utils.isNode) {
                      gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, false);
                  }
                  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
              } else {
                  gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
              }
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this._buckets, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this._values);
              gl.activeTexture(gl.TEXTURE0);
          }
          cleanup() {
              if (this._valuesTexture) {
                  this.gl.deleteTexture(this._valuesTexture);
              }
          }
      }
      CircularPushShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    uniform float offsetX;
    uniform float offsetY;
    uniform float aspectRatio;
    varying vec2 vTextureCoord;
    varying vec2 vPos;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vPos = vTextureCoord * 2.0 - 1.0;
        vPos.y = vPos.y * aspectRatio;
        vPos.y = vPos.y + offsetY;
        vPos.x = vPos.x + offsetX;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      CircularPushShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vPos;
    uniform float amount;
    uniform float offset;
    uniform float values[100];
    uniform float buckets;
    uniform sampler2D uSampler;
    uniform sampler2D uValueSampler;
    void main(void){
        float l = length(vPos);
        float m = (l * buckets * 0.678 - offset) / buckets;
        float f = texture2D(uValueSampler, vec2(m, 0.0)).a * amount;
        vec2 unit = vPos / l;
        gl_FragColor = texture2D(uSampler, vTextureCoord - f * unit) * vColor;
    }
`;

      class InversionShader extends DefaultShader {
          constructor(context) {
              super(context);
              this._amount = 1;
          }
          set amount(v) {
              this._amount = v;
              this.redraw();
          }
          get amount() {
              return this._amount;
          }
          useDefault() {
              return this._amount === 0;
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              this._setUniform("amount", this._amount, this.gl.uniform1f);
          }
      }
      InversionShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        color.rgb = color.rgb * (1.0 - amount) + amount * (1.0 * color.a - color.rgb); 
        gl_FragColor = color * vColor;
    }
`;

      class OutlineShader extends DefaultShader {
          constructor(ctx) {
              super(ctx);
              this._width = 5;
              this._col = 0xFFFFFFFF;
              this._color = [1,1,1,1];
          }
          set width(v) {
              this._width = v;
              this.redraw();
          }
          get color() {
              return this._col;
          }
          set color(v) {
              if (this._col !== v) {
                  const col = StageUtils.getRgbaComponentsNormalized(v);
                  col[0] = col[0] * col[3];
                  col[1] = col[1] * col[3];
                  col[2] = col[2] * col[3];
                  this._color = col;
                  this.redraw();
                  this._col = v;
              }
          }
          useDefault() {
              return (this._width === 0 || this._col[3] === 0);
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              let gl = this.gl;
              this._setUniform("color", new Float32Array(this._color), gl.uniform4fv);
          }
          enableAttribs() {
              super.enableAttribs();
              this.gl.enableVertexAttribArray(this._attrib("aCorner"));
          }
          disableAttribs() {
              super.disableAttribs();
              this.gl.disableVertexAttribArray(this._attrib("aCorner"));
          }
          setExtraAttribsInBuffer(operation) {
              let offset = operation.extraAttribsDataByteOffset / 4;
              let floats = operation.quads.floats;
              let length = operation.length;
              for (let i = 0; i < length; i++) {
                  const elementCore = operation.getElementCore(i);
                  const ddw = this._width / elementCore.w;
                  const dw = ddw / (1 - 2 * ddw);
                  const ddh = this._width / elementCore.h;
                  const dh = ddh / (1 - 2 * ddh);
                  floats[offset] = -dw;
                  floats[offset + 1] = -dh;
                  floats[offset + 2] = 1 + dw;
                  floats[offset + 3] = -dh;
                  floats[offset + 4] = 1 + dw;
                  floats[offset + 5] = 1 + dh;
                  floats[offset + 6] = -dw;
                  floats[offset + 7] = 1 + dh;
                  offset += 8;
              }
          }
          beforeDraw(operation) {
              let gl = this.gl;
              gl.vertexAttribPointer(this._attrib("aCorner"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
          }
          getExtraAttribBytesPerVertex() {
              return 8;
          }
      }
      OutlineShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aCorner;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vCorner;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vCorner = aCorner;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      OutlineShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vCorner;
    uniform vec4 color;
    uniform sampler2D uSampler;
    void main(void){
        vec2 m = min(vCorner, 1.0 - vCorner);
        float value = step(0.0, min(m.x, m.y));
        gl_FragColor = mix(color, texture2D(uSampler, vTextureCoord) * vColor, value);
    }
`;

      class PixelateShader extends DefaultShader {
          constructor(ctx) {
              super(ctx);
              this._size = new Float32Array([4, 4]);
          }
          get x() {
              return this._size[0];
          }
          set x(v) {
              this._size[0] = v;
              this.redraw();
          }
          get y() {
              return this._size[1];
          }
          set y(v) {
              this._size[1] = v;
              this.redraw();
          }
          get size() {
              return this._size[0];
          }
          set size(v) {
              this._size[0] = v;
              this._size[1] = v;
              this.redraw();
          }
          useDefault() {
              return ((this._size[0] === 0) && (this._size[1] === 0));
          }
          static getWebGLImpl() {
              return WebGLPixelateShaderImpl;
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              let gl = this.gl;
              this._setUniform("size", new Float32Array(this._size), gl.uniform2fv);
          }
          getExtraAttribBytesPerVertex() {
              return 8;
          }
          enableAttribs() {
              super.enableAttribs();
              this.gl.enableVertexAttribArray(this._attrib("aTextureRes"));
          }
          disableAttribs() {
              super.disableAttribs();
              this.gl.disableVertexAttribArray(this._attrib("aTextureRes"));
          }
          setExtraAttribsInBuffer(operation) {
              let offset = operation.extraAttribsDataByteOffset / 4;
              let floats = operation.quads.floats;
              let length = operation.length;
              for (let i = 0; i < length; i++) {
                  let w = operation.quads.getTextureWidth(operation.index + i);
                  let h = operation.quads.getTextureHeight(operation.index + i);
                  floats[offset] = w;
                  floats[offset + 1] = h;
                  floats[offset + 2] = w;
                  floats[offset + 3] = h;
                  floats[offset + 4] = w;
                  floats[offset + 5] = h;
                  floats[offset + 6] = w;
                  floats[offset + 7] = h;
                  offset += 8;
              }
          }
          beforeDraw(operation) {
              let gl = this.gl;
              gl.vertexAttribPointer(this._attrib("aTextureRes"), 2, gl.FLOAT, false, this.getExtraAttribBytesPerVertex(), this.getVertexAttribPointerOffset(operation));
          }
      }
      PixelateShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aTextureRes;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        vTextureRes = aTextureRes;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      PixelateShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;

    uniform vec2 size;
    uniform sampler2D uSampler;
    
    vec2 mapCoord( vec2 coord )
    {
        coord *= vTextureRes.xy;
        return coord;
    }
    
    vec2 unmapCoord( vec2 coord )
    {
        coord /= vTextureRes.xy;
        return coord;
    }
    
    vec2 pixelate(vec2 coord, vec2 size)
    {
        return floor( coord / size ) * size;
    }
    
    void main(void)
    {
        vec2 coord = mapCoord(vTextureCoord);
        coord = pixelate(coord, size);
        coord = unmapCoord(coord);
        gl_FragColor = texture2D(uSampler, coord) * vColor;
    }
`;

      class RadialFilterShader extends DefaultShader {
          constructor(context) {
              super(context);
              this._radius = 0;
              this._cutoff = 1;
          }
          set radius(v) {
              this._radius = v;
              this.redraw();
          }
          get radius() {
              return this._radius;
          }
          set cutoff(v) {
              this._cutoff = v;
              this.redraw();
          }
          get cutoff() {
              return this._cutoff;
          }
          useDefault() {
              return this._radius === 0;
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              this._setUniform("radius", 2 * (this._radius - 0.5) / operation.getRenderWidth(), this.gl.uniform1f);
              this._setUniform("cutoff", 0.5 * operation.getRenderWidth() / this._cutoff, this.gl.uniform1f);
          }
      }
      RadialFilterShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 pos;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
        pos = gl_Position.xy;
    }
`;
      RadialFilterShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 pos;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float radius;
    uniform float cutoff;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        float f = max(0.0, min(1.0, 1.0 - (length(pos) - radius) * cutoff));
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * f;
    }
`;

      class RoundedRectangleShader extends DefaultShader {
          constructor(context) {
              super(context);
              this._blend = 0;
              this._radius = [1, 1, 1, 1];
              this._stroke = 0;
              this._fc = 0x00ffffff;
              this._fillColor = this._getNormalizedColor(0xffffffff);
              this._strokeColor = this._getNormalizedColor(0x00ffffff);
          }
          set blend(p) {
              this._blend = Math.min(Math.max(p, 0), 1);
          }
          set radius(v) {
              if(Array.isArray(v)) {
                  if(v.length === 2) {
                      this._radius = [v[0], v[1], v[0], v[1]];
                  }
                  else if(v.length === 3) {
                      this._radius = [v[0], v[1], v[2], this._radius[3]];
                  }
                  else if (v.length === 4) {
                      this._radius = v;
                  }
                  else {
                      this._radius = [v[0], v[0], v[0], v[0]];
                  }
              }
              else {
                  this._radius = [v, v, v, v];
              }
              this.redraw();
          }
          get radius() {
              return this._radius;
          }
          set topLeft(num) {
              this._radius[0] = num;
              this.redraw();
          }
          get topLeft() {
              return this._radius[0];
          }
          set topRight(num) {
              this._radius[1] = num;
              this.redraw();
          }
          get topRight() {
              return this._radius[1];
          }
          set bottomRight(num) {
              this._radius[2] = num;
              this.redraw();
          }
          get bottomRight() {
              return this._radius[2];
          }
          set bottomLeft(num) {
              this._radius[3] = num;
              this.redraw();
          }
          get bottomLeft() {
              return this._radius[4];
          }
          set strokeColor(argb) {
              this._sc = argb;
              this._strokeColor = this._getNormalizedColor(argb);
              this.redraw();
          }
          get strokeColor() {
              return this._sc;
          }
          set fillColor(argb) {
              this._fc = argb;
              this._fillColor = this._getNormalizedColor(argb);
              this.redraw();
          }
          get fillColor() {
              return this._fc;
          }
          set stroke(num) {
              this._stroke = num;
              this.redraw();
          }
          get stroke() {
              return this._stroke;
          }
          _getNormalizedColor(color) {
              const col = StageUtils.getRgbaComponentsNormalized(color);
              col[0] *= col[3];
              col[1] *= col[3];
              col[2] *= col[3];
              return new Float32Array(col);
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              const owner = operation.shaderOwner;
              const renderPrecision = this.ctx.stage.getRenderPrecision();
              const _radius = this._radius.map((r) => (r + 0.5) * renderPrecision);
              this._setUniform('radius', new Float32Array(_radius), this.gl.uniform4fv);
              this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
              this._setUniform('blend', this._blend, this.gl.uniform1f);
              this._setUniform('strokeColor', this._strokeColor, this.gl.uniform4fv);
              this._setUniform('fillColor', this._fillColor, this.gl.uniform4fv);
              this._setUniform('stroke',  this._stroke * renderPrecision, this.gl.uniform1f);
              this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
          }
      }
      RoundedRectangleShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      RoundedRectangleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif

    #define PI 3.14159265359

    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 radius;
    uniform float stroke;
    uniform vec4 strokeColor;
    uniform vec4 fillColor;
    uniform float alpha;
    uniform float fill;
    uniform float blend;
    
    float boxDist(vec2 p, vec2 size, float radius){
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    float innerBorderMask(float dist, float width){
        float alpha1 = clamp(dist + width, 0.0, 1.0);
        float alpha2 = clamp(dist, 0.0, 1.0);
        return alpha1 - alpha2;
    }

    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        float r = 0.0;
        if (vTextureCoord.x < 0.5 && vTextureCoord.y < 0.5) {
            r = radius[0];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y < 0.5) {
            r = radius[1];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y >= 0.5) {
            r = radius[2];
        } else {
            r = radius[3];
        }
        
        float b = boxDist(vTextureCoord.xy * resolution - halfRes, halfRes - 0.005, r);
        vec4 tex = texture2D(uSampler, vTextureCoord) * vColor;
        vec4 blend = mix(vec4(1.0) * alpha, tex, blend);     
        vec4 layer1 = mix(vec4(0.0), tex * fillColor, fillMask(b));
        gl_FragColor = mix(layer1, blend * strokeColor, innerBorderMask(b, stroke));
    }
`;

      class FadeOutShader extends DefaultShader {
          constructor(context) {
              super(context);
              this._fade = [0, 0, 0, 0];
          }
          set top(num) {
              this._fade[0] = num;
              this.redraw();
          }
          get top() {
              return this._fade[0];
          }
          set right(num) {
              this._fade[1] = num;
              this.redraw();
          }
          get right() {
              return this._fade[1];
          }
          set bottom(num) {
              this._fade[2] = num;
              this.redraw();
          }
          get bottom() {
              return this._fade[2];
          }
          set left(num) {
              this._fade[3] = num;
              this.redraw();
          }
          get left() {
              return this._fade[3];
          }
          set fade(v) {
              if(Array.isArray(v)) {
                  if(v.length === 2) {
                      this._fade = [v[0], v[1], v[0], v[1]];
                  }
                  else if(v.length === 3) {
                      this._fade = [v[0], v[1], v[2], this._fade[3]];
                  }
                  else if (v.length === 4) {
                      this._fade = v;
                  }
                  else {
                      this._fade = [v[0], v[0], v[0], v[0]];
                  }
              }
              else {
                  this._fade = [v, v, v, v];
              }
              this.redraw();
          }
          get fade() {
              return this._fade;
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              const owner = operation.shaderOwner;
              const renderPrecision = this.ctx.stage.getRenderPrecision();
              const fade = this._fade.map((f) => f * renderPrecision);
              this._setUniform('fade',  new Float32Array(fade), this.gl.uniform4fv);
              this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
          }
      }
      FadeOutShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 fade;
    
    void main() {
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 point = vTextureCoord.xy * resolution.xy;
        
        vec2 pos1;
        vec2 pos2;
        vec2 d;
        float c;
        float t = 0.0;
             
        if(fade[0] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x, point.y + fade[0]);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[1] > 0.0) {
            vec2 pos1 = vec2(point.x - resolution.x - fade[1], vTextureCoord.y);
            vec2 pos2 = vec2(point.x - resolution.x, vTextureCoord.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[2] > 0.0) {
            vec2 pos1 = vec2(vTextureCoord.x, point.y - resolution.y - fade[2]);
            vec2 pos2 = vec2(vTextureCoord.x, point.y - resolution.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[3] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x + fade[3], point.y);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        gl_FragColor = color;
    }
`;

      class VignetteShader extends DefaultShader {
          constructor(context) {
              super(context);
              this._magnitude = 1.3;
              this._intensity = 0.7;
              this._pivot = [0.5, 0.5];
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              this._setUniform("magnitude", this._magnitude , this.gl.uniform1f);
              this._setUniform("intensity", this._intensity, this.gl.uniform1f);
              this._setUniform('pivot', new Float32Array(this._pivot), this.gl.uniform2fv);
              this.redraw();
          }
          set pivot(v) {
              if(Array.isArray(v)) {
                  this._pivot = v;
              }
              else {
                  this._pivot = [v, v];
              }
              this.redraw();
          }
          get pivotX() {
              return this._pivot[0];
          }
          set pivotX(v) {
              this._pivot[0] = v;
              this.redraw();
          }
          get pivotY() {
              return this._pivot[1];
          }
          set pivotY(v) {
              this._pivot[1] = v;
              this.redraw();
          }
          get intensity() {
              return this._intensity;
          }
          set intensity(v) {
              this._intensity = v;
              this.redraw();
          }
          get magnitude() {
              return this._magnitude;
          }
          set magnitude(v) {
              this._magnitude = v;
              this.redraw();
          }
      }
      VignetteShader.vertexShaderSource = DefaultShader.vertexShaderSource;
      VignetteShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float magnitude;
    uniform float intensity;
    uniform vec2 pivot;

    void main() {
        vec2 uv = vTextureCoord.xy - pivot + vec2(0.5);
        uv.x = clamp(uv.x, 0.0, 1.0);
        uv.y = clamp(uv.y, 0.0, 1.0);
   
        uv *=  1.00 - uv.yx;
        float vig = uv.x * uv.y * 25.0 * intensity;
        vig = pow(vig, 0.45 * magnitude);
        vec4 fragColor = vec4(vig) * vColor;
        gl_FragColor = texture2D(uSampler, vTextureCoord) * fragColor;

    }
`;

      class SpinnerShader extends DefaultShader {
          constructor(ctx) {
              super(ctx);
              this._radius = 100;
              this._width = 50;
              this._period = 1;
              this._angle = 0.5;
              this._smooth = 0.005;
              this._color = 0xffffffff;
              this._backgroundColor = 0xff000000;
              this._time = Date.now();
          }
          set radius(v) {
              this._radius = v;
              this.redraw();
          }
          set width(v) {
              this._width = v;
              this.redraw();
          }
          set period(v) {
              this._period = v;
              this.redraw();
          }
          set angle(v) {
              this._angle = v;
              this.redraw();
          }
          set smooth(v) {
              this._smooth = v;
              this.redraw();
          }
          set color(v) {
              this._color = v;
              this.redraw();
          }
          set backgroundColor(v) {
              this._backgroundColor = v;
              this.redraw();
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              const owner = operation.shaderOwner;
              this._setUniform("iTime", Date.now() - this._time, this.gl.uniform1f);
              const renderPrecision = this.ctx.stage.getRenderPrecision();
              this._setUniform('radius', this._radius * renderPrecision, this.gl.uniform1f);
              this._setUniform('width', this._width * renderPrecision, this.gl.uniform1f);
              this._setUniform('period', this._period, this.gl.uniform1f);
              this._setUniform('angle', this._angle, this.gl.uniform1f);
              this._setUniform('smooth', this._smooth, this.gl.uniform1f);
              this._setUniform('color', new Float32Array(StageUtils.getRgbaComponentsNormalized(this._color)), this.gl.uniform4fv);
              this._setUniform('backgroundColor', new Float32Array(StageUtils.getRgbaComponentsNormalized(this._backgroundColor)), this.gl.uniform4fv);
              this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
              this.redraw();
          }
      }
      SpinnerShader.vertexShaderSource = DefaultShader.vertexShaderSource;
      SpinnerShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float iTime;
    uniform float radius;
    uniform float width;
    uniform float period;
    uniform float angle;
    uniform float smooth;
    uniform vec2 resolution;

    uniform vec4 color;
    uniform vec4 backgroundColor;

    float ratio = resolution.y / resolution.x;

    vec2 transpose_pos(vec2 pos) {
        if (ratio < 1.) {
            float diff = 0.5 - pos.x;
            pos.x = 0.5 - diff / ratio;
        } else {
            float diff = 0.5 - pos.y;
            pos.y = 0.5 - diff * ratio;
        }
        return pos;
    }

    float get_angle(vec2 pos) {
        pos = transpose_pos(pos);
        float a = atan(pos.y - 0.5, pos.x - 0.5);
        a = (1.0+a/3.14159)/2.0;
        
        return a;
    }

    float dist(vec2 pos1, vec2 pos2) {
        pos1 = transpose_pos(pos1);
        return distance(pos1, pos2);
    }

    void main()
    {
        vec2 fragCoord = vTextureCoord;
        vec4 fragColor = vColor;
        
        vec2 st = vTextureCoord;
        float pct = dist(st, vec2(0.5));

        float a = get_angle(st);
        float t = iTime / 1000.0 / period;

        float inner = max((radius - width) / resolution.x, (radius - width) / resolution.y);
        float outer = max(radius / resolution.x, radius / resolution.y);

        float x1 = mod(t, 1.0);
        float x2 = mod(t + angle, 1.0);

        if (x1 < x2) {
            if (a > x1 && a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        } else {
            if (a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else if (a > x1) {
                float val = (1.0 - (1.0 + x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (1.0 + x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        }

        float s = smoothstep(inner, inner + smooth + 0.00001, pct) * (1.0 - smoothstep(outer, outer + smooth + 0.00001, pct));
        gl_FragColor = texture2D(uSampler, fragCoord) * vColor * (1. - s * fragColor.a) + fragColor * s;
    }
`;

      class HoleShader extends DefaultShader {
          constructor(context) {
              super(context);
              this._x = 0;
              this._y = 0;
              this._w = 0;
              this._h = 0;
              this._radius = 0;
          }
          get x() {
              return this._x;
          }
          set x(v) {
              this._x = v;
              this.redraw();
          }
          get y() {
              return this._y;
          }
          set y(v) {
              this._y = v;
              this.redraw();
          }
          get w() {
              return this._w;
          }
          set w(v) {
              this._w = v;
              this.redraw();
          }
          get h() {
              return this._h;
          }
          set h(v) {
              this._h = v;
              this.redraw();
          }
          get radius() {
              return this._radius;
          }
          set radius(v) {
              this._radius = v;
              this.redraw();
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              const owner = operation.shaderOwner;
              const renderPrecision = this.ctx.stage.getRenderPrecision();
              this._setUniform("x", this._x * renderPrecision, this.gl.uniform1f);
              this._setUniform("y", this._y * renderPrecision, this.gl.uniform1f);
              this._setUniform("w", this._w * renderPrecision, this.gl.uniform1f);
              this._setUniform("h", this._h * renderPrecision, this.gl.uniform1f);
              this._setUniform('radius',  (this._radius + .5) * renderPrecision, this.gl.uniform1f);
              this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
          }
          useDefault() {
              return (this._x === 0 && this._y === 0 && this._w === 0 && this._h === 0)
          }
      }
      HoleShader.vertexShaderSource = DefaultShader.vertexShaderSource;
      HoleShader.fragmentShaderSource = `
   #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float x;
    uniform float y;
    uniform float w;
    uniform float h;
    uniform vec2 resolution;
    uniform float radius;

    float roundBox(vec2 p, vec2 b, float r) {
        float d = length(max(abs(p)-b+r, 0.1))-r;
        return smoothstep(1.0, 0.0, d);
    }

    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
        vec2 size = vec2(w, h) / 2.0;
        float b = roundBox(pos, size, radius);
        gl_FragColor = mix(color, vec4(0.0), b);
    }
`;

      class RadialGradientShader extends DefaultShader {
          constructor(context) {
              super(context);
              this._pivot = [0, 0];
              this._ic = 0xffffffff;
              this._normalizedIC = this._getNormalizedColor(this._ic);
              this._oc = 0x00ffffff;
              this._normalizedOC = this._getNormalizedColor(this._oc);
              this._radius = 0;
          }
          set radiusX(v) {
              this.radius = v;
          }
          get radiusX() {
              return this._radius;
          }
          set radiusY(v) {
              this._radiusY = v;
              this.redraw();
          }
          get radiusY() {
              return this._radiusY;
          }
          set radius(v) {
              this._radius = v;
              this.redraw();
          }
          set innerColor(argb) {
              this._ic = argb;
              this._normalizedIC = this._getNormalizedColor(argb);
              this.redraw();
          }
          get innerColor() {
              return this._ic;
          }
          set outerColor(argb) {
              this._oc = argb;
              this._normalizedOC = this._getNormalizedColor(argb);
              this.redraw();
          }
          set color(argb) {
              this.innerColor = argb;
          }
          get color() {
              return this.innerColor;
          }
          get outerColor() {
              return this._ic;
          }
          set x(f) {
              this._x = f;
              this.redraw();
          }
          set y(f) {
              this._y = f;
              this.redraw();
          }
          set pivot(v) {
              if(Array.isArray(v) && v.length === 2) {
                  this._pivot = v;
              }
              else if(Array.isArray(v)) {
                  this._pivot = [v[0], v[1] || v[0]];
              }
              else {
                  this._pivot = [v, v];
              }
              this.redraw();
          }
          get pivot() {
              return this._pivot[0];
          }
          set pivotY(f) {
              this._pivot[1] = f;
              this.redraw();
          }
          get pivotY() {
              return this._pivot[1];
          }
          set pivotX(f) {
              this._pivot[0] = f;
              this.redraw();
          }
          get pivotX() {
              return this._pivot[0];
          }
          _getNormalizedColor(color) {
              const col = StageUtils.getRgbaComponentsNormalized(color);
              col[0] *= col[3];
              col[1] *= col[3];
              col[2] *= col[3];
              return new Float32Array(col);
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              const owner = operation.shaderOwner;
              if(this._x) {
                  this._pivot[0] = this._x / owner.w;
              }
              if(this._y) {
                  this._pivot[1] = this._y / owner.h;
              }
              if(this._radius === 0) {
                  this._radius = owner.w * 0.5;
              }
              this._setUniform('innerColor', this._normalizedIC, this.gl.uniform4fv);
              this._setUniform('fill', StageUtils.getRgbaComponentsNormalized(this._oc)[3], this.gl.uniform1f);
              this._setUniform('outerColor', this._normalizedOC, this.gl.uniform4fv);
              this._setUniform('pivot', new Float32Array(this._pivot),  this.gl.uniform2fv);
              this._setUniform('resolution', new Float32Array([owner._w, owner._h]),  this.gl.uniform2fv);
              this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
              this._setUniform('radius',  this._radius, this.gl.uniform1f);
              this._setUniform('radiusY',  (this._radiusY || this._radius), this.gl.uniform1f);
          }
      }
      RadialGradientShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec2 pivot;
    uniform vec4 innerColor;
    uniform vec4 outerColor;
    uniform float radius;
    uniform float radiusY;
    uniform float alpha;
    uniform float fill;
    uniform float aspectRatio;
    
    void main() {
        vec2 point = vTextureCoord.xy * resolution;
        vec2 projection = vec2(pivot.x * resolution.x, pivot.y * resolution.y);
        float d = length((point - projection) / vec2(radius * 2.0, radiusY * 2.0));
        vec4 color = mix(texture2D(uSampler, vTextureCoord) * vColor, outerColor * alpha, fill);
        gl_FragColor = mix(innerColor * alpha, color, smoothstep(0.0, 1.0, d));
    }
`;

      class Light3dShader extends DefaultShader {
          constructor(ctx) {
              super(ctx);
              this._strength = 0.5;
              this._ambient = 0.5;
              this._fudge = 0.4;
              this._rx = 0;
              this._ry = 0;
              this._z = 0;
              this._pivotX = NaN;
              this._pivotY = NaN;
              this._pivotZ = 0;
              this._lightY = 0;
              this._lightZ = 0;
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              let vr = operation.shaderOwner;
              let element = vr.element;
              let pivotX = isNaN(this._pivotX) ? element.pivotX * vr.w : this._pivotX;
              let pivotY = isNaN(this._pivotY) ? element.pivotY * vr.h : this._pivotY;
              let coords = vr.getRenderTextureCoords(pivotX, pivotY);
              let rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);
              let gl = this.gl;
              this._setUniform("pivot", new Float32Array([coords[0], coords[1], this._pivotZ]), gl.uniform3fv);
              this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
              this._setUniform("z", this._z, gl.uniform1f);
              this._setUniform("lightY", this.lightY, gl.uniform1f);
              this._setUniform("lightZ", this.lightZ, gl.uniform1f);
              this._setUniform("strength", this._strength, gl.uniform1f);
              this._setUniform("ambient", this._ambient, gl.uniform1f);
              this._setUniform("fudge", this._fudge, gl.uniform1f);
          }
          set strength(v) {
              this._strength = v;
              this.redraw();
          }
          get strength() {
              return this._strength;
          }
          set ambient(v) {
              this._ambient = v;
              this.redraw();
          }
          get ambient() {
              return this._ambient;
          }
          set fudge(v) {
              this._fudge = v;
              this.redraw();
          }
          get fudge() {
              return this._fudge;
          }
          get rx() {
              return this._rx;
          }
          set rx(v) {
              this._rx = v;
              this.redraw();
          }
          get ry() {
              return this._ry;
          }
          set ry(v) {
              this._ry = v;
              this.redraw();
          }
          get z() {
              return this._z;
          }
          set z(v) {
              this._z = v;
              this.redraw();
          }
          get pivotX() {
              return this._pivotX;
          }
          set pivotX(v) {
              this._pivotX = v + 1;
              this.redraw();
          }
          get pivotY() {
              return this._pivotY;
          }
          set pivotY(v) {
              this._pivotY = v + 1;
              this.redraw();
          }
          get lightY() {
              return this._lightY;
          }
          set lightY(v) {
              this._lightY = v;
              this.redraw();
          }
          get pivotZ() {
              return this._pivotZ;
          }
          set pivotZ(v) {
              this._pivotZ = v;
              this.redraw();
          }
          get lightZ() {
              return this._lightZ;
          }
          set lightZ(v) {
              this._lightZ = v;
              this.redraw();
          }
          useDefault() {
              return (this._rx === 0 && this._ry === 0 && this._z === 0 && this._strength === 0 && this._ambient === 1);
          }
      }
      Light3dShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float fudge;
    uniform float strength;
    uniform float ambient;
    uniform float z;
    uniform float lightY;
    uniform float lightZ;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Set depth perspective
        float perspective = 1.0 + fudge * pos.z;

        pos.z += lightZ * projection.x;

        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, perspective);

        // Correct light source position.
        pos.y += lightY * abs(projection.y);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      Light3dShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec3 pos;
    uniform sampler2D uSampler;
    uniform float ambient;
    uniform float strength;
    void main(void){
        vec4 rgba = texture2D(uSampler, vTextureCoord);
        float d = length(pos);
        float n = 1.0 / max(0.1, d);
        rgba.rgb = rgba.rgb * (strength * n + ambient);
        gl_FragColor = rgba * vColor;
    }
`;

      class PerspectiveShader extends DefaultShader {
          constructor(ctx) {
              super(ctx);
              this._fudge = 0.2;
              this._rx = 0;
              this._ry = 0;
              this._z = 1.0;
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              const vr = operation.shaderOwner;
              const element = vr.element;
              const pivotX = element.pivotX * vr.w;
              const pivotY = element.pivotY * vr.h;
              const coords = vr.getRenderTextureCoords(pivotX, pivotY);
              const rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);
              const gl = this.gl;
              this._setUniform("pivot", new Float32Array([coords[0], coords[1], 0]), gl.uniform3fv);
              this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
              this._setUniform("z", this._z, gl.uniform1f);
              this._setUniform("fudge", this._fudge, gl.uniform1f);
          }
          set fudge(v) {
              this._fudge = v;
              this.redraw();
          }
          get fudge() {
              return this._fudge;
          }
          get rx() {
              return this._rx;
          }
          set rx(v) {
              this._rx = v;
              this.redraw();
          }
          get ry() {
              return this._ry;
          }
          set ry(v) {
              this._ry = v;
              this.redraw();
          }
          get z() {
              return this._z;
          }
          set z(v) {
              this._z = v;
              this.redraw();
          }
          useDefault() {
              return (this._rx === 0 && this._ry === 0 && this._z === 0);
          }
      }
      PerspectiveShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float z;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, z);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
      PerspectiveShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform vec3 rot;
    uniform float fudge;

    void main(void) {
        vec2 coords = vTextureCoord;

        coords.xy -= vec2(0.5);
        coords.y = coords.y + (sign(rot[0]) * 0.5 - coords.x) * sin(rot[0]) * fudge * coords.y;
        coords.x = coords.x + (sign(rot[1]) * 0.5 - coords.y) * sin(rot[1]) * fudge * coords.x;
        coords.xy += vec2(0.5);

        if (coords.x < 0.0 || coords.x > 1.0 || coords.y < 0.0 || coords.y > 1.0) {
            gl_FragColor = vec4(0.0);
        } else {
            gl_FragColor = texture2D(uSampler, coords) * vColor;
        }
    }
`;

      class SpinnerShader2 extends DefaultShader {
          constructor(context) {
              super(context);
              this._period = 1;
              this._stroke = 0;
              this._showDot = true;
              this._clockwise = true;
              this._bc = 0xff000000;
              this._normalizedBC = this._getNormalizedColor(this._bc);
              this._c = 0xffffffff;
              this._normalizedC = this._getNormalizedColor(this._c);
          }
          set radius(v) {
              if(v === 0) {
                  v = 1;
              }
              this._radius = v;
          }
          set stroke(value) {
              this._stroke = Math.abs(value);
          }
          get stroke() {
              return this._stroke;
          }
          set color(argb) {
              this._c = argb;
              this._normalizedC = this._getNormalizedColor(argb);
          }
          get color() {
              return this._c;
          }
          set backgroundColor(argb) {
              this._bc = argb;
              this._normalizedBC = this._getNormalizedColor(argb);
          }
          get backgroundColor() {
              return this._sc;
          }
          set showDot(bool) {
              this._showDot = bool;
          }
          get showDot() {
              return this._showDot;
          }
          set clockwise(bool) {
              this._clockwise = bool;
          }
          get clockwise() {
              return this._clockwise;
          }
          set period(v) {
              this._period = v;
          }
          get period() {
              return this._period;
          }
          _getNormalizedColor(color) {
              const col = StageUtils.getRgbaComponentsNormalized(color);
              col[0] *= col[3];
              col[1] *= col[3];
              col[2] *= col[3];
              return new Float32Array(col);
          }
          setupUniforms(operation) {
              super.setupUniforms(operation);
              const owner = operation.shaderOwner;
              const radius = this._radius || (owner._w / 2);
              if(this._stroke === 0) {
                  this._stroke = radius * 0.33;
              }
              this._setUniform('resolution', new Float32Array([owner._w, owner._h]),  this.gl.uniform2fv);
              this._setUniform('color', this._normalizedC, this.gl.uniform4fv);
              this._setUniform('backgroundColor', this._normalizedBC, this.gl.uniform4fv);
              this._setUniform('stroke',  this._stroke, this.gl.uniform1f);
              this._setUniform('radius',  radius, this.gl.uniform1f);
              this._setUniform('direction',  this._clockwise ? -1 : 1, this.gl.uniform1f);
              this._setUniform('showDot', !!this._showDot, this.gl.uniform1f);
              this._setUniform('time', Date.now() - SpinnerShader2.spinSync, this.gl.uniform1f);
              this._setUniform('period', this._period, this.gl.uniform1f);
              this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
              if(this._sc !== this._bc || this._stroke !== radius * 0.5) {
                  this.redraw();
              }
          }
      }
      SpinnerShader2.spinSync = Date.now();
      SpinnerShader2.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 color;
    uniform vec4 backgroundColor;
    uniform float direction;
    uniform float radius;
    uniform float time;
    uniform float stroke;
    uniform float showDot;
    uniform float period;
    uniform float alpha;
    
    float circleDist(vec2 p, float radius){
        return length(p) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 center = vTextureCoord.xy * resolution - halfRes;
        
        float c = max(-circleDist(center, radius - stroke), circleDist(center, radius));
        float rot = -(time / 1000.0 / period) * 6.0 * direction;
        center *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));
        
        float a = direction * atan(center.x, center.y) * PI * 0.05 + 0.45;
        
        float strokeRad = stroke * 0.5;
        a = mix(a, max(a, fillMask(circleDist(vec2(center.x, center.y + (radius - strokeRad)), strokeRad))), showDot);
        vec4 base = mix(vec4(0.0), backgroundColor * alpha, fillMask(c));
        gl_FragColor = mix(base, color * alpha, fillMask(c) * a);
    }
`;

      const lightning = {
          Application,
          Component,
          Base,
          Utils,
          StageUtils,
          Element,
          Tools,
          Stage,
          ElementCore,
          ElementTexturizer,
          Texture,
          EventEmitter,
          shaders: {
              Grayscale: WebGLGrayscaleShader,
              BoxBlur: BoxBlurShader,
              Dithering: DitheringShader,
              CircularPush: CircularPushShader,
              Inversion: InversionShader,
              LinearBlur: LinearBlurShader,
              Outline: OutlineShader,
              Pixelate: PixelateShader,
              RadialFilter: RadialFilterShader,
              RoundedRectangle: RoundedRectangleShader,
              Spinner2: SpinnerShader2,
              FadeOut: FadeOutShader,
              Hole: HoleShader,
              Vignette: VignetteShader,
              Spinner: SpinnerShader,
              RadialGradient: RadialGradientShader,
              Light3d: Light3dShader,
              Perspective: PerspectiveShader,
              WebGLShader,
              WebGLDefaultShader: DefaultShader,
              C2dShader,
              C2dDefaultShader: DefaultShader$1,
              c2d: {
                  Grayscale: C2dGrayscaleShader,
                  Blur: BlurShader
              }
          },
          textures: {
              RectangleTexture,
              NoiseTexture,
              TextTexture,
              ImageTexture,
              HtmlTexture,
              StaticTexture,
              StaticCanvasTexture,
              SourceTexture
          },
          components: {
              FastBlurComponent,
              BloomComponent,
              SmoothScaleComponent,
              BorderComponent,
              ListComponent
          },
          tools: {
              ObjMerger,
              ObjectListProxy,
              ObjectListWrapper
          }
      };
      if (Utils.isWeb) {
          window.lng = lightning;
      }

      return lightning;

  })));
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const events$1 = [
    'timeupdate',
    'error',
    'ended',
    'loadeddata',
    'canplay',
    'play',
    'playing',
    'pause',
    'loadstart',
    'seeking',
    'seeked',
    'encrypted',
  ];

  let mediaUrl = url => url;

  const initMediaPlayer = config => {
    if (config.mediaUrl) {
      mediaUrl = config.mediaUrl;
    }
  };

  class Mediaplayer extends lightning.Component {
    _construct() {
      this._skipRenderToTexture = false;
      this._metrics = null;
      this._textureMode = Settings.get('platform', 'textureMode') || false;
      Log.info('Texture mode: ' + this._textureMode);
      console.warn(
        [
          "The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
          "Please consider using the new 'VideoPlayer'-plugin instead.",
          'https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer',
        ].join('\n\n')
      );
    }

    static _template() {
      return {
        Video: {
          VideoWrap: {
            VideoTexture: {
              visible: false,
              pivot: 0.5,
              texture: { type: lightning.textures.StaticTexture, options: {} },
            },
          },
        },
      }
    }

    set skipRenderToTexture(v) {
      this._skipRenderToTexture = v;
    }

    get textureMode() {
      return this._textureMode
    }

    get videoView() {
      return this.tag('Video')
    }

    _init() {
      //re-use videotag if already there
      const videoEls = document.getElementsByTagName('video');
      if (videoEls && videoEls.length > 0) this.videoEl = videoEls[0];
      else {
        this.videoEl = document.createElement('video');
        this.videoEl.setAttribute('id', 'video-player');
        this.videoEl.style.position = 'absolute';
        this.videoEl.style.zIndex = '1';
        this.videoEl.style.display = 'none';
        this.videoEl.setAttribute('width', '100%');
        this.videoEl.setAttribute('height', '100%');

        this.videoEl.style.visibility = this.textureMode ? 'hidden' : 'visible';
        document.body.appendChild(this.videoEl);
      }
      if (this.textureMode && !this._skipRenderToTexture) {
        this._createVideoTexture();
      }

      this.eventHandlers = [];
    }

    _registerListeners() {
      events$1.forEach(event => {
        const handler = e => {
          if (this._metrics && this._metrics[event] && typeof this._metrics[event] === 'function') {
            this._metrics[event]({ currentTime: this.videoEl.currentTime });
          }
          this.fire(event, { videoElement: this.videoEl, event: e });
        };
        this.eventHandlers.push(handler);
        this.videoEl.addEventListener(event, handler);
      });
    }

    _deregisterListeners() {
      Log.info('Deregistering event listeners MediaPlayer');
      events$1.forEach((event, index) => {
        this.videoEl.removeEventListener(event, this.eventHandlers[index]);
      });
      this.eventHandlers = [];
    }

    _attach() {
      this._registerListeners();
    }

    _detach() {
      this._deregisterListeners();
      this.close();
    }

    _createVideoTexture() {
      const stage = this.stage;

      const gl = stage.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height };
    }

    _startUpdatingVideoTexture() {
      if (this.textureMode && !this._skipRenderToTexture) {
        const stage = this.stage;
        if (!this._updateVideoTexture) {
          this._updateVideoTexture = () => {
            if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
              const gl = stage.gl;

              const currentTime = new Date().getTime();

              // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
              // We'll fallback to fixed 30fps in this case.
              const frameCount = this.videoEl.webkitDecodedFrameCount;

              const mustUpdate = frameCount
                ? this._lastFrame !== frameCount
                : this._lastTime < currentTime - 30;

              if (mustUpdate) {
                this._lastTime = currentTime;
                this._lastFrame = frameCount;
                try {
                  gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                  this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                  this.videoTextureView.visible = true;

                  this.videoTexture.options.w = this.videoEl.videoWidth;
                  this.videoTexture.options.h = this.videoEl.videoHeight;
                  const expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h;
                  const realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight;
                  if (expectedAspectRatio > realAspectRatio) {
                    this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio;
                    this.videoTextureView.scaleY = 1;
                  } else {
                    this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio;
                    this.videoTextureView.scaleX = 1;
                  }
                } catch (e) {
                  Log.error('texImage2d video', e);
                  this._stopUpdatingVideoTexture();
                  this.videoTextureView.visible = false;
                }
                this.videoTexture.source.forceRenderUpdate();
              }
            }
          };
        }
        if (!this._updatingVideoTexture) {
          stage.on('frameStart', this._updateVideoTexture);
          this._updatingVideoTexture = true;
        }
      }
    }

    _stopUpdatingVideoTexture() {
      if (this.textureMode) {
        const stage = this.stage;
        stage.removeListener('frameStart', this._updateVideoTexture);
        this._updatingVideoTexture = false;
        this.videoTextureView.visible = false;

        if (this.videoTexture.options.source) {
          const gl = stage.gl;
          gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
      }
    }

    updateSettings(settings = {}) {
      // The Component that 'consumes' the media player.
      this._consumer = settings.consumer;

      if (this._consumer && this._consumer.getMediaplayerSettings) {
        // Allow consumer to add settings.
        settings = Object.assign(settings, this._consumer.getMediaplayerSettings());
      }

      if (!lightning.Utils.equalValues(this._stream, settings.stream)) {
        if (settings.stream && settings.stream.keySystem) {
          navigator
            .requestMediaKeySystemAccess(
              settings.stream.keySystem.id,
              settings.stream.keySystem.config
            )
            .then(keySystemAccess => {
              return keySystemAccess.createMediaKeys()
            })
            .then(createdMediaKeys => {
              return this.videoEl.setMediaKeys(createdMediaKeys)
            })
            .then(() => {
              if (settings.stream && settings.stream.src) this.open(settings.stream.src);
            })
            .catch(() => {
              console.error('Failed to set up MediaKeys');
            });
        } else if (settings.stream && settings.stream.src) {
          // This is here to be backwards compatible, will be removed
          // in future sdk release
          if (Settings.get('app', 'hls')) {
            if (!window.Hls) {
              window.Hls = class Hls {
                static isSupported() {
                  console.warn('hls-light not included');
                  return false
                }
              };
            }
            if (window.Hls.isSupported()) {
              if (!this._hls) this._hls = new window.Hls({ liveDurationInfinity: true });
              this._hls.loadSource(settings.stream.src);
              this._hls.attachMedia(this.videoEl);
              this.videoEl.style.display = 'block';
            }
          } else {
            this.open(settings.stream.src);
          }
        } else {
          this.close();
        }
        this._stream = settings.stream;
      }

      this._setHide(settings.hide);
      this._setVideoArea(settings.videoPos);
    }

    _setHide(hide) {
      if (this.textureMode) {
        this.tag('Video').setSmooth('alpha', hide ? 0 : 1);
      } else {
        this.videoEl.style.visibility = hide ? 'hidden' : 'visible';
      }
    }

    open(url, settings = { hide: false, videoPosition: null }) {
      // prep the media url to play depending on platform (mediaPlayerplugin)
      url = mediaUrl(url);
      this._metrics = Metrics$1.media(url);
      Log.info('Playing stream', url);
      if (this.application.noVideo) {
        Log.info('noVideo option set, so ignoring: ' + url);
        return
      }
      // close the video when opening same url as current (effectively reloading)
      if (this.videoEl.getAttribute('src') === url) {
        this.close();
      }
      this.videoEl.setAttribute('src', url);

      // force hide, then force show (in next tick!)
      // (fixes comcast playback rollover issue)
      this.videoEl.style.visibility = 'hidden';
      this.videoEl.style.display = 'none';

      setTimeout(() => {
        this.videoEl.style.display = 'block';
        this.videoEl.style.visibility = 'visible';
      });

      this._setHide(settings.hide);
      this._setVideoArea(settings.videoPosition || [0, 0, 1920, 1080]);
    }

    close() {
      // We need to pause first in order to stop sound.
      this.videoEl.pause();
      this.videoEl.removeAttribute('src');

      // force load to reset everything without errors
      this.videoEl.load();

      this._clearSrc();

      this.videoEl.style.display = 'none';
    }

    playPause() {
      if (this.isPlaying()) {
        this.doPause();
      } else {
        this.doPlay();
      }
    }

    get muted() {
      return this.videoEl.muted
    }

    set muted(v) {
      this.videoEl.muted = v;
    }

    get loop() {
      return this.videoEl.loop
    }

    set loop(v) {
      this.videoEl.loop = v;
    }

    isPlaying() {
      return this._getState() === 'Playing'
    }

    doPlay() {
      this.videoEl.play();
    }

    doPause() {
      this.videoEl.pause();
    }

    reload() {
      var url = this.videoEl.getAttribute('src');
      this.close();
      this.videoEl.src = url;
    }

    getPosition() {
      return Promise.resolve(this.videoEl.currentTime)
    }

    setPosition(pos) {
      this.videoEl.currentTime = pos;
    }

    getDuration() {
      return Promise.resolve(this.videoEl.duration)
    }

    seek(time, absolute = false) {
      if (absolute) {
        this.videoEl.currentTime = time;
      } else {
        this.videoEl.currentTime += time;
      }
    }

    get videoTextureView() {
      return this.tag('Video').tag('VideoTexture')
    }

    get videoTexture() {
      return this.videoTextureView.texture
    }

    _setVideoArea(videoPos) {
      if (lightning.Utils.equalValues(this._videoPos, videoPos)) {
        return
      }

      this._videoPos = videoPos;

      if (this.textureMode) {
        this.videoTextureView.patch({
          smooth: {
            x: videoPos[0],
            y: videoPos[1],
            w: videoPos[2] - videoPos[0],
            h: videoPos[3] - videoPos[1],
          },
        });
      } else {
        const precision = this.stage.getRenderPrecision();
        this.videoEl.style.left = Math.round(videoPos[0] * precision) + 'px';
        this.videoEl.style.top = Math.round(videoPos[1] * precision) + 'px';
        this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * precision) + 'px';
        this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * precision) + 'px';
      }
    }

    _fireConsumer(event, args) {
      if (this._consumer) {
        this._consumer.fire(event, args);
      }
    }

    _equalInitData(buf1, buf2) {
      if (!buf1 || !buf2) return false
      if (buf1.byteLength != buf2.byteLength) return false
      const dv1 = new Int8Array(buf1);
      const dv2 = new Int8Array(buf2);
      for (let i = 0; i != buf1.byteLength; i++) if (dv1[i] != dv2[i]) return false
      return true
    }

    error(args) {
      this._fireConsumer('$mediaplayerError', args);
      this._setState('');
      return ''
    }

    loadeddata(args) {
      this._fireConsumer('$mediaplayerLoadedData', args);
    }

    play(args) {
      this._fireConsumer('$mediaplayerPlay', args);
    }

    playing(args) {
      this._fireConsumer('$mediaplayerPlaying', args);
      this._setState('Playing');
    }

    canplay(args) {
      this.videoEl.play();
      this._fireConsumer('$mediaplayerStart', args);
    }

    loadstart(args) {
      this._fireConsumer('$mediaplayerLoad', args);
    }

    seeked() {
      this._fireConsumer('$mediaplayerSeeked', {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1,
      });
    }

    seeking() {
      this._fireConsumer('$mediaplayerSeeking', {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1,
      });
    }

    durationchange(args) {
      this._fireConsumer('$mediaplayerDurationChange', args);
    }

    encrypted(args) {
      const video = args.videoElement;
      const event = args.event;
      // FIXME: Double encrypted events need to be properly filtered by Gstreamer
      if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
        this._previousInitData = event.initData;
        this._fireConsumer('$mediaplayerEncrypted', args);
      }
    }

    static _states() {
      return [
        class Playing extends this {
          $enter() {
            this._startUpdatingVideoTexture();
          }
          $exit() {
            this._stopUpdatingVideoTexture();
          }
          timeupdate() {
            this._fireConsumer('$mediaplayerProgress', {
              currentTime: this.videoEl.currentTime,
              duration: this.videoEl.duration || 1,
            });
          }
          ended(args) {
            this._fireConsumer('$mediaplayerEnded', args);
            this._setState('');
          }
          pause(args) {
            this._fireConsumer('$mediaplayerPause', args);
            this._setState('Playing.Paused');
          }
          _clearSrc() {
            this._fireConsumer('$mediaplayerStop', {});
            this._setState('');
          }
          static _states() {
            return [class Paused extends this {}]
          }
        },
      ]
    }
  }

  class localCookie{constructor(e){return e=e||{},this.forceCookies=e.forceCookies||!1,!0===this._checkIfLocalStorageWorks()&&!0!==e.forceCookies?{getItem:this._getItemLocalStorage,setItem:this._setItemLocalStorage,removeItem:this._removeItemLocalStorage,clear:this._clearLocalStorage}:{getItem:this._getItemCookie,setItem:this._setItemCookie,removeItem:this._removeItemCookie,clear:this._clearCookies}}_checkIfLocalStorageWorks(){if("undefined"==typeof localStorage)return !1;try{return localStorage.setItem("feature_test","yes"),"yes"===localStorage.getItem("feature_test")&&(localStorage.removeItem("feature_test"),!0)}catch(e){return !1}}_getItemLocalStorage(e){return window.localStorage.getItem(e)}_setItemLocalStorage(e,t){return window.localStorage.setItem(e,t)}_removeItemLocalStorage(e){return window.localStorage.removeItem(e)}_clearLocalStorage(){return window.localStorage.clear()}_getItemCookie(e){var t=document.cookie.match(RegExp("(?:^|;\\s*)"+function(e){return e.replace(/([.*+?\^${}()|\[\]\/\\])/g,"\\$1")}(e)+"=([^;]*)"));return t&&""===t[1]&&(t[1]=null),t?t[1]:null}_setItemCookie(e,t){var o=new Date,r=new Date(o.getTime()+15768e7);document.cookie=`${e}=${t}; expires=${r.toUTCString()};`;}_removeItemCookie(e){document.cookie=`${e}=;Max-Age=-99999999;`;}_clearCookies(){document.cookie.split(";").forEach(e=>{document.cookie=e.replace(/^ +/,"").replace(/=.*/,"=;expires=Max-Age=-99999999");});}}

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const initStorage = () => {
    Settings.get('platform', 'id');
    // todo: pass options (for example to force the use of cookies)
    new localCookie();
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const isFunction = v => {
    return typeof v === 'function'
  };

  const isObject = v => {
    return typeof v === 'object' && v !== null
  };

  const isBoolean = v => {
    return typeof v === 'boolean'
  };

  const isPage = v => {
    if (v instanceof lightning.Element || isComponentConstructor(v)) {
      return true
    }
    return false
  };

  const isComponentConstructor = type => {
    return type.prototype && 'isComponent' in type.prototype
  };

  const isArray = v => {
    return Array.isArray(v)
  };

  const ucfirst = v => {
    return `${v.charAt(0).toUpperCase()}${v.slice(1)}`
  };

  const isString = v => {
    return typeof v === 'string'
  };

  const isPromise = method => {
    let result;
    if (isFunction(method)) {
      try {
        result = method.apply(null);
      } catch (e) {
        result = e;
      }
    } else {
      result = method;
    }
    return isObject(result) && isFunction(result.then)
  };

  const getConfigMap = () => {
    const routerSettings = Settings.get('platform', 'router');
    const isObj = isObject(routerSettings);
    return [
      'backtrack',
      'gcOnUnload',
      'destroyOnHistoryBack',
      'lazyCreate',
      'lazyDestroy',
      'reuseInstance',
      'autoRestoreRemote',
      'numberNavigation',
      'updateHash',
    ].reduce((config, key) => {
      config.set(key, isObj ? routerSettings[key] : Settings.get('platform', key));
      return config
    }, new Map())
  };

  const getQueryStringParams = hash => {
    const getQuery = /([?&].*)/;
    const matches = getQuery.exec(hash);
    const params = {};

    if (matches && matches.length) {
      const urlParams = new URLSearchParams(matches[1]);
      for (const [key, value] of urlParams.entries()) {
        params[key] = value;
      }
      return params
    }
    return false
  };

  const objectToQueryString = obj => {
    if (!isObject(obj)) {
      return ''
    }
    return (
      '?' +
      Object.keys(obj)
        .map(key => {
          return `${key}=${obj[key]}`
        })
        .join('&')
    )
  };

  const symbols = {
    route: Symbol('route'),
    hash: Symbol('hash'),
    store: Symbol('store'),
    fromHistory: Symbol('fromHistory'),
    expires: Symbol('expires'),
    resume: Symbol('resume'),
    backtrack: Symbol('backtrack'),
    historyState: Symbol('historyState'),
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g;
  const isWildcard = /^[!*$]$/;
  const hasLookupId = /\/:\w+?@@([0-9]+?)@@/;
  const isNamedGroup = /^\/:/;

  /**
   * Test if a route is part regular expressed
   * and replace it for a simple character
   * @param route
   * @returns {*}
   */
  const stripRegex = (route, char = 'R') => {
    // if route is part regular expressed we replace
    // the regular expression for a character to
    // simplify floor calculation and backtracking
    if (hasRegex.test(route)) {
      route = route.replace(hasRegex, char);
    }
    return route
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Create a local request register
   * @param flags
   * @returns {Map<any, any>}
   */
  const createRegister = flags => {
    const reg = new Map()
    // store user defined and router
    // defined flags in register
    ;[...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach(key => {
      reg.set(key, flags[key]);
    });
    return reg
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  class Request {
    constructor(hash, navArgs, storeCaller = true) {
      this._hash = hash;
      this._storeCaller = storeCaller;
      this._register = new Map();
      this._isCreated = false;
      this._isSharedInstance = false;
      this._cancelled = false;

      // if there are arguments attached to navigate()
      // we store them in new request
      if (isObject(navArgs)) {
        this._register = createRegister(navArgs);
      } else if (isBoolean(navArgs) && !navArgs) {
        // if second navigate() argument is explicitly
        // set to false we prevent the calling page
        // from ending up in history
        this._storeCaller = false;
      }
      // @todo: remove because we can simply check
      // ._storeCaller property
      this._register.set(symbols.store, this._storeCaller);
    }

    cancel() {
      console.log('cancelled:', this._hash);
      this._cancelled = true;
    }

    get url() {
      return this._hash
    }

    get register() {
      return this._register
    }

    get hash() {
      return this._hash
    }

    set hash(args) {
      this._hash = args;
    }

    get route() {
      return this._route
    }

    set route(args) {
      this._route = args;
    }

    get provider() {
      return this._provider
    }

    set provider(args) {
      this._provider = args;
    }

    get providerType() {
      return this._providerType
    }

    set providerType(args) {
      this._providerType = args;
    }

    set page(args) {
      this._page = args;
    }

    get page() {
      return this._page
    }

    set isCreated(args) {
      this._isCreated = args;
    }

    get isCreated() {
      return this._isCreated
    }

    get isSharedInstance() {
      return this._isSharedInstance
    }

    set isSharedInstance(args) {
      this._isSharedInstance = args;
    }

    get isCancelled() {
      return this._cancelled
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  class Route {
    constructor(config = {}) {
      // keep backwards compatible
      let type = ['on', 'before', 'after'].reduce((acc, type) => {
        return isFunction(config[type]) ? type : acc
      }, undefined);

      this._cfg = config;
      if (type) {
        this._provider = {
          type,
          request: config[type],
        };
      }
    }

    get path() {
      return this._cfg.path
    }

    get component() {
      return this._cfg.component
    }

    get options() {
      return this._cfg.options
    }

    get widgets() {
      return this._cfg.widgets
    }

    get cache() {
      return this._cfg.cache
    }

    get hook() {
      return this._cfg.hook
    }

    get beforeNavigate() {
      return this._cfg.beforeNavigate
    }

    get provider() {
      return this._provider
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Simple route length calculation
   * @param route {string}
   * @returns {number} - floor
   */
  const getFloor = route => {
    return stripRegex(route).split('/').length
  };

  /**
   * return all stored routes that live on the same floor
   * @param floor
   * @returns {Array}
   */
  const getRoutesByFloor = floor => {
    const matches = [];
    // simple filter of level candidates
    for (let [route] of routes.entries()) {
      if (getFloor(route) === floor) {
        matches.push(route);
      }
    }
    return matches
  };

  /**
   * return a matching route by provided hash
   * hash: home/browse/12 will match:
   * route: home/browse/:categoryId
   * @param hash {string}
   * @returns {boolean|{}} - route
   */
  const getRouteByHash = hash => {
      console.log('getRouteByHash', hash)
    // @todo: clean up on handleHash
    hash = hash.replace(/^#/, '');

    const getUrlParts = /(\/?:?[@!*\w%\s:-]+)/g;
    // grab possible candidates from stored routes
    const candidates = getRoutesByFloor(getFloor(hash));
    // break hash down in chunks
    const hashParts = hash.match(getUrlParts) || [];

    // to simplify the route matching and prevent look around
    // in our getUrlParts regex we get the regex part from
    // route candidate and store them so that we can reference
    // them when we perform the actual regex against hash
    let regexStore = [];

    let matches = candidates.filter(route => {
      let isMatching = true;
      // replace regex in route with lookup id => @@{storeId}@@
      if (hasRegex.test(route)) {
        const regMatches = route.match(hasRegex);
        if (regMatches && regMatches.length) {
          route = regMatches.reduce((fullRoute, regex) => {
            const lookupId = regexStore.length;
            fullRoute = fullRoute.replace(regex, `@@${lookupId}@@`);
            regexStore.push(regex.substring(1, regex.length - 1));
            return fullRoute
          }, route);
        }
      }

      const routeParts = route.match(getUrlParts) || [];

      for (let i = 0, j = routeParts.length; i < j; i++) {
        const routePart = routeParts[i];
        const hashPart = hashParts[i];

        // Since we support catch-all and regex driven name groups
        // we first test for regex lookup id and see if the regex
        // matches the value from the hash
        if (hasLookupId.test(routePart)) {
          const routeMatches = hasLookupId.exec(routePart);
          const storeId = routeMatches[1];
          const routeRegex = regexStore[storeId];

          // split regex and modifiers so we can use both
          // to create a new RegExp
          // eslint-disable-next-line
                  const regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex);

          if (regMatches && regMatches.length) {
            const expression = regMatches[1];
            const modifiers = regMatches[2];

            const regex = new RegExp(`^/${expression}$`, modifiers);

            if (!regex.test(hashPart)) {
              isMatching = false;
            }
          }
        } else if (isNamedGroup.test(routePart)) {
          // we kindly skip namedGroups because this is dynamic
          // we only need to the static and regex drive parts
          continue
        } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
          isMatching = false;
        }
      }
      return isMatching
    });

    if (matches.length) {
      if (matches.indexOf(hash) !== -1) {
        const match = matches[matches.indexOf(hash)];
        return routes.get(match)
      } else {
        // we give prio to static routes over dynamic
        matches = matches.sort(a => {
          return isNamedGroup.test(a) ? -1 : 1
        });
        // would be strange if this fails
        // but still we test
        if (routeExists(matches[0])) {
          return routes.get(matches[0])
        }
      }
    }
    return false
  };

  const getValuesFromHash = (hash = '', path) => {
    // replace the regex definition from the route because
    // we already did the matching part
    path = stripRegex(path, '');

    const getUrlParts = /(\/?:?[\w%\s:-]+)/g;
    const hashParts = hash.match(getUrlParts) || [];
    const routeParts = path.match(getUrlParts) || [];
    const getNamedGroup = /^\/:([\w-]+)\/?/;

    return routeParts.reduce((storage, value, index) => {
      const match = getNamedGroup.exec(value);
      if (match && match.length) {
        storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, '')));
      }
      return storage
    }, new Map())
  };

  const getOption = (stack, prop) => {
    // eslint-disable-next-line
      if(stack && stack.hasOwnProperty(prop)){
      return stack[prop]
    }
    // we explicitly return undefined since we're testing
    // for explicit test values
  };

  /**
   * create and return new Route instance
   * @param config
   */
  const createRoute = config => {
    return new Route(config)
  };
  /**
   * Create a new Router request object
   * @param url
   * @param args
   * @param store
   * @returns {*}
   */
  const createRequest = (url, args, store) => {
    return new Request(url, args, store)
  };

  const getHashByName = obj => {
    if (!obj.name) {
      return false
    }
    const route = getRouteByName(obj.name);
    const hasDynamicGroup = /\/:([\w-]+)\/?/;
    let hash = route;

    // if route contains dynamic group
    // we replace them with the provided params
    if (hasDynamicGroup.test(route)) {
      if (obj.params) {
        const keys = Object.keys(obj.params);
        hash = keys.reduce((acc, key) => {
          return acc.replace(`:${key}`, obj.params[key])
        }, route);
      }
      if (obj.query) {
        return `${hash}${objectToQueryString(obj.query)}`
      }
    }
    return hash
  };

  const getRouteByName = name => {
    for (let [path, route] of routes.entries()) {
      if (route.name === name) {
        return path
      }
    }
    return false
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var emit = (page, events = [], params = {}) => {
    if (!isArray(events)) {
      events = [events];
    }
    events.forEach(e => {
      const event = `_on${ucfirst(e)}`;
      if (isFunction(page[event])) {
        page[event](params);
      }
    });
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let activeWidget = null;

  const getReferences = () => {
    if (!widgetsHost) {
      return
    }
    return widgetsHost.get().reduce((storage, widget) => {
      const key = widget.ref.toLowerCase();
      storage[key] = widget;
      return storage
    }, {})
  };

  /**
   * update the visibility of the available widgets
   * for the current page / route
   * @param page
   */
  const updateWidgets = (widgets, page) => {
    // force lowercase lookup
    const configured = (widgets || []).map(ref => ref.toLowerCase());

    widgetsHost.forEach(widget => {
      widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1;
      if (widget.visible) {
        emit(widget, ['activated'], page);
      }
    });
    if (app.state === 'Widgets' && activeWidget && !activeWidget.visible) {
      app._setState('');
    }
  };

  const getWidgetByName = name => {
    name = ucfirst(name);
    return widgetsHost.getByRef(name) || false
  };

  /**
   * delegate app focus to a on-screen widget
   * @param name - {string}
   */
  const focusWidget = name => {
    const widget = getWidgetByName(name);
    if (widget) {
      setActiveWidget(widget);

      // if app is already in 'Widgets' state we can assume that
      // focus has been delegated from one widget to another so
      // we need to set the new widget reference and trigger a
      // new focus calculation of Lightning's focuspath
      if (app.state === 'Widgets') {
        app.reload(activeWidget);
      } else {
        app._setState('Widgets', [activeWidget]);
      }
    }
  };

  const restoreFocus = () => {
    activeWidget = null;
    app._setState('');
  };

  const getActiveWidget = () => {
    return activeWidget
  };

  const setActiveWidget = instance => {
    activeWidget = instance;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const createComponent = (stage, type) => {
    return stage.c({
      type,
      visible: false,
      widgets: getReferences(),
    })
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Simple flat array that holds the visited hashes + state Object
   * so the router can navigate back to them
   * @type {Array}
   */
  let history = [];

  const updateHistory = request => {
    const hash = getActiveHash();
      console.log('updateHistory', hash)
    if (!hash) {
      return
    }

    const activeRoute = getRouteByHash(hash);
    const register = request.register;
    const regStore = register.get(symbols.store);
    const routerConfig = getRouterConfig();

    // test preventStorage on route
    const configStore = !getOption(activeRoute.options, 'preventStorage');

    if (regStore && configStore) {
      const toStore = hash.replace(/^\//, '');
      const location = locationInHistory(toStore);
      const stateObject = getStateObject(getActivePage());

      // store hash if it's not a part of history or flag for
      // storage of same hash is true
      if (location === -1 || routerConfig.get('storeSameHash')) {
        history.push({ hash: toStore, state: stateObject });
      } else {
        // if we visit the same route we want to sync history
        const prev = history.splice(location, 1)[0];
        history.push({ hash: prev.hash, state: stateObject });
      }
    }
  };

  const locationInHistory = hash => {
    for (let i = 0; i < history.length; i++) {
      if (history[i].hash === hash) {
        return i
      }
    }
    return -1
  };

  const getHistoryState = hash => {
    let state = null;
    if (history.length) {
      // if no hash is provided we get the last
      // pushed history record
      if (!hash) {
        const record = history[history.length - 1];
        // could be null
        state = record.state;
      } else {
        if (locationInHistory(hash) !== -1) {
          const record = history[locationInHistory(hash)];
          state = record.state;
        }
      }
    }
    return state
  };

  const replaceHistoryState = (state = null, hash) => {
    if (!history.length) {
      return
    }
    const location = hash ? locationInHistory(hash) : history.length - 1;
    if (location !== -1 && isObject(state)) {
      history[location].state = state;
    }
  };

  const getStateObject = page => {
    if (page && isFunction(page.historyState)) {
      return page.historyState()
    }
    return null
  };

  const getHistory = () => {
    return history.slice(0)
  };

  const setHistory = (arr = []) => {
    if (isArray(arr)) {
      history = arr;
    }
  };

  var isMergeableObject = function isMergeableObject(value) {
  	return isNonNullObject(value)
  		&& !isSpecial(value)
  };

  function isNonNullObject(value) {
  	return !!value && typeof value === 'object'
  }

  function isSpecial(value) {
  	var stringValue = Object.prototype.toString.call(value);

  	return stringValue === '[object RegExp]'
  		|| stringValue === '[object Date]'
  		|| isReactElement(value)
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

  function isReactElement(value) {
  	return value.$$typeof === REACT_ELEMENT_TYPE
  }

  function emptyTarget(val) {
  	return Array.isArray(val) ? [] : {}
  }

  function cloneUnlessOtherwiseSpecified(value, options) {
  	return (options.clone !== false && options.isMergeableObject(value))
  		? deepmerge(emptyTarget(value), value, options)
  		: value
  }

  function defaultArrayMerge(target, source, options) {
  	return target.concat(source).map(function(element) {
  		return cloneUnlessOtherwiseSpecified(element, options)
  	})
  }

  function getMergeFunction(key, options) {
  	if (!options.customMerge) {
  		return deepmerge
  	}
  	var customMerge = options.customMerge(key);
  	return typeof customMerge === 'function' ? customMerge : deepmerge
  }

  function getEnumerableOwnPropertySymbols(target) {
  	return Object.getOwnPropertySymbols
  		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
  			return target.propertyIsEnumerable(symbol)
  		})
  		: []
  }

  function getKeys(target) {
  	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
  }

  function propertyIsOnObject(object, property) {
  	try {
  		return property in object
  	} catch(_) {
  		return false
  	}
  }

  // Protects from prototype poisoning and unexpected merging up the prototype chain.
  function propertyIsUnsafe(target, key) {
  	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
  		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
  			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
  }

  function mergeObject(target, source, options) {
  	var destination = {};
  	if (options.isMergeableObject(target)) {
  		getKeys(target).forEach(function(key) {
  			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
  		});
  	}
  	getKeys(source).forEach(function(key) {
  		if (propertyIsUnsafe(target, key)) {
  			return
  		}

  		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
  			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
  		} else {
  			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
  		}
  	});
  	return destination
  }

  function deepmerge(target, source, options) {
  	options = options || {};
  	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
  	// implementations can use it. The caller may not replace it.
  	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

  	var sourceIsArray = Array.isArray(source);
  	var targetIsArray = Array.isArray(target);
  	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  	if (!sourceAndTargetTypesMatch) {
  		return cloneUnlessOtherwiseSpecified(source, options)
  	} else if (sourceIsArray) {
  		return options.arrayMerge(target, source, options)
  	} else {
  		return mergeObject(target, source, options)
  	}
  }

  deepmerge.all = function deepmergeAll(array, options) {
  	if (!Array.isArray(array)) {
  		throw new Error('first argument should be an array')
  	}

  	return array.reduce(function(prev, next) {
  		return deepmerge(prev, next, options)
  	}, {})
  };

  var deepmerge_1 = deepmerge;

  var cjs = deepmerge_1;

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let warned = false;
  const deprecated = (force = false) => {
    if (force === true || warned === false) {
      console.warn(
        [
          "The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
          "Please consider using the new 'Language'-plugin instead.",
          'https://rdkcentral.github.io/Lightning-SDK/#/plugins/language',
        ].join('\n\n')
      );
    }
    warned = true;
  };
  class Locale {
    constructor() {
      this.__enabled = false;
    }

    /**
     * Loads translation object from external json file.
     *
     * @param {String} path Path to resource.
     * @return {Promise}
     */
    async load(path) {
      if (!this.__enabled) {
        return
      }

      await fetch(path)
        .then(resp => resp.json())
        .then(resp => {
          this.loadFromObject(resp);
        });
    }

    /**
     * Sets language used by module.
     *
     * @param {String} lang
     */
    setLanguage(lang) {
      deprecated();
      this.__enabled = true;
      this.language = lang;
    }

    /**
     * Returns reference to translation object for current language.
     *
     * @return {Object}
     */
    get tr() {
      deprecated(true);
      return this.__trObj[this.language]
    }

    /**
     * Loads translation object from existing object (binds existing object).
     *
     * @param {Object} trObj
     */
    loadFromObject(trObj) {
      deprecated();
      const fallbackLanguage = 'en';
      if (Object.keys(trObj).indexOf(this.language) === -1) {
        Log.warn('No translations found for: ' + this.language);
        if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
          Log.warn('Using fallback language: ' + fallbackLanguage);
          this.language = fallbackLanguage;
        } else {
          const error = 'No translations found for fallback language: ' + fallbackLanguage;
          Log.error(error);
          throw Error(error)
        }
      }

      this.__trObj = trObj;
      for (const lang of Object.values(this.__trObj)) {
        for (const str of Object.keys(lang)) {
          lang[str] = new LocalizedString(lang[str]);
        }
      }
    }
  }

  /**
   * Extended string class used for localization.
   */
  class LocalizedString extends String {
    /**
     * Returns formatted LocalizedString.
     * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
     *
     * E.g.:
     * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
     * A and B and A
     *
     * @param  {...any} args List of arguments for placeholders.
     */
    format(...args) {
      const sub = args.reduce((string, arg, index) => string.split(`{${index}}`).join(arg), this);
      return new LocalizedString(sub)
    }
  }

  var Locale$1 = new Locale();

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  class VersionLabel extends lightning.Component {
    static _template() {
      return {
        rect: true,
        color: 0xbb0078ac,
        h: 40,
        w: 100,
        x: w => w - 50,
        y: h => h - 50,
        mount: 1,
        Text: {
          w: w => w,
          h: h => h,
          y: 5,
          x: 20,
          text: {
            fontSize: 22,
            lineHeight: 26,
          },
        },
      }
    }

    _firstActive() {
      this.tag('Text').text = `APP - v${this.version}\nSDK - v${this.sdkVersion}`;
      this.tag('Text').loadTexture();
      this.w = this.tag('Text').renderWidth + 40;
      this.h = this.tag('Text').renderHeight + 5;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class FpsIndicator extends lightning.Component {
    static _template() {
      return {
        rect: true,
        color: 0xffffffff,
        texture: lightning.Tools.getRoundRect(80, 80, 40),
        h: 80,
        w: 80,
        x: 100,
        y: 100,
        mount: 1,
        Background: {
          x: 3,
          y: 3,
          texture: lightning.Tools.getRoundRect(72, 72, 36),
          color: 0xff008000,
        },
        Counter: {
          w: w => w,
          h: h => h,
          y: 10,
          text: {
            fontSize: 32,
            textAlign: 'center',
          },
        },
        Text: {
          w: w => w,
          h: h => h,
          y: 48,
          text: {
            fontSize: 15,
            textAlign: 'center',
            text: 'FPS',
          },
        },
      }
    }

    _setup() {
      this.config = {
        ...{
          log: false,
          interval: 500,
          threshold: 1,
        },
        ...Settings.get('platform', 'showFps'),
      };

      this.fps = 0;
      this.lastFps = this.fps - this.config.threshold;

      const fpsCalculator = () => {
        this.fps = ~~(1 / this.stage.dt);
      };
      this.stage.on('frameStart', fpsCalculator);
      this.stage.off('framestart', fpsCalculator);
      this.interval = setInterval(this.showFps.bind(this), this.config.interval);
    }

    _firstActive() {
      this.showFps();
    }

    _detach() {
      clearInterval(this.interval);
    }

    showFps() {
      if (Math.abs(this.lastFps - this.fps) <= this.config.threshold) return
      this.lastFps = this.fps;
      // green
      let bgColor = 0xff008000;
      // orange
      if (this.fps <= 40 && this.fps > 20) bgColor = 0xffffa500;
      // red
      else if (this.fps <= 20) bgColor = 0xffff0000;

      this.tag('Background').setSmooth('color', bgColor);
      this.tag('Counter').text = `${this.fps}`;

      this.config.log && Log.info('FPS', this.fps);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let meta = {};
  let translations = {};
  let language = null;

  const initLanguage = (file, language = null) => {
    return new Promise((resolve, reject) => {
      fetch(file)
        .then(response => response.json())
        .then(json => {
          setTranslations(json);
          // set language (directly or in a promise)
          typeof language === 'object' && 'then' in language && typeof language.then === 'function'
            ? language
                .then(lang =>
                  setLanguage(lang)
                    .then(resolve)
                    .catch(reject)
                )
                .catch(e => {
                  Log.error(e);
                  reject(e);
                })
            : setLanguage(language)
                .then(resolve)
                .catch(reject);
        })
        .catch(() => {
          const error = 'Language file ' + file + ' not found';
          Log.error(error);
          reject(error);
        });
    })
  };

  const setTranslations = obj => {
    if ('meta' in obj) {
      meta = { ...obj.meta };
      delete obj.meta;
    }
    translations = obj;
  };

  const setLanguage = lng => {
    language = null;

    return new Promise((resolve, reject) => {
      if (lng in translations) {
        language = lng;
      } else {
        if ('map' in meta && lng in meta.map && meta.map[lng] in translations) {
          language = meta.map[lng];
        } else if ('default' in meta && meta.default in translations) {
          language = meta.default;
          const error =
            'Translations for Language ' +
            language +
            ' not found. Using default language ' +
            meta.default;
          Log.warn(error);
          reject(error);
        } else {
          const error = 'Translations for Language ' + language + ' not found.';
          Log.error(error);
          reject(error);
        }
      }

      if (language) {
        Log.info('Setting language to', language);

        const translationsObj = translations[language];
        if (typeof translationsObj === 'object') {
          resolve();
        } else if (typeof translationsObj === 'string') {
          const url = Utils.asset(translationsObj);

          fetch(url)
            .then(response => response.json())
            .then(json => {
              // save the translations for this language (to prevent loading twice)
              translations[language] = json;
              resolve();
            })
            .catch(e => {
              const error = 'Error while fetching ' + url;
              Log.error(error, e);
              reject(error);
            });
        }
      }
    })
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const registry = {
    eventListeners: [],
    timeouts: [],
    intervals: [],
    targets: [],
  };

  var Registry = {
    // Timeouts
    setTimeout(cb, timeout, ...params) {
      const timeoutId = setTimeout(
        () => {
          registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
          cb.apply(null, params);
        },
        timeout,
        params
      );
      Log.info('Set Timeout', 'ID: ' + timeoutId);
      registry.timeouts.push(timeoutId);
      return timeoutId
    },

    clearTimeout(timeoutId) {
      if (registry.timeouts.indexOf(timeoutId) > -1) {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
        Log.info('Clear Timeout', 'ID: ' + timeoutId);
        clearTimeout(timeoutId);
      } else {
        Log.error('Clear Timeout', 'ID ' + timeoutId + ' not found');
      }
    },

    clearTimeouts() {
      registry.timeouts.forEach(timeoutId => {
        this.clearTimeout(timeoutId);
      });
    },

    // Intervals
    setInterval(cb, interval, ...params) {
      const intervalId = setInterval(
        () => {
          registry.intervals.filter(id => id !== intervalId);
          cb.apply(null, params);
        },
        interval,
        params
      );
      Log.info('Set Interval', 'ID: ' + intervalId);
      registry.intervals.push(intervalId);
      return intervalId
    },

    clearInterval(intervalId) {
      if (registry.intervals.indexOf(intervalId) > -1) {
        registry.intervals = registry.intervals.filter(id => id !== intervalId);
        Log.info('Clear Interval', 'ID: ' + intervalId);
        clearInterval(intervalId);
      } else {
        Log.error('Clear Interval', 'ID ' + intervalId + ' not found');
      }
    },

    clearIntervals() {
      registry.intervals.forEach(intervalId => {
        this.clearInterval(intervalId);
      });
    },

    // Event listeners
    addEventListener(target, event, handler) {
      target.addEventListener(event, handler);
      const targetIndex =
        registry.targets.indexOf(target) > -1
          ? registry.targets.indexOf(target)
          : registry.targets.push(target) - 1;

      registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {};
      registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || [];
      registry.eventListeners[targetIndex][event].push(handler);
      Log.info('Add eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler);
    },

    removeEventListener(target, event, handler) {
      const targetIndex = registry.targets.indexOf(target);
      if (
        targetIndex > -1 &&
        registry.eventListeners[targetIndex] &&
        registry.eventListeners[targetIndex][event] &&
        registry.eventListeners[targetIndex][event].indexOf(handler) > -1
      ) {
        registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][
          event
        ].filter(fn => fn !== handler);
        Log.info('Remove eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler);
        target.removeEventListener(event, handler);
      } else {
        Log.error(
          'Remove eventListener',
          'Not found',
          'Target',
          target,
          'Event: ' + event,
          'Handler',
          handler
        );
      }
    },

    // if `event` is omitted, removes all registered event listeners for target
    // if `target` is also omitted, removes all registered event listeners
    removeEventListeners(target, event) {
      if (target && event) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          registry.eventListeners[targetIndex][event].forEach(handler => {
            this.removeEventListener(target, event, handler);
          });
        }
      } else if (target) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          Object.keys(registry.eventListeners[targetIndex]).forEach(_event => {
            this.removeEventListeners(target, _event);
          });
        }
      } else {
        Object.keys(registry.eventListeners).forEach(targetIndex => {
          this.removeEventListeners(registry.targets[targetIndex]);
        });
      }
    },

    // Clear everything (to be called upon app close for proper cleanup)
    clear() {
      this.clearTimeouts();
      this.clearIntervals();
      this.removeEventListeners();
      registry.eventListeners = [];
      registry.timeouts = [];
      registry.intervals = [];
      registry.targets = [];
    },
  };

  const isObject$1 = v => {
    return typeof v === 'object' && v !== null
  };

  const isString$1 = v => {
    return typeof v === 'string'
  };

  let colors = {
    white: '#ffffff',
    black: '#000000',
    red: '#ff0000',
    green: '#00ff00',
    blue: '#0000ff',
    yellow: '#feff00',
    cyan: '#00feff',
    magenta: '#ff00ff',
  };

  const normalizedColors = {
    //store for normalized colors
  };

  const addColors = (colorsToAdd, value) => {
    if (isObject$1(colorsToAdd)) {
      // clean up normalizedColors if they exist in the to be added colors
      Object.keys(colorsToAdd).forEach(color => cleanUpNormalizedColors(color));
      colors = Object.assign({}, colors, colorsToAdd);
    } else if (isString$1(colorsToAdd) && value) {
      cleanUpNormalizedColors(colorsToAdd);
      colors[colorsToAdd] = value;
    }
  };

  const cleanUpNormalizedColors = color => {
    for (let c in normalizedColors) {
      if (c.indexOf(color) > -1) {
        delete normalizedColors[c];
      }
    }
  };

  const initColors = file => {
    return new Promise((resolve, reject) => {
      if (typeof file === 'object') {
        addColors(file);
        resolve();
      }
      fetch(file)
        .then(response => response.json())
        .then(json => {
          addColors(json);
          resolve();
        })
        .catch(() => {
          const error = 'Colors file ' + file + ' not found';
          Log.error(error);
          reject(error);
        });
    })
  };

  var version = "4.2.1";

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let AppInstance;

  const defaultOptions = {
    stage: { w: 1920, h: 1080, clearColor: 0x00000000, canvas2d: false },
    debug: false,
    defaultFontFace: 'RobotoRegular',
    keys: {
      8: 'Back',
      13: 'Enter',
      27: 'Menu',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      174: 'ChannelDown',
      175: 'ChannelUp',
      178: 'Stop',
      250: 'PlayPause',
      191: 'Search', // Use "/" for keyboard
      409: 'Search',
    },
  };

  if (window.innerHeight === 720) {
    defaultOptions.stage['w'] = 1280;
    defaultOptions.stage['h'] = 720;
    defaultOptions.stage['precision'] = 0.6666666667;
  }

  function Application(App, appData, platformSettings) {
    return class Application extends lightning.Application {
      constructor(options) {
        const config = cjs(defaultOptions, options);
        super(config);
        this.config = config;
      }

      static _template() {
        return {
          w: 1920,
          h: 1080,
        }
      }

      _setup() {
        Promise.all([
          this.loadFonts((App.config && App.config.fonts) || (App.getFonts && App.getFonts()) || []),
          // to be deprecated
          Locale$1.load((App.config && App.config.locale) || (App.getLocale && App.getLocale())),
          App.language && this.loadLanguage(App.language()),
          App.colors && this.loadColors(App.colors()),
        ])
          .then(() => {
            Metrics$1.app.loaded();

            AppInstance = this.stage.c({
              ref: 'App',
              type: App,
              zIndex: 1,
              forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps,
            });

            this.childList.a(AppInstance);

            Log.info('App version', this.config.version);
            Log.info('SDK version', version);

            if (platformSettings.showVersion) {
              this.childList.a({
                ref: 'VersionLabel',
                type: VersionLabel,
                version: this.config.version,
                sdkVersion: version,
                zIndex: 1,
              });
            }

            if (platformSettings.showFps) {
              this.childList.a({
                ref: 'FpsCounter',
                type: FpsIndicator,
                zIndex: 1,
              });
            }

            super._setup();
          })
          .catch(console.error);
      }

      _handleBack() {
        this.closeApp();
      }

      _handleExit() {
        this.closeApp();
      }

      closeApp() {
        Log.info('Closing App');

        Settings.clearSubscribers();
        Registry.clear();

        if (platformSettings.onClose && typeof platformSettings.onClose === 'function') {
          platformSettings.onClose(...arguments);
        } else {
          this.close();
        }
      }

      close() {
        Log.info('Closing App');
        this.childList.remove(this.tag('App'));

        // force texture garbage collect
        this.stage.gc();
        this.destroy();
      }

      loadFonts(fonts) {
        return new Promise((resolve, reject) => {
          fonts
            .map(({ family, url, descriptors }) => () => {
              const fontFace = new FontFace(family, 'url(' + url + ')', descriptors || {});
              document.fonts.add(fontFace);
              return fontFace.load()
            })
            .reduce((promise, method) => {
              return promise.then(() => method())
            }, Promise.resolve(null))
            .then(resolve)
            .catch(reject);
        })
      }

      loadLanguage(config) {
        let file = Utils.asset('translations.json');
        let language = config;

        if (typeof language === 'object') {
          language = config.language || null;
          file = config.file || file;
        }

        return initLanguage(file, language)
      }

      loadColors(config) {
        let file = Utils.asset('colors.json');
        if (config && (typeof config === 'string' || typeof config === 'object')) {
          file = config;
        }
        return initColors(file)
      }

      set focus(v) {
        this._focussed = v;
        this._refocus();
      }

      _getFocused() {
        return this._focussed || this.tag('App')
      }
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @type {Lightning.Application}
   */
  let application;

  /**
   * Actual instance of the app
   * @type {Lightning.Component}
   */
  let app;

  /**
   * Component that hosts all routed pages
   * @type {Lightning.Component}
   */
  let pagesHost;

  /**
   * @type {Lightning.Stage}
   */
  let stage;

  /**
   * Platform driven Router configuration
   * @type {Map<string>}
   */
  let routerConfig;

  /**
   * Component that hosts all attached widgets
   * @type {Lightning.Component}
   */
  let widgetsHost;

  /**
   * Hash we point the browser to when we boot the app
   * and there is no deep-link provided
   * @type {string|Function}
   */
  let rootHash;

  /**
   * Boot request will fire before app start
   * can be used to execute some global logic
   * and can be configured
   */
  let bootRequest;

  /**
   * Flag if we need to update the browser location hash.
   * Router can work without.
   * @type {boolean}
   */
  let updateHash = true;

  /**
   * Will be called before a route starts, can be overridden
   * via routes config
   * @param from - route we came from
   * @param to - route we navigate to
   * @returns {Promise<*>}
   */
  // eslint-disable-next-line
  let beforeEachRoute = async (from, to)=>{
    return true
  };

  /**
   * Will be called after a navigate successfully resolved,
   * can be overridden via routes config
   * @param request - request object
   */
  let afterEachRoute = async request => {
    return true
  };

  /**
   * All configured routes
   * @type {Map<string, object>}
   */
  let routes = new Map();

  /**
   * Store all page components per route
   * @type {Map<string, object>}
   */
  let components = new Map();

  /**
   * Flag if router has been initialised
   * @type {boolean}
   */
  let initialised = false;

  /**
   * Current page being rendered on screen
   * @type {null}
   */

  let activeHash;
  let activePage = null;
  let activeRoute;

  /**
   *  During the process of a navigation request a new
   *  request can start, to prevent unwanted behaviour
   *  the navigate()-method stores the last accepted hash
   *  so we can invalidate any prior requests
   */
  let lastAcceptedHash;

  /**
   * With on()-data providing behaviour the Router forced the App
   * in a Loading state. When the data-provider resolves we want to
   * change the state back to where we came from
   */
  let previousState;

  const mixin = app => {
    // by default the Router Baseclass provides the component
    // reference in which we store our pages
    if (app.pages) {
      pagesHost = app.pages.childList;
    }
    // if the app is using widgets we grab refs
    // and hide all the widgets
    if (app.widgets && app.widgets.children) {
      widgetsHost = app.widgets.childList;
      // hide all widgets on boot
      widgetsHost.forEach(w => (w.visible = false));
    }
    app._handleBack = e => {
      step(-1);
      e.preventDefault();
    };
  };

  const bootRouter = (config, instance) => {
    let { appInstance, routes } = config;

    // if instance is provided and it's and Lightning Component instance
    if (instance && isPage(instance)) {
      app = instance;
    }
    if (!app) {
      app = appInstance || AppInstance;
    }

    application = app.application;
    pagesHost = application.childList;
    stage = app.stage;
    routerConfig = getConfigMap();

    mixin(app);

    if (isArray(routes)) {
      setup(config);
    } else if (isFunction(routes)) {
      console.warn('[Router]: Calling Router.route() directly is deprecated.');
      console.warn(
        'Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration'
      );
    }
  };

  const setup = config => {
    if (!initialised) {
      init(config);
    }
    config.routes.forEach(r => {
      // strip leading slash
      const path = r.path.replace(/\/+$/, '');
      if (!routeExists(path)) {
        const route = createRoute(r);
        routes.set(path, route);
        // if route has a configured component property
        // we store it in a different map to simplify
        // the creating and destroying per route
        if (route.component) {
          let type = route.component;
          if (isComponentConstructor(type)) {
            if (!routerConfig.get('lazyCreate')) {
              type = createComponent(stage, type);
              pagesHost.a(type);
            }
          }
          components.set(path, type);
        }
      } else {
        console.error(`${path} already exists in routes configuration`);
      }
    });
  };

  const init = config => {
    rootHash = config.root;
    if (isFunction(config.boot)) {
      bootRequest = config.boot;
    }
    if (isBoolean(config.updateHash)) {
      updateHash = config.updateHash;
    }
    if (isFunction(config.beforeEachRoute)) {
      beforeEachRoute = config.beforeEachRoute;
    }
    if (isFunction(config.afterEachRoute)) {
      afterEachRoute = config.afterEachRoute;
    }
    if (config.bootComponent) {
      if (isPage(config.bootComponent)) {
        config.routes.push({
          path: '@router-boot-page',
          component: config.bootComponent,
        });
      } else {
        console.error(`[Router]: ${config.bootComponent} is not a valid boot component`);
      }
    }
    initialised = true;
  };

  const storeComponent = (route, type) => {
    if (components.has(route)) {
      components.set(route, type);
    }
  };

  const getComponent = route => {
    if (components.has(route)) {
      return components.get(route)
    }
    return null
  };
  /**
   * Test if router needs to update browser location hash
   * @returns {boolean}
   */
  const mustUpdateLocationHash = () => {
    // we need support to either turn change hash off
    // per platform or per app
    const updateConfig = routerConfig.get('updateHash');
    return !((isBoolean(updateConfig) && !updateConfig) || (isBoolean(updateHash) && !updateHash))
  };

  /**
   * Will be called when a new navigate() request has completed
   * and has not been expired due to it's async nature
   * @param request
   */
  const onRequestResolved = request => {
    const hash = request.hash;
    const route = request.route;
    const register = request.register;
    const page = request.page;

    // clean up history if modifier is set
    if (getOption(route.options, 'clearHistory')) {
      setHistory([]);
    } else if (hash && !isWildcard.test(route.path)) {
      updateHistory(request);
    }

    // we only update the stackLocation if a route
    // is not expired before it resolves
    storeComponent(route.path, page);

    if (request.isSharedInstance || !request.isCreated) {
      emit(page, 'changed');
    } else if (request.isCreated) {
      emit(page, 'mounted');
    }

    // only update widgets if we have a host
    if (widgetsHost) {
      updateWidgets(route.widgets, page);
    }

    // we want to clean up if there is an
    // active page that is not being shared
    // between current and previous route
    if (getActivePage() && !request.isSharedInstance) {
      cleanUp(activePage, request);
    }

    if (register.get(symbols.historyState) && isFunction(page.historyState)) {
      page.historyState(register.get(symbols.historyState));
    }

    setActivePage(page);

    activeHash = request.hash;
    activeRoute = route.path;

    afterEachRoute(request).then(() => {
      // silent
    });

    Log.info('[route]:', route.path);
    Log.info('[hash]:', hash);
  };

  const cleanUp = (page, request) => {
    const route = activeRoute;
    const register = request.register;
    const lazyDestroy = routerConfig.get('lazyDestroy');
    const destroyOnBack = routerConfig.get('destroyOnHistoryBack');
    const keepAlive = register.get('keepAlive');
    const isFromHistory = register.get(symbols.backtrack);

    let doCleanup = false;

    if (isFromHistory && (destroyOnBack || lazyDestroy)) {
      doCleanup = true;
    } else if (lazyDestroy && !keepAlive) {
      doCleanup = true;
    }

    if (doCleanup) {
      // grab original class constructor if
      // statemachine routed else store constructor
      storeComponent(route, page._routedType || page.constructor);

      // actual remove of page from memory
      pagesHost.remove(page);

      // force texture gc() if configured
      // so we can cleanup textures in the same tick
      if (routerConfig.get('gcOnUnload')) {
        stage.gc();
      }
    } else {
      // If we're not removing the page we need to
      // reset it's properties
      page.patch({
        x: 0,
        y: 0,
        scale: 1,
        alpha: 1,
        visible: false,
      });
    }
  };

  const getActiveHash = () => {
    return activeHash
  };

  const setActivePage = page => {
    activePage = page;
  };

  const getActivePage = () => {
    return activePage
  };

  const getActiveRoute = () => {
    return activeRoute
  };

  const getLastHash = () => {
    return lastAcceptedHash
  };

  const setLastHash = hash => {
    lastAcceptedHash = hash;
  };

  const getPreviousState = () => {
    return previousState
  };

  const routeExists = key => {
    return routes.has(key)
  };

  const getRootHash = () => {
    return rootHash
  };

  const getBootRequest = () => {
    return bootRequest
  };

  const getRouterConfig = () => {
    return routerConfig
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const types = {
    on: request => {
      app.state || '';
      app._setState('Loading');
      return execProvider(request)
    },
    before: request => {
      return execProvider(request)
    },
    after: request => {
      try {
        execProvider(request);
      } catch (e) {
        // for now we fail silently
      }
      return Promise.resolve()
    },
    // on route share instance
    shared: request => {
      return execProvider(request)
    },
  };

  const execProvider = request => {
    const route = request.route;
    const provider = route.provider;
    const expires = route.cache ? route.cache * 1000 : 0;
    const params = addPersistData(request);
    return provider.request(request.page, { ...params }).then(() => {
      request.page[symbols.expires] = Date.now() + expires;
    })
  };

  const addPersistData = ({ page, route, hash, register = new Map() }) => {
    const urlValues = getValuesFromHash(hash, route.path);
    const pageData = new Map([...urlValues, ...register]);
    const params = {};

    // make dynamic url data available to the page
    // as instance properties
    for (let [name, value] of pageData) {
      // @todo: show page prop deprecation in changelog
      // page[name] = value;
      params[name] = value;
    }

    // check navigation register for persistent data
    if (register.size) {
      const obj = {};
      for (let [k, v] of register) {
        obj[k] = v;
      }
      page.persist = obj;
    }

    // make url data and persist data available
    // via params property
    page.params = params;
    emit(page, ['urlParams'], params);

    return params
  };

  /**
   * Test if page passed cache-time
   * @param page
   * @returns {boolean}
   */
  const isPageExpired = page => {
    if (!page[symbols.expires]) {
      return false
    }

    const expires = page[symbols.expires];
    const now = Date.now();

    return now >= expires
  };

  const hasProvider = path => {
    if (routeExists(path)) {
      const record = routes.get(path);
      return !!record.provider
    }
    return false
  };

  const getProvider = route => {
    // @todo: fix, route already is passed in
    if (routeExists(route.path)) {
      const { provider } = routes.get(route.path);
      return {
        type: provider.type,
        provider: provider.request,
      }
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const fade = (i, o) => {
    return new Promise(resolve => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, { duration: 0.5, delay: 0.1 }],
        },
      });
      // resolve on y finish
      i.transition('alpha').on('finish', () => {
        if (o) {
          o.visible = false;
        }
        resolve();
      });
    })
  };

  const crossFade = (i, o) => {
    return new Promise(resolve => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, { duration: 0.5, delay: 0.1 }],
        },
      });
      if (o) {
        o.patch({
          smooth: {
            alpha: [0, { duration: 0.5, delay: 0.3 }],
          },
        });
      }
      // resolve on y finish
      i.transition('alpha').on('finish', () => {
        resolve();
      });
    })
  };

  const moveOnAxes = (axis, direction, i, o) => {
    const bounds = axis === 'x' ? 1920 : 1080;
    return new Promise(resolve => {
      i.patch({
        [`${axis}`]: direction ? bounds * -1 : bounds,
        visible: true,
        smooth: {
          [`${axis}`]: [0, { duration: 0.4, delay: 0.2 }],
        },
      });
      // out is optional
      if (o) {
        o.patch({
          [`${axis}`]: 0,
          smooth: {
            [`${axis}`]: [direction ? bounds : bounds * -1, { duration: 0.4, delay: 0.2 }],
          },
        });
      }
      // resolve on y finish
      i.transition(axis).on('finish', () => {
        resolve();
      });
    })
  };

  const up = (i, o) => {
    return moveOnAxes('y', 0, i, o)
  };

  const down = (i, o) => {
    return moveOnAxes('y', 1, i, o)
  };

  const left = (i, o) => {
    return moveOnAxes('x', 0, i, o)
  };

  const right = (i, o) => {
    return moveOnAxes('x', 1, i, o)
  };

  var Transitions = {
    fade,
    crossFade,
    up,
    down,
    left,
    right,
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * execute transition between new / old page and
   * toggle the defined widgets
   * @todo: platform override default transition
   * @param pageIn
   * @param pageOut
   */
  const executeTransition = (pageIn, pageOut = null) => {
    const transition = pageIn.pageTransition || pageIn.easing;
    const hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition);
    const transitionsDisabled = getRouterConfig().get('disableTransitions');

    if (pageIn.easing) {
      console.warn('easing() method is deprecated and will be removed. Use pageTransition()');
    }

    // default behaviour is a visibility toggle
    if (!hasCustomTransitions || transitionsDisabled) {
      pageIn.visible = true;
      if (pageOut) {
        pageOut.visible = false;
      }
      return Promise.resolve()
    }

    if (transition) {
      let type;
      try {
        type = transition.call(pageIn, pageIn, pageOut);
      } catch (e) {
        type = 'crossFade';
      }

      if (isPromise(type)) {
        return type
      }

      if (isString(type)) {
        const fn = Transitions[type];
        if (fn) {
          return fn(pageIn, pageOut)
        }
      }

      // keep backwards compatible for now
      if (pageIn.smoothIn) {
        // provide a smooth function that resolves itself
        // on transition finish
        const smooth = (p, v, args = {}) => {
          return new Promise(resolve => {
            pageIn.visible = true;
            pageIn.setSmooth(p, v, args);
            pageIn.transition(p).on('finish', () => {
              resolve();
            });
          })
        };
        return pageIn.smoothIn({ pageIn, smooth })
      }
    }
    return Transitions.crossFade(pageIn, pageOut)
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * The actual loading of the component
   * */
  const load = async request => {
    let expired = false;
    try {
      request = await loader(request);
      if (request && !request.isCancelled) {
        // in case of on() providing we need to reset
        // app state;
        if (app.state === 'Loading') {
          if (getPreviousState() === 'Widgets') ; else {
            app._setState('');
          }
        }
        // Do page transition if instance
        // is not shared between the routes
        if (!request.isSharedInstance && !request.isCancelled) {
          await executeTransition(request.page, getActivePage());
        }
      } else {
        expired = true;
      }
      // on expired we only cleanup
      if (expired || request.isCancelled) {
        Log.debug('[router]:', `Rejected ${request.hash} because route to ${getLastHash()} started`);
        if (request.isCreated && !request.isSharedInstance) {
          // remove from render-tree
          pagesHost.remove(request.page);
        }
      } else {
        onRequestResolved(request);
        // resolve promise
        return request.page
      }
    } catch (request) {
      if (!request.route) {
        console.error(request);
      } else if (!expired) {
        // @todo: revisit
        const { route } = request;
        // clean up history if modifier is set
        if (getOption(route.options, 'clearHistory')) {
          setHistory([]);
        } else if (!isWildcard.test(route.path)) {
          updateHistory(request);
        }

        if (request.isCreated && !request.isSharedInstance) {
          // remove from render-tree
          pagesHost.remove(request.page);
        }
        handleError(request);
      }
    }
  };

  const loader = async request => {
    const route = request.route;
    const hash = request.hash;
    const register = request.register;

    // todo: grab from Route instance
    let type = getComponent(route.path);
    let isConstruct = isComponentConstructor(type);
    let provide = false;

    // if it's an instance bt we're not coming back from
    // history we test if we can re-use this instance
    if (!isConstruct && !register.get(symbols.backtrack)) {
      if (!mustReuse(route)) {
        type = type.constructor;
        isConstruct = true;
      }
    }

    // If type is not a constructor
    if (!isConstruct) {
      request.page = type;
      // if we have have a data route for current page
      if (hasProvider(route.path)) {
        if (isPageExpired(type) || type[symbols.hash] !== hash) {
          provide = true;
        }
      }
      let currentRoute = getActivePage() && getActivePage()[symbols.route];
      // if the new route is equal to the current route it means that both
      // route share the Component instance and stack location / since this case
      // is conflicting with the way before() and after() loading works we flag it,
      // and check platform settings in we want to re-use instance
      if (route.path === currentRoute) {
        request.isSharedInstance = true;
      }
    } else {
      request.page = createComponent(stage, type);
      pagesHost.a(request.page);
      // test if need to request data provider
      if (hasProvider(route.path)) {
        provide = true;
      }
      request.isCreated = true;
    }

    // we store hash and route as properties on the page instance
    // that way we can easily calculate new behaviour on page reload
    request.page[symbols.hash] = hash;
    request.page[symbols.route] = route.path;

    try {
      if (provide) {
        // extract attached data-provider for route
        // we're processing
        const { type: loadType, provider } = getProvider(route);

        // update running request
        request.provider = provider;
        request.providerType = loadType;

        await types[request.isSharedInstance ? 'shared' : loadType](request);

        // we early exit if the current request is expired
        if (hash !== getLastHash()) {
          return false
        } else {
          emit(request.page, 'dataProvided');
          // resolve promise
          return request
        }
      } else {
        addPersistData(request);
        return request
      }
    } catch (e) {
      request.error = e;
      return Promise.reject(request)
    }
  };

  const handleError = request => {
    if (request && request.error) {
      console.error(request.error);
    } else if (request) {
      Log.error(request);
    }

    if (request.page) {
      navigate('!', { request }, false);
    }
  };

  const mustReuse = route => {
    const opt = getOption(route.options, 'reuseInstance');
    const config = routerConfig.get('reuseInstance');

    // route always has final decision
    if (isBoolean(opt)) {
      return opt
    }
    return !(isBoolean(config) && config === false)
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  class RoutedApp extends lightning.Component {
    static _template() {
      return {
        Pages: {
          forceZIndexContext: true,
        },
        /**
         * This is a default Loading page that will be made visible
         * during data-provider on() you CAN override in child-class
         */
        Loading: {
          rect: true,
          w: 1920,
          h: 1080,
          color: 0xff000000,
          visible: false,
          zIndex: 99,
          Label: {
            mount: 0.5,
            x: 960,
            y: 540,
            text: {
              text: 'Loading..',
            },
          },
        },
      }
    }

    static _states() {
      return [
        class Loading extends this {
          $enter() {
            this.tag('Loading').visible = true;
          }

          $exit() {
            this.tag('Loading').visible = false;
          }
        },
        class Widgets extends this {
          $enter(args, widget) {
            // store widget reference
            this._widget = widget;

            // since it's possible that this behaviour
            // is non-remote driven we force a recalculation
            // of the focuspath
            this._refocus();
          }

          _getFocused() {
            // we delegate focus to selected widget
            // so it can consume remotecontrol presses
            return this._widget
          }

          // if we want to widget to widget focus delegation
          reload(widget) {
            this._widget = widget;
            this._refocus();
          }

          _handleKey() {
            const restoreFocus = routerConfig.get('autoRestoreRemote');
            /**
             * The Router used to delegate focus back to the page instance on
             * every unhandled key. This is barely usefull in any situation
             * so for now we offer the option to explicity turn that behaviour off
             * so we don't don't introduce a breaking change.
             */
            if (!isBoolean(restoreFocus) || restoreFocus === true) {
              Router.focusPage();
            }
          }
        },
      ]
    }

    /**
     * Return location where pages need to be stored
     */
    get pages() {
      return this.tag('Pages')
    }

    /**
     * Tell router where widgets are stored
     */
    get widgets() {
      return this.tag('Widgets')
    }

    /**
     * we MUST register _handleBack method so the Router
     * can override it
     * @private
     */
    _handleBack() {}

    /**
     * We MUST return Router.activePage() so the new Page
     * can listen to the remote-control.
     */
    _getFocused() {
      return Router.getActivePage()
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /*
  rouThor ==[x]
   */
  let navigateQueue = new Map();
  let forcedHash = '';
  let resumeHash = '';

  /**
   * Start routing the app
   * @param config - route config object
   * @param instance - instance of the app
   */
  const startRouter = (config, instance) => {
    bootRouter(config, instance);
    start();
  };

  // start translating url
  const start = () => {
    const bootKey = '@router-boot-page';
    const hash = (getHash() || '').replace(/^#/, '');
    const params = getQueryStringParams(hash);
    const bootRequest = getBootRequest();
            console.log('startR', hash, params)
    // if we refreshed the boot-page we don't want to
    // redirect to this page so we force rootHash load
    const isDirectLoad = hash.indexOf(bootKey) !== -1;
    const ready = () => {
      const rootHash = getRootHash();

      if (routeExists(bootKey)) {
        resumeHash = isDirectLoad ? rootHash : hash || rootHash;
        navigate(bootKey);
      } else if (!hash && rootHash) {
        if (isString(rootHash)) {
          navigate(rootHash);
        } else if (isFunction(rootHash)) {
          rootHash().then(res => {
            if (isObject(res)) {
              navigate(res.path, res.params);
            } else {
              navigate(res);
            }
          });
        }
      } else {
        queue(hash);
        handleHashChange().then(() => {
          app._refocus();
        });
      }
    };
    if (isFunction(bootRequest)) {
      bootRequest(params)
        .then(() => {
          ready();
        })
        .catch(e => {
          if (routeExists('!')) {
            navigate('!', { request: { error: e } });
          } else {
            console.error(e);
          }
        });
    } else {
      ready();
    }
  };

  /**
   * start a new request
   * @param url
   * @param args
   * @param store
   */
  const navigate = (url, args = {}, store = true) => {
            console.log('navigate', url)
    if (isObject(url)) {
      url = getHashByName(url);
      if (!url) {
        return
      }
    }
            console.log('navigate2', url)
    let hash = getHash();
    if (!mustUpdateLocationHash() && forcedHash) {
      hash = forcedHash;
    }
    if (hash.replace(/^#/, '') !== url) {
      // push request in the queue
      queue(url, args, store);
        console.log('navigate3', url)
      setHash(url);
      if (!mustUpdateLocationHash()) {
        forcedHash = url;
          console.log('navigate4', url)
        handleHashChange(url)
          .then(() => {
            app._refocus();
              console.log('navigate5', url)
          })
          .catch(e => {
            console.error(e);
          });
      }
    } else if (args.reload) {
      // push request in the queue
      queue(url, args, store);
        console.log('navigate4', url)
      handleHashChange(url)
        .then(() => {
          app._refocus();
        })
        .catch(e => {
          console.error(e);
        });
    }
  };

  const queue = (hash, args = {}, store = true) => {
    hash = hash.replace(/^#/, '');
    if (!navigateQueue.has(hash)) {
      for (let request of navigateQueue.values()) {
        request.cancel();
      }
      const request = createRequest(hash, args, store);
      navigateQueue.set(decodeURIComponent(hash), request);

      return request
    }
    return false
  };

  /**
   * Handle change of hash
   * @param override
   * @returns {Promise<void>}
   */
  const handleHashChange = async override => {
    const hash = (override || getHash()).replace(/^#/, '');
    const queueId = decodeURIComponent(hash);
    let request = navigateQueue.get(queueId);
            console.log('handleHashChange', hash)
    // handle hash updated manually
    if (!request && !navigateQueue.size) {
      request = queue(hash);
    }

    const route = getRouteByHash(hash);
            console.log('handleHashChange2', route)
    if (!route) {
      if (routeExists('*')) {
        navigate('*', { failedHash: hash });
      } else {
        console.error(`Unable to navigate to: ${hash}`);
      }
      return
    }

    // update current processed request
    request.hash = hash;
    request.route = route;

    let result = await beforeEachRoute(getActiveHash(), request);

    // test if a local hook is configured for the route
    if (route.beforeNavigate) {
      result = await route.beforeNavigate(getActiveHash(), request);
    }

    if (isBoolean(result)) {
      // only if resolve value is explicitly true
      // we continue the current route request
      if (result) {
        return resolveHashChange(request)
      }
    } else {
      // if navigation guard didn't return true
      // we cancel the current request
      request.cancel();
      navigateQueue.delete(queueId);

      if (isString(result)) {
        navigate(result);
      } else if (isObject(result)) {
        let store = true;
        if (isBoolean(result.store)) {
          store = result.store;
        }
        navigate(result.path, result.params, store);
      }
    }
  };

  /**
   * Continue processing the hash change if not blocked
   * by global or local hook
   * @param request - {}
   */
  const resolveHashChange = request => {
    const hash = request.hash;
    const route = request.route;
    const queueId = decodeURIComponent(hash);
    // store last requested hash so we can
    // prevent a route that resolved later
    // from displaying itself
    setLastHash(hash);

    if (route.path) {
      const component = getComponent(route.path);
      // if a hook is provided for the current route
      if (isFunction(route.hook)) {
        const urlParams = getValuesFromHash(hash, route.path);
        const params = {};
        for (const key of urlParams.keys()) {
          params[key] = urlParams.get(key);
        }
        route.hook(app, { ...params });
      }
      // if there is a component attached to the route
      if (component) {
        if (isPage(component)) {
          load(request).then(() => {
            app._refocus();
            navigateQueue.delete(queueId);
          });
        } else {
          // of the component is not a constructor
          // or a Component instance we can assume
          // that it's a dynamic import
          component()
            .then(contents => {
              return contents.default
            })
            .then(module => {
              storeComponent(route.path, module);
              return load(request)
            })
            .then(() => {
              app._refocus();
              navigateQueue.delete(queueId);
            });
        }
      } else {
        navigateQueue.delete(queueId);
      }
    }
  };

  /**
   * Directional step in history
   * @param direction
   */
  const step = (level = 0) => {
    if (!level || isNaN(level)) {
      return false
    }
    const history = getHistory();
    // for now we only support negative numbers
    level = Math.abs(level);

    // we can't step back past the amount
    // of history entries
    if (level > history.length) {
      if (isFunction(app._handleAppClose)) {
        return app._handleAppClose()
      }
      return false
    } else if (history.length) {
      // for now we only support history back
      const route = history.splice(history.length - level, level)[0];
      // store changed history
      setHistory(history);
      return navigate(
        route.hash,
        {
          [symbols.backtrack]: true,
          [symbols.historyState]: route.state,
        },
        false
      )
    } else if (routerConfig.get('backtrack')) {
      const hashLastPart = /(\/:?[\w%\s-]+)$/;
      let hash = stripRegex(getHash());
      let floor = getFloor(hash);

      // test if we got deep-linked
      if (floor > 1) {
        while (floor--) {
          // strip of last part
          hash = hash.replace(hashLastPart, '');
          // if we have a configured route
          // we navigate to it
          if (getRouteByHash(hash)) {
            return navigate(hash, { [symbols.backtrack]: true }, false)
          }
        }
      }
    }
    return false
  };

  /**
   * Resume Router's page loading process after
   * the BootComponent became visible;
   */
  const resume = () => {
    if (isString(resumeHash)) {
      navigate(resumeHash, false);
    } else if (isFunction(resumeHash)) {
      resumeHash().then(url => {
        navigate(url, false);
      });
    } else {
      console.warn('[Router]: resume() called but no hash found');
    }
  };

  /**
   * Query if the Router is still processing a Request
   * @returns {boolean}
   */
  const isNavigating = () => {
    if (navigateQueue.size) {
      let isProcessing = false;
      for (let request of navigateQueue.values()) {
        if (!request.isCancelled) {
          isProcessing = true;
        }
      }
      return isProcessing
    }
    return false
  };

  /**
   * By default we return the location hash
   * @returns {string}
   */
  let getHash = () => {
    return document.location.hash
  };

  /**
   * Update location hash
   * @param url
   */
  let setHash = url => {
    document.location.hash = url;
  };

  /**
   * This can be called from the platform / bootstrapper to override
   * the default getting and setting of the hash
   * @param config
   */
  const initRouter = config => {
    if (config.getHash) {
      getHash = config.getHash;
    }
    if (config.setHash) {
      setHash = config.setHash;
    }
  };

  /**
   * On hash change we start processing
   */
  window.addEventListener('hashchange', async () => {
            console.log('hashcanged')
    if (mustUpdateLocationHash()) {
      await handleHashChange();
    }
  });

  // export API
  var Router = {
    startRouter,
    navigate,
    resume,
    step,
    go: step,
    back: step.bind(null, -1),
    activePage: getActivePage,
    getActivePage() {
      // warning
      return getActivePage()
    },
    getActiveRoute,
    getActiveHash,
    focusWidget,
    getActiveWidget,
    restoreFocus,
    isNavigating,
    getHistory,
    setHistory,
    getHistoryState,
    replaceHistoryState,
    symbols,
    App: RoutedApp,
    // keep backwards compatible
    focusPage: restoreFocus,
    /**
     * Deprecated api methods
     */
    setupRoutes() {
      console.warn('Router: setupRoutes is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    on() {
      console.warn('Router.on() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    before() {
      console.warn('Router.before() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    after() {
      console.warn('Router.after() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const defaultChannels = [
    {
      number: 1,
      name: 'Metro News 1',
      description: 'New York Cable News Channel',
      entitled: true,
      program: {
        title: 'The Morning Show',
        description: "New York's best morning show",
        startTime: new Date(new Date() - 60 * 5 * 1000).toUTCString(), // started 5 minutes ago
        duration: 60 * 30, // 30 minutes
        ageRating: 0,
      },
    },
    {
      number: 2,
      name: 'MTV',
      description: 'Music Television',
      entitled: true,
      program: {
        title: 'Beavis and Butthead',
        description: 'American adult animated sitcom created by Mike Judge',
        startTime: new Date(new Date() - 60 * 20 * 1000).toUTCString(), // started 20 minutes ago
        duration: 60 * 45, // 45 minutes
        ageRating: 18,
      },
    },
    {
      number: 3,
      name: 'NBC',
      description: 'NBC TV Network',
      entitled: false,
      program: {
        title: 'The Tonight Show Starring Jimmy Fallon',
        description: 'Late-night talk show hosted by Jimmy Fallon on NBC',
        startTime: new Date(new Date() - 60 * 10 * 1000).toUTCString(), // started 10 minutes ago
        duration: 60 * 60, // 1 hour
        ageRating: 10,
      },
    },
  ];

  const channels = () => Settings.get('platform', 'tv', defaultChannels);

  const randomChannel = () => channels()[~~(channels.length * Math.random())];

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let currentChannel;
  const callbacks = {};

  const emit$1 = (event, ...args) => {
    callbacks[event] &&
      callbacks[event].forEach(cb => {
        cb.apply(null, args);
      });
  };

  // local mock methods
  let methods = {
    getChannel() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        if (currentChannel) {
          const channel = { ...currentChannel };
          delete channel.program;
          resolve(channel);
        } else {
          reject('No channel found');
        }
      })
    },
    getProgram() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        currentChannel.program ? resolve(currentChannel.program) : reject('No program found');
      })
    },
    setChannel(number) {
      return new Promise((resolve, reject) => {
        if (number) {
          const newChannel = channels().find(c => c.number === number);
          if (newChannel) {
            currentChannel = newChannel;
            const channel = { ...currentChannel };
            delete channel.program;
            emit$1('channelChange', channel);
            resolve(channel);
          } else {
            reject('Channel not found');
          }
        } else {
          reject('No channel number supplied');
        }
      })
    },
  };

  const initTV = config => {
    methods = {};
    if (config.getChannel && typeof config.getChannel === 'function') {
      methods.getChannel = config.getChannel;
    }
    if (config.getProgram && typeof config.getProgram === 'function') {
      methods.getProgram = config.getProgram;
    }
    if (config.setChannel && typeof config.setChannel === 'function') {
      methods.setChannel = config.setChannel;
    }
    if (config.emit && typeof config.emit === 'function') {
      config.emit(emit$1);
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const initPurchase = config => {
    if (config.billingUrl) config.billingUrl;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let ApplicationInstance;

  var Launch = (App, appSettings, platformSettings, appData) => {
    initSettings(appSettings, platformSettings);

    initUtils(platformSettings);
    initStorage();
    // Initialize plugins
    if (platformSettings.plugins) {
      platformSettings.plugins.profile && initProfile(platformSettings.plugins.profile);
      platformSettings.plugins.metrics && initMetrics(platformSettings.plugins.metrics);
      platformSettings.plugins.mediaPlayer && initMediaPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.mediaPlayer && initVideoPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.ads && initAds(platformSettings.plugins.ads);
      platformSettings.plugins.router && initRouter(platformSettings.plugins.router);
      platformSettings.plugins.tv && initTV(platformSettings.plugins.tv);
      platformSettings.plugins.purchase && initPurchase(platformSettings.plugins.purchase);
    }

    const app = Application(App, appData, platformSettings);
    ApplicationInstance = new app(appSettings);
    return ApplicationInstance
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  class VideoTexture extends lightning.Component {
    static _template() {
      return {
        Video: {
          alpha: 1,
          visible: false,
          pivot: 0.5,
          texture: { type: lightning.textures.StaticTexture, options: {} },
        },
      }
    }

    set videoEl(v) {
      this._videoEl = v;
    }

    get videoEl() {
      return this._videoEl
    }

    get videoView() {
      return this.tag('Video')
    }

    get videoTexture() {
      return this.videoView.texture
    }

    get isVisible() {
      return this.videoView.alpha === 1 && this.videoView.visible === true
    }

    _init() {
      this._createVideoTexture();
    }

    _createVideoTexture() {
      const stage = this.stage;

      const gl = stage.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height };

      this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision();
      this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision();
    }

    start() {
      const stage = this.stage;
      if (!this._updateVideoTexture) {
        this._updateVideoTexture = () => {
          if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
            const gl = stage.gl;

            const currentTime = new Date().getTime();

            // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
            // We'll fallback to fixed 30fps in this case.
            const frameCount = this.videoEl.webkitDecodedFrameCount;

            const mustUpdate = frameCount
              ? this._lastFrame !== frameCount
              : this._lastTime < currentTime - 30;

            if (mustUpdate) {
              this._lastTime = currentTime;
              this._lastFrame = frameCount;
              try {
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                this.videoView.visible = true;

                this.videoTexture.options.w = this.videoEl.width;
                this.videoTexture.options.h = this.videoEl.height;
                const expectedAspectRatio = this.videoView.w / this.videoView.h;
                const realAspectRatio = this.videoEl.width / this.videoEl.height;

                if (expectedAspectRatio > realAspectRatio) {
                  this.videoView.scaleX = realAspectRatio / expectedAspectRatio;
                  this.videoView.scaleY = 1;
                } else {
                  this.videoView.scaleY = expectedAspectRatio / realAspectRatio;
                  this.videoView.scaleX = 1;
                }
              } catch (e) {
                Log.error('texImage2d video', e);
                this.stop();
              }
              this.videoTexture.source.forceRenderUpdate();
            }
          }
        };
      }
      if (!this._updatingVideoTexture) {
        stage.on('frameStart', this._updateVideoTexture);
        this._updatingVideoTexture = true;
      }
    }

    stop() {
      const stage = this.stage;
      stage.removeListener('frameStart', this._updateVideoTexture);
      this._updatingVideoTexture = false;
      this.videoView.visible = false;

      if (this.videoTexture.options.source) {
        const gl = stage.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
    }

    position(top, left) {
      this.videoView.patch({
        smooth: {
          x: left,
          y: top,
        },
      });
    }

    size(width, height) {
      this.videoView.patch({
        smooth: {
          w: width,
          h: height,
        },
      });
    }

    show() {
      this.videoView.setSmooth('alpha', 1);
    }

    hide() {
      this.videoView.setSmooth('alpha', 0);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let mediaUrl$1 = url => url;
  let videoEl;
  let videoTexture;
  let metrics$1;
  let consumer;
  let precision = 1;
  let textureMode = false;

  const initVideoPlayer = config => {
    if (config.mediaUrl) {
      mediaUrl$1 = config.mediaUrl;
    }
  };

  // todo: add this in a 'Registry' plugin
  // to be able to always clean this up on app close
  let eventHandlers = {};

  const state = {
    adsEnabled: false,
    playing: false,
    _playingAds: false,
    get playingAds() {
      return this._playingAds
    },
    set playingAds(val) {
      if (this._playingAds !== val) {
        this._playingAds = val;
        fireOnConsumer(val === true ? 'AdStart' : 'AdEnd');
      }
    },
    skipTime: false,
    playAfterSeek: null,
  };

  const hooks = {
    play() {
      state.playing = true;
    },
    pause() {
      state.playing = false;
    },
    seeked() {
      state.playAfterSeek === true && videoPlayerPlugin.play();
      state.playAfterSeek = null;
    },
    abort() {
      deregisterEventListeners();
    },
  };

  const withPrecision = val => Math.round(precision * val) + 'px';

  const fireOnConsumer = (event, args) => {
    if (consumer) {
      consumer.fire('$videoPlayer' + event, args, videoEl.currentTime);
      consumer.fire('$videoPlayerEvent', event, args, videoEl.currentTime);
    }
  };

  const fireHook = (event, args) => {
    hooks[event] && typeof hooks[event] === 'function' && hooks[event].call(null, event, args);
  };

  let customLoader = null;
  let customUnloader = null;

  const loader$1 = (url, videoEl, config) => {
    return customLoader && typeof customLoader === 'function'
      ? customLoader(url, videoEl, config)
      : new Promise(resolve => {
          url = mediaUrl$1(url);
          videoEl.setAttribute('src', url);
          videoEl.load();
          resolve();
        })
  };

  const unloader = videoEl => {
    return customUnloader && typeof customUnloader === 'function'
      ? customUnloader(videoEl)
      : new Promise(resolve => {
          videoEl.removeAttribute('src');
          videoEl.load();
          resolve();
        })
  };

  const setupVideoTag = () => {
    const videoEls = document.getElementsByTagName('video');
    if (videoEls && videoEls.length) {
      return videoEls[0]
    } else {
      const videoEl = document.createElement('video');
      videoEl.setAttribute('id', 'video-player');
      videoEl.setAttribute('width', withPrecision(1920));
      videoEl.setAttribute('height', withPrecision(1080));
      videoEl.setAttribute('crossorigin', 'anonymous');
      videoEl.style.position = 'absolute';
      videoEl.style.zIndex = '1';
      videoEl.style.display = 'none';
      videoEl.style.visibility = 'hidden';
      videoEl.style.top = withPrecision(0);
      videoEl.style.left = withPrecision(0);
      videoEl.style.width = withPrecision(1920);
      videoEl.style.height = withPrecision(1080);
      document.body.appendChild(videoEl);
      return videoEl
    }
  };

  const setUpVideoTexture = () => {
    if (!ApplicationInstance.tag('VideoTexture')) {
      const el = ApplicationInstance.stage.c({
        type: VideoTexture,
        ref: 'VideoTexture',
        zIndex: 0,
        videoEl,
      });
      ApplicationInstance.childList.addAt(el, 0);
    }
    return ApplicationInstance.tag('VideoTexture')
  };

  const registerEventListeners = () => {
    Log.info('VideoPlayer', 'Registering event listeners');
    Object.keys(events).forEach(event => {
      const handler = e => {
        // Fire a metric for each event (if it exists on the metrics object)
        if (metrics$1 && metrics$1[event] && typeof metrics$1[event] === 'function') {
          metrics$1[event]({ currentTime: videoEl.currentTime });
        }
        // fire an internal hook
        fireHook(event, { videoElement: videoEl, event: e });

        // fire the event (with human friendly event name) to the consumer of the VideoPlayer
        fireOnConsumer(events[event], { videoElement: videoEl, event: e });
      };

      eventHandlers[event] = handler;
      videoEl.addEventListener(event, handler);
    });
  };

  const deregisterEventListeners = () => {
    Log.info('VideoPlayer', 'Deregistering event listeners');
    Object.keys(eventHandlers).forEach(event => {
      videoEl.removeEventListener(event, eventHandlers[event]);
    });
    eventHandlers = {};
  };

  const videoPlayerPlugin = {
    consumer(component) {
      consumer = component;
    },

    loader(loaderFn) {
      customLoader = loaderFn;
    },

    unloader(unloaderFn) {
      customUnloader = unloaderFn;
    },

    position(top = 0, left = 0) {
      videoEl.style.left = withPrecision(left);
      videoEl.style.top = withPrecision(top);
      if (textureMode === true) {
        videoTexture.position(top, left);
      }
    },

    size(width = 1920, height = 1080) {
      videoEl.style.width = withPrecision(width);
      videoEl.style.height = withPrecision(height);
      videoEl.width = parseFloat(videoEl.style.width);
      videoEl.height = parseFloat(videoEl.style.height);
      if (textureMode === true) {
        videoTexture.size(width, height);
      }
    },

    area(top = 0, right = 1920, bottom = 1080, left = 0) {
      this.position(top, left);
      this.size(right - left, bottom - top);
    },

    open(url, config = {}) {
      if (!this.canInteract) return
      metrics$1 = Metrics$1.media(url);

      this.hide();
      deregisterEventListeners();

      if (this.src == url) {
        this.clear().then(this.open(url, config));
      } else {
        const adConfig = { enabled: state.adsEnabled, duration: 300 };
        if (config.videoId) {
          adConfig.caid = config.videoId;
        }
        Ads.get(adConfig, consumer).then(ads => {
          state.playingAds = true;
          ads.prerolls().then(() => {
            state.playingAds = false;
            loader$1(url, videoEl, config).then(() => {
              registerEventListeners();
              this.show();
              this.play();
            });
          });
        });
      }
    },

    reload() {
      if (!this.canInteract) return
      const url = videoEl.getAttribute('src');
      this.close();
      this.open(url);
    },

    close() {
      Ads.cancel();
      if (state.playingAds) {
        state.playingAds = false;
        Ads.stop();
        // call self in next tick
        setTimeout(() => {
          this.close();
        });
      }
      if (!this.canInteract) return
      this.clear();
      this.hide();
      deregisterEventListeners();
    },

    clear() {
      if (!this.canInteract) return
      // pause the video first to disable sound
      this.pause();
      if (textureMode === true) videoTexture.stop();
      return unloader(videoEl).then(() => {
        fireOnConsumer('Clear', { videoElement: videoEl });
      })
    },

    play() {
      if (!this.canInteract) return
      if (textureMode === true) videoTexture.start();
      videoEl.play();
    },

    pause() {
      if (!this.canInteract) return
      videoEl.pause();
    },

    playPause() {
      if (!this.canInteract) return
      this.playing === true ? this.pause() : this.play();
    },

    mute(muted = true) {
      if (!this.canInteract) return
      videoEl.muted = muted;
    },

    loop(looped = true) {
      videoEl.loop = looped;
    },

    seek(time) {
      if (!this.canInteract) return
      if (!this.src) return
      // define whether should continue to play after seek is complete (in seeked hook)
      if (state.playAfterSeek === null) {
        state.playAfterSeek = !!state.playing;
      }
      // pause before actually seeking
      this.pause();
      // currentTime always between 0 and the duration of the video (minus 0.1s to not set to the final frame and stall the video)
      videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1));
    },

    skip(seconds) {
      if (!this.canInteract) return
      if (!this.src) return

      state.skipTime = (state.skipTime || videoEl.currentTime) + seconds;
      easeExecution(() => {
        this.seek(state.skipTime);
        state.skipTime = false;
      }, 300);
    },

    show() {
      if (!this.canInteract) return
      if (textureMode === true) {
        videoTexture.show();
      } else {
        videoEl.style.display = 'block';
        videoEl.style.visibility = 'visible';
      }
    },

    hide() {
      if (!this.canInteract) return
      if (textureMode === true) {
        videoTexture.hide();
      } else {
        videoEl.style.display = 'none';
        videoEl.style.visibility = 'hidden';
      }
    },

    enableAds(enabled = true) {
      state.adsEnabled = enabled;
    },

    /* Public getters */
    get duration() {
      return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration)
    },

    get currentTime() {
      return videoEl && videoEl.currentTime
    },

    get muted() {
      return videoEl && videoEl.muted
    },

    get looped() {
      return videoEl && videoEl.loop
    },

    get src() {
      return videoEl && videoEl.getAttribute('src')
    },

    get playing() {
      return state.playing
    },

    get playingAds() {
      return state.playingAds
    },

    get canInteract() {
      // todo: perhaps add an extra flag wether we allow interactions (i.e. pauze, mute, etc.) during ad playback
      return state.playingAds === false
    },

    get top() {
      return videoEl && parseFloat(videoEl.style.top)
    },

    get left() {
      return videoEl && parseFloat(videoEl.style.left)
    },

    get bottom() {
      return videoEl && parseFloat(videoEl.style.top - videoEl.style.height)
    },

    get right() {
      return videoEl && parseFloat(videoEl.style.left - videoEl.style.width)
    },

    get width() {
      return videoEl && parseFloat(videoEl.style.width)
    },

    get height() {
      return videoEl && parseFloat(videoEl.style.height)
    },

    get visible() {
      if (textureMode === true) {
        return videoTexture.isVisible
      } else {
        return videoEl && videoEl.style.display === 'block'
      }
    },

    get adsEnabled() {
      return state.adsEnabled
    },

    // prefixed with underscore to indicate 'semi-private'
    // because it's not recommended to interact directly with the video element
    get _videoEl() {
      return videoEl
    },
  };

  var VideoPlayer = autoSetupMixin(videoPlayerPlugin, () => {
    precision =
      (ApplicationInstance &&
        ApplicationInstance.stage &&
        ApplicationInstance.stage.getRenderPrecision()) ||
      precision;

    videoEl = setupVideoTag();

    textureMode = Settings.get('platform', 'textureMode', false);
    if (textureMode === true) {
      videoTexture = setUpVideoTexture();
    }
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let consumer$1;

  let getAds = () => {
    // todo: enable some default ads during development, maybe from the settings.json
    return Promise.resolve({
      prerolls: [],
      midrolls: [],
      postrolls: [],
    })
  };

  const initAds = config => {
    if (config.getAds) {
      getAds = config.getAds;
    }
  };

  const state$1 = {
    active: false,
  };

  const playSlot = (slot = []) => {
    return slot.reduce((promise, ad) => {
      return promise.then(() => {
        return playAd(ad)
      })
    }, Promise.resolve(null))
  };

  const playAd = ad => {
    return new Promise(resolve => {
      if (state$1.active === false) {
        Log.info('Ad', 'Skipping add due to inactive state');
        return resolve()
      }
      // is it safe to rely on videoplayer plugin already created the video tag?
      const videoEl = document.getElementsByTagName('video')[0];
      videoEl.style.display = 'block';
      videoEl.style.visibility = 'visible';
      videoEl.src = mediaUrl$1(ad.url);
      videoEl.load();

      let timeEvents = null;
      let timeout;

      const cleanup = () => {
        // remove all listeners
        Object.keys(handlers).forEach(handler =>
          videoEl.removeEventListener(handler, handlers[handler])
        );
        resolve();
      };
      const handlers = {
        play() {
          Log.info('Ad', 'Play ad', ad.url);
          fireOnConsumer$1('Play', ad);
          sendBeacon(ad.callbacks, 'defaultImpression');
        },
        ended() {
          fireOnConsumer$1('Ended', ad);
          sendBeacon(ad.callbacks, 'complete');
          cleanup();
        },
        timeupdate() {
          if (!timeEvents && videoEl.duration) {
            // calculate when to fire the time based events (now that duration is known)
            timeEvents = {
              firstQuartile: videoEl.duration / 4,
              midPoint: videoEl.duration / 2,
              thirdQuartile: (videoEl.duration / 4) * 3,
            };
            Log.info('Ad', 'Calculated quartiles times', { timeEvents });
          }
          if (
            timeEvents &&
            timeEvents.firstQuartile &&
            videoEl.currentTime >= timeEvents.firstQuartile
          ) {
            fireOnConsumer$1('FirstQuartile', ad);
            delete timeEvents.firstQuartile;
            sendBeacon(ad.callbacks, 'firstQuartile');
          }
          if (timeEvents && timeEvents.midPoint && videoEl.currentTime >= timeEvents.midPoint) {
            fireOnConsumer$1('MidPoint', ad);
            delete timeEvents.midPoint;
            sendBeacon(ad.callbacks, 'midPoint');
          }
          if (
            timeEvents &&
            timeEvents.thirdQuartile &&
            videoEl.currentTime >= timeEvents.thirdQuartile
          ) {
            fireOnConsumer$1('ThirdQuartile', ad);
            delete timeEvents.thirdQuartile;
            sendBeacon(ad.callbacks, 'thirdQuartile');
          }
        },
        stalled() {
          fireOnConsumer$1('Stalled', ad);
          timeout = setTimeout(() => {
            cleanup();
          }, 5000); // make timeout configurable
        },
        canplay() {
          timeout && clearTimeout(timeout);
        },
        error() {
          fireOnConsumer$1('Error', ad);
          cleanup();
        },
        // this doesn't work reliably on sky box, moved logic to timeUpdate event
        // loadedmetadata() {
        //   // calculate when to fire the time based events (now that duration is known)
        //   timeEvents = {
        //     firstQuartile: videoEl.duration / 4,
        //     midPoint: videoEl.duration / 2,
        //     thirdQuartile: (videoEl.duration / 4) * 3,
        //   }
        // },
        abort() {
          cleanup();
        },
        // todo: pause, resume, mute, unmute beacons
      };
      // add all listeners
      Object.keys(handlers).forEach(handler => videoEl.addEventListener(handler, handlers[handler]));

      videoEl.play();
    })
  };

  const sendBeacon = (callbacks, event) => {
    if (callbacks && callbacks[event]) {
      Log.info('Ad', 'Sending beacon', event, callbacks[event]);
      return callbacks[event].reduce((promise, url) => {
        return promise.then(() =>
          fetch(url)
            // always resolve, also in case of a fetch error (so we don't block firing the rest of the beacons for this event)
            // note: for fetch failed http responses don't throw an Error :)
            .then(response => {
              if (response.status === 200) {
                fireOnConsumer$1('Beacon' + event + 'Sent');
              } else {
                fireOnConsumer$1('Beacon' + event + 'Failed' + response.status);
              }
            })
            .catch(() => {
            })
        )
      }, Promise.resolve(null))
    } else {
      Log.info('Ad', 'No callback found for ' + event);
    }
  };

  const fireOnConsumer$1 = (event, args) => {
    if (consumer$1) {
      consumer$1.fire('$ad' + event, args);
      consumer$1.fire('$adEvent', event, args);
    }
  };

  var Ads = {
    get(config, videoPlayerConsumer) {
      if (config.enabled === false) {
        return Promise.resolve({
          prerolls() {
            return Promise.resolve()
          },
        })
      }
      consumer$1 = videoPlayerConsumer;

      return new Promise(resolve => {
        Log.info('Ad', 'Starting session');
        getAds(config).then(ads => {
          Log.info('Ad', 'API result', ads);
          resolve({
            prerolls() {
              if (ads.preroll) {
                state$1.active = true;
                fireOnConsumer$1('PrerollSlotImpression', ads);
                sendBeacon(ads.preroll.callbacks, 'slotImpression');
                return playSlot(ads.preroll.ads).then(() => {
                  fireOnConsumer$1('PrerollSlotEnd', ads);
                  sendBeacon(ads.preroll.callbacks, 'slotEnd');
                  state$1.active = false;
                })
              }
              return Promise.resolve()
            },
            midrolls() {
              return Promise.resolve()
            },
            postrolls() {
              return Promise.resolve()
            },
          });
        });
      })
    },
    cancel() {
      Log.info('Ad', 'Cancel Ad');
      state$1.active = false;
    },
    stop() {
      Log.info('Ad', 'Stop Ad');
      state$1.active = false;
      // fixme: duplication
      const videoEl = document.getElementsByTagName('video')[0];
      videoEl.pause();
      videoEl.removeAttribute('src');
    },
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  class ScaledImageTexture extends lightning.textures.ImageTexture {
    constructor(stage) {
      super(stage);
      this._scalingOptions = undefined;
    }

    set options(options) {
      this.resizeMode = this._scalingOptions = options;
    }

    _getLookupId() {
      return `${this._src}-${this._scalingOptions.type}-${this._scalingOptions.w}-${this._scalingOptions.h}`
    }

    getNonDefaults() {
      const obj = super.getNonDefaults();
      if (this._src) {
        obj.src = this._src;
      }
      return obj
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  class PinInput extends lightning.Component {
    static _template() {
      return {
        w: 120,
        h: 150,
        rect: true,
        color: 0xff949393,
        alpha: 0.5,
        shader: { type: lightning.shaders.RoundedRectangle, radius: 10 },
        Nr: {
          w: w => w,
          y: 24,
          text: {
            text: '',
            textColor: 0xff333333,
            fontSize: 80,
            textAlign: 'center',
            verticalAlign: 'middle',
          },
        },
      }
    }

    set index(v) {
      this.x = v * (120 + 24);
    }

    set nr(v) {
      this._timeout && clearTimeout(this._timeout);

      if (v) {
        this.setSmooth('alpha', 1);
      } else {
        this.setSmooth('alpha', 0.5);
      }

      this.tag('Nr').patch({
        text: {
          text: (v && v.toString()) || '',
          fontSize: v === '*' ? 120 : 80,
        },
      });

      if (v && v !== '*') {
        this._timeout = setTimeout(() => {
          this._timeout = null;
          this.nr = '*';
        }, 750);
      }
    }
  }

  class PinDialog extends lightning.Component {
    static _template() {
      return {
        zIndex: 1,
        w: w => w,
        h: h => h,
        rect: true,
        color: 0xdd000000,
        alpha: 0.000001,
        Dialog: {
          w: 648,
          h: 320,
          y: h => (h - 320) / 2,
          x: w => (w - 648) / 2,
          rect: true,
          color: 0xdd333333,
          shader: { type: lightning.shaders.RoundedRectangle, radius: 10 },
          Info: {
            y: 24,
            x: 48,
            text: { text: 'Please enter your PIN', fontSize: 32 },
          },
          Msg: {
            y: 260,
            x: 48,
            text: { text: '', fontSize: 28, textColor: 0xffffffff },
          },
          Code: {
            x: 48,
            y: 96,
          },
        },
      }
    }

    _init() {
      const children = [];
      for (let i = 0; i < 4; i++) {
        children.push({
          type: PinInput,
          index: i,
        });
      }

      this.tag('Code').children = children;
    }

    get pin() {
      if (!this._pin) this._pin = '';
      return this._pin
    }

    set pin(v) {
      if (v.length <= 4) {
        const maskedPin = new Array(Math.max(v.length - 1, 0)).fill('*', 0, v.length - 1);
        v.length && maskedPin.push(v.length > this._pin.length ? v.slice(-1) : '*');
        for (let i = 0; i < 4; i++) {
          this.tag('Code').children[i].nr = maskedPin[i] || '';
        }
        this._pin = v;
      }
    }

    get msg() {
      if (!this._msg) this._msg = '';
      return this._msg
    }

    set msg(v) {
      this._timeout && clearTimeout(this._timeout);

      this._msg = v;
      if (this._msg) {
        this.tag('Msg').text = this._msg;
        this.tag('Info').setSmooth('alpha', 0.5);
        this.tag('Code').setSmooth('alpha', 0.5);
      } else {
        this.tag('Msg').text = '';
        this.tag('Info').setSmooth('alpha', 1);
        this.tag('Code').setSmooth('alpha', 1);
      }
      this._timeout = setTimeout(() => {
        this.msg = '';
      }, 2000);
    }

    _firstActive() {
      this.setSmooth('alpha', 1);
    }

    _handleKey(event) {
      if (this.msg) {
        this.msg = false;
      } else {
        const val = parseInt(event.key);
        if (val > -1) {
          this.pin += val;
        }
      }
    }

    _handleBack() {
      if (this.msg) {
        this.msg = false;
      } else {
        if (this.pin.length) {
          this.pin = this.pin.slice(0, this.pin.length - 1);
        } else {
          Pin.hide();
          this.resolve(false);
        }
      }
    }

    _handleEnter() {
      if (this.msg) {
        this.msg = false;
      } else {
        Pin.submit(this.pin)
          .then(val => {
            this.msg = 'Unlocking ...';
            setTimeout(() => {
              Pin.hide();
            }, 1000);
            this.resolve(val);
          })
          .catch(e => {
            this.msg = e;
            this.reject(e);
          });
      }
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // only used during local development
  let unlocked = false;

  let submit = pin => {
    return new Promise((resolve, reject) => {
      if (pin.toString() === Settings.get('platform', 'pin', '0000').toString()) {
        unlocked = true;
        resolve(unlocked);
      } else {
        reject('Incorrect pin');
      }
    })
  };

  let check = () => {
    return new Promise(resolve => {
      resolve(unlocked);
    })
  };

  let pinDialog = null;

  // Public API
  var Pin = {
    show() {
      return new Promise((resolve, reject) => {
        pinDialog = ApplicationInstance.stage.c({
          ref: 'PinDialog',
          type: PinDialog,
          resolve,
          reject,
        });
        ApplicationInstance.childList.a(pinDialog);
        ApplicationInstance.focus = pinDialog;
      })
    },
    hide() {
      ApplicationInstance.focus = null;
      ApplicationInstance.children = ApplicationInstance.children.map(
        child => child !== pinDialog && child
      );
      pinDialog = null;
    },
    submit(pin) {
      return new Promise((resolve, reject) => {
        try {
          submit(pin)
            .then(resolve)
            .catch(reject);
        } catch (e) {
          reject(e);
        }
      })
    },
    unlocked() {
      return new Promise((resolve, reject) => {
        try {
          check()
            .then(resolve)
            .catch(reject);
        } catch (e) {
          reject(e);
        }
      })
    },
    locked() {
      return new Promise((resolve, reject) => {
        try {
          check()
            .then(unlocked => resolve(!!!unlocked))
            .catch(reject);
        } catch (e) {
          reject(e);
        }
      })
    },
  };

  class FetchError extends Error {
      constructor(message, code = -1, url = '') {
          super();
          this.name = 'FetchError';
          this.message = message;
          this.code = code;
          this.url = url;
      }
  }
  class ConfigNotReadyError extends Error {
      constructor() {
          super();
          this.name = 'ConfigNotReadyError';
          this.message = 'Attempted property access before config is loaded';
      }
  }
  class CellDataError extends Error {
      constructor() {
          super();
          this.name = 'CellDataError';
          this.message = 'Attempted to read uninitialized data property on cell';
      }
  }
  class RowDataError extends Error {
      constructor() {
          super();
          this.name = 'RowDataError';
          this.message = 'Attempted to read uninitialized data property on row';
      }
  }
  class PageDataError extends Error {
      constructor() {
          super();
          this.name = 'PageDataError';
          this.message = 'Attempted to read uninitialized data property on page';
      }
  }
  class TabMenuItemError extends Error {
      constructor() {
          super();
          this.name = 'TabMenuItemError';
          this.message = 'Attempted to call uninitialized onSelected method';
      }
  }
  class StoreDataError extends Error {
      constructor() {
          super();
          this.name = 'StoreDataError';
          this.message = 'Attempted to read uninitialized property on Store';
      }
  }
  class BadgerAccessError extends Error {
      constructor() {
          super();
          this.name = 'BadgerAccessError';
          this.message = 'Attempted to call unauthorised moneybadger api';
      }
  }

  var mparticle_common = createCommonjsModule(function (module) {
  // Base64 encoder/decoder - http://www.webtoolkit.info/javascript_base64.html
  var Base64={_keyStr:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",// Input must be a string
  encode:function(a){try{if(window.btoa&&window.atob)return window.btoa(unescape(encodeURIComponent(a)))}catch(a){console.error("Error encoding cookie values into Base64:"+a);}return this._encode(a)},_encode:function(a){var b,c,d,e,f,g,h,j="",k=0;for(a=UTF8.encode(a);k<a.length;)b=a.charCodeAt(k++),c=a.charCodeAt(k++),d=a.charCodeAt(k++),e=b>>2,f=(3&b)<<4|c>>4,g=(15&c)<<2|d>>6,h=63&d,isNaN(c)?g=h=64:isNaN(d)&&(h=64),j=j+Base64._keyStr.charAt(e)+Base64._keyStr.charAt(f)+Base64._keyStr.charAt(g)+Base64._keyStr.charAt(h);return j},decode:function(a){try{if(window.btoa&&window.atob)return decodeURIComponent(escape(window.atob(a)))}catch(a){//log(e);
  }return Base64._decode(a)},_decode:function(a){var b,c,d,e,f,g,h,j="",k=0;for(a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");k<a.length;)e=Base64._keyStr.indexOf(a.charAt(k++)),f=Base64._keyStr.indexOf(a.charAt(k++)),g=Base64._keyStr.indexOf(a.charAt(k++)),h=Base64._keyStr.indexOf(a.charAt(k++)),b=e<<2|f>>4,c=(15&f)<<4|g>>2,d=(3&g)<<6|h,j+=String.fromCharCode(b),64!==g&&(j+=String.fromCharCode(c)),64!==h&&(j+=String.fromCharCode(d));return j=UTF8.decode(j),j}},UTF8={encode:function(a){for(var b,d="",e=0;e<a.length;e++)b=a.charCodeAt(e),128>b?d+=String.fromCharCode(b):127<b&&2048>b?(d+=String.fromCharCode(192|b>>6),d+=String.fromCharCode(128|63&b)):(d+=String.fromCharCode(224|b>>12),d+=String.fromCharCode(128|63&b>>6),d+=String.fromCharCode(128|63&b));return d},decode:function(a){for(var b="",d=0,e=0,f=0,g=0;d<a.length;)e=a.charCodeAt(d),128>e?(b+=String.fromCharCode(e),d++):191<e&&224>e?(f=a.charCodeAt(d+1),b+=String.fromCharCode((31&e)<<6|63&f),d+=2):(f=a.charCodeAt(d+1),g=a.charCodeAt(d+2),b+=String.fromCharCode((15&e)<<12|(63&f)<<6|63&g),d+=3);return b}};var Polyfill = {// forEach polyfill
  // Production steps of ECMA-262, Edition 5, 15.4.4.18
  // Reference: http://es5.github.io/#x15.4.4.18
  forEach:function forEach(a,b){var c,d;if(null==this)throw new TypeError(" this is null or not defined");var e=Object(this),f=e.length>>>0;if("function"!=typeof a)throw new TypeError(a+" is not a function");for(1<arguments.length&&(c=b),d=0;d<f;){var g;d in e&&(g=e[d],a.call(c,g,d,e)),d++;}},// map polyfill
  // Production steps of ECMA-262, Edition 5, 15.4.4.19
  // Reference: http://es5.github.io/#x15.4.4.19
  map:function map(a,b){var c,d,e;if(null===this)throw new TypeError(" this is null or not defined");var f=Object(this),g=f.length>>>0;if("function"!=typeof a)throw new TypeError(a+" is not a function");for(1<arguments.length&&(c=b),d=Array(g),e=0;e<g;){var h,i;e in f&&(h=f[e],i=a.call(c,h,e,f),d[e]=i),e++;}return d},// filter polyfill
  // Prodcution steps of ECMA-262, Edition 5
  // Reference: http://es5.github.io/#x15.4.4.20
  filter:function filter(a/*, thisArg*/){if(void 0===this||null===this)throw new TypeError;var b=Object(this),c=b.length>>>0;if("function"!=typeof a)throw new TypeError;for(var d=[],e=2<=arguments.length?arguments[1]:void 0,f=0;f<c;f++)if(f in b){var g=b[f];a.call(e,g,f,b)&&d.push(g);}return d},// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
  isArray:function isArray(a){return "[object Array]"===Object.prototype.toString.call(a)},Base64:Base64};

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var defineProperty = _defineProperty;

  var MessageType={SessionStart:1,SessionEnd:2,PageView:3,PageEvent:4,CrashReport:5,OptOut:6,AppStateTransition:10,Profile:14,Commerce:16,Media:20,UserAttributeChange:17,UserIdentityChange:18},TriggerUploadType=defineProperty({},MessageType.Commerce,1),EventType={Unknown:0,Navigation:1,Location:2,Search:3,Transaction:4,UserContent:5,UserPreference:6,Social:7,Other:8,Media:9,getName:function getName(a){return a===EventType.Unknown?"Unknown":a===EventType.Navigation?"Navigation":a===EventType.Location?"Location":a===EventType.Search?"Search":a===EventType.Transaction?"Transaction":a===EventType.UserContent?"User Content":a===EventType.UserPreference?"User Preference":a===EventType.Social?"Social":a===CommerceEventType.ProductAddToCart?"Product Added to Cart":a===CommerceEventType.ProductAddToWishlist?"Product Added to Wishlist":a===CommerceEventType.ProductCheckout?"Product Checkout":a===CommerceEventType.ProductCheckoutOption?"Product Checkout Options":a===CommerceEventType.ProductClick?"Product Click":a===CommerceEventType.ProductImpression?"Product Impression":a===CommerceEventType.ProductPurchase?"Product Purchased":a===CommerceEventType.ProductRefund?"Product Refunded":a===CommerceEventType.ProductRemoveFromCart?"Product Removed From Cart":a===CommerceEventType.ProductRemoveFromWishlist?"Product Removed from Wishlist":a===CommerceEventType.ProductViewDetail?"Product View Details":a===CommerceEventType.PromotionClick?"Promotion Click":a===CommerceEventType.PromotionView?"Promotion View":"Other"}},CommerceEventType={ProductAddToCart:10,ProductRemoveFromCart:11,ProductCheckout:12,ProductCheckoutOption:13,ProductClick:14,ProductViewDetail:15,ProductPurchase:16,ProductRefund:17,PromotionView:18,PromotionClick:19,ProductAddToWishlist:20,ProductRemoveFromWishlist:21,ProductImpression:22},IdentityType={Other:0,CustomerId:1,Facebook:2,Twitter:3,Google:4,Microsoft:5,Yahoo:6,Email:7,FacebookCustomAudienceId:9,Other2:10,Other3:11,Other4:12,Other5:13,Other6:14,Other7:15,Other8:16,Other9:17,Other10:18,MobileNumber:19,PhoneNumber2:20,PhoneNumber3:21};IdentityType.isValid=function(a){if("number"==typeof a)for(var b in IdentityType)if(IdentityType.hasOwnProperty(b)&&IdentityType[b]===a)return !0;return !1},IdentityType.getName=function(a){return a===window.mParticle.IdentityType.CustomerId?"Customer ID":a===window.mParticle.IdentityType.Facebook?"Facebook ID":a===window.mParticle.IdentityType.Twitter?"Twitter ID":a===window.mParticle.IdentityType.Google?"Google ID":a===window.mParticle.IdentityType.Microsoft?"Microsoft ID":a===window.mParticle.IdentityType.Yahoo?"Yahoo ID":a===window.mParticle.IdentityType.Email?"Email":a===window.mParticle.IdentityType.FacebookCustomAudienceId?"Facebook App User ID":"Other ID"},IdentityType.getIdentityType=function(a){return "other"===a?IdentityType.Other:"customerid"===a?IdentityType.CustomerId:"facebook"===a?IdentityType.Facebook:"twitter"===a?IdentityType.Twitter:"google"===a?IdentityType.Google:"microsoft"===a?IdentityType.Microsoft:"yahoo"===a?IdentityType.Yahoo:"email"===a?IdentityType.Email:"facebookcustomaudienceid"===a?IdentityType.FacebookCustomAudienceId:"other2"===a?IdentityType.Other2:"other3"===a?IdentityType.Other3:"other4"===a?IdentityType.Other4:"other5"===a?IdentityType.Other5:"other6"===a?IdentityType.Other6:"other7"===a?IdentityType.Other7:"other8"===a?IdentityType.Other8:"other9"===a?IdentityType.Other9:"other10"===a?IdentityType.Other10:"mobile_number"===a?IdentityType.MobileNumber:"phone_number_2"===a?IdentityType.PhoneNumber2:!("phone_number_3"!=a)&&IdentityType.PhoneNumber3},IdentityType.getIdentityName=function(a){return a===IdentityType.Other?"other":a===IdentityType.CustomerId?"customerid":a===IdentityType.Facebook?"facebook":a===IdentityType.Twitter?"twitter":a===IdentityType.Google?"google":a===IdentityType.Microsoft?"microsoft":a===IdentityType.Yahoo?"yahoo":a===IdentityType.Email?"email":a===IdentityType.FacebookCustomAudienceId?"facebookcustomaudienceid":a===IdentityType.Other2?"other2":a===IdentityType.Other3?"other3":a===IdentityType.Other4?"other4":a===IdentityType.Other5?"other5":a===IdentityType.Other6?"other6":a===IdentityType.Other7?"other7":a===IdentityType.Other8?"other8":a===IdentityType.Other9?"other9":a===IdentityType.Other10?"other10":a===IdentityType.MobileNumber?"mobile_number":a===IdentityType.PhoneNumber2?"phone_number_2":a===IdentityType.PhoneNumber3?"phone_number_3":void 0};var ProductActionType={Unknown:0,AddToCart:1,RemoveFromCart:2,Checkout:3,CheckoutOption:4,Click:5,ViewDetail:6,Purchase:7,Refund:8,AddToWishlist:9,RemoveFromWishlist:10};ProductActionType.getName=function(a){return a===ProductActionType.AddToCart?"Add to Cart":a===ProductActionType.RemoveFromCart?"Remove from Cart":a===ProductActionType.Checkout?"Checkout":a===ProductActionType.CheckoutOption?"Checkout Option":a===ProductActionType.Click?"Click":a===ProductActionType.ViewDetail?"View Detail":a===ProductActionType.Purchase?"Purchase":a===ProductActionType.Refund?"Refund":a===ProductActionType.AddToWishlist?"Add to Wishlist":a===ProductActionType.RemoveFromWishlist?"Remove from Wishlist":"Unknown"},ProductActionType.getExpansionName=function(a){return a===ProductActionType.AddToCart?"add_to_cart":a===ProductActionType.RemoveFromCart?"remove_from_cart":a===ProductActionType.Checkout?"checkout":a===ProductActionType.CheckoutOption?"checkout_option":a===ProductActionType.Click?"click":a===ProductActionType.ViewDetail?"view_detail":a===ProductActionType.Purchase?"purchase":a===ProductActionType.Refund?"refund":a===ProductActionType.AddToWishlist?"add_to_wishlist":a===ProductActionType.RemoveFromWishlist?"remove_from_wishlist":"unknown"};var PromotionActionType={Unknown:0,PromotionView:1,PromotionClick:2};PromotionActionType.getName=function(a){return a===PromotionActionType.PromotionView?"view":a===PromotionActionType.PromotionClick?"click":"unknown"},PromotionActionType.getExpansionName=function(a){return a===PromotionActionType.PromotionView?"view":a===PromotionActionType.PromotionClick?"click":"unknown"};var ProfileMessageType={Logout:3},ApplicationTransitionType={AppInit:1};var Types = {MessageType:MessageType,EventType:EventType,CommerceEventType:CommerceEventType,IdentityType:IdentityType,ProfileMessageType:ProfileMessageType,ApplicationTransitionType:ApplicationTransitionType,ProductActionType:ProductActionType,PromotionActionType:PromotionActionType,TriggerUploadType:TriggerUploadType};

  var Constants={sdkVersion:"2.12.2",sdkVendor:"mparticle",platform:"web",Messages:{ErrorMessages:{NoToken:"A token must be specified.",EventNameInvalidType:"Event name must be a valid string value.",EventDataInvalidType:"Event data must be a valid object hash.",LoggingDisabled:"Event logging is currently disabled.",CookieParseError:"Could not parse cookie",EventEmpty:"Event object is null or undefined, cancelling send",APIRequestEmpty:"APIRequest is null or undefined, cancelling send",NoEventType:"Event type must be specified.",TransactionIdRequired:"Transaction ID is required",TransactionRequired:"A transaction attributes object is required",PromotionIdRequired:"Promotion ID is required",BadAttribute:"Attribute value cannot be object or array",BadKey:"Key value cannot be object or array",BadLogPurchase:"Transaction attributes and a product are both required to log a purchase, https://docs.mparticle.com/?javascript#measuring-transactions"},InformationMessages:{CookieSearch:"Searching for cookie",CookieFound:"Cookie found, parsing values",CookieNotFound:"Cookies not found",CookieSet:"Setting cookie",CookieSync:"Performing cookie sync",SendBegin:"Starting to send event",SendIdentityBegin:"Starting to send event to identity server",SendWindowsPhone:"Sending event to Windows Phone container",SendIOS:"Calling iOS path: ",SendAndroid:"Calling Android JS interface method: ",SendHttp:"Sending event to mParticle HTTP service",SendAliasHttp:"Sending alias request to mParticle HTTP service",SendIdentityHttp:"Sending event to mParticle HTTP service",StartingNewSession:"Starting new Session",StartingLogEvent:"Starting to log event",StartingLogOptOut:"Starting to log user opt in/out",StartingEndSession:"Starting to end session",StartingInitialization:"Starting to initialize",StartingLogCommerceEvent:"Starting to log commerce event",StartingAliasRequest:"Starting to Alias MPIDs",LoadingConfig:"Loading configuration options",AbandonLogEvent:"Cannot log event, logging disabled or developer token not set",AbandonAliasUsers:"Cannot Alias Users, logging disabled or developer token not set",AbandonStartSession:"Cannot start session, logging disabled or developer token not set",AbandonEndSession:"Cannot end session, logging disabled or developer token not set",NoSessionToEnd:"Cannot end session, no active session found"},ValidationMessages:{ModifyIdentityRequestUserIdentitiesPresent:"identityRequests to modify require userIdentities to be present. Request not sent to server. Please fix and try again",IdentityRequesetInvalidKey:"There is an invalid key on your identityRequest object. It can only contain a `userIdentities` object and a `onUserAlias` function. Request not sent to server. Please fix and try again.",OnUserAliasType:"The onUserAlias value must be a function. The onUserAlias provided is of type",UserIdentities:"The userIdentities key must be an object with keys of identityTypes and values of strings. Request not sent to server. Please fix and try again.",UserIdentitiesInvalidKey:"There is an invalid identity key on your `userIdentities` object within the identityRequest. Request not sent to server. Please fix and try again.",UserIdentitiesInvalidValues:"All user identity values must be strings or null. Request not sent to server. Please fix and try again.",AliasMissingMpid:"Alias Request must contain both a destinationMpid and a sourceMpid",AliasNonUniqueMpid:"Alias Request's destinationMpid and sourceMpid must be unique",AliasMissingTime:"Alias Request must have both a startTime and an endTime",AliasStartBeforeEndTime:"Alias Request's endTime must be later than its startTime"}},NativeSdkPaths:{LogEvent:"logEvent",SetUserTag:"setUserTag",RemoveUserTag:"removeUserTag",SetUserAttribute:"setUserAttribute",RemoveUserAttribute:"removeUserAttribute",SetSessionAttribute:"setSessionAttribute",AddToCart:"addToCart",RemoveFromCart:"removeFromCart",ClearCart:"clearCart",LogOut:"logOut",SetUserAttributeList:"setUserAttributeList",RemoveAllUserAttributes:"removeAllUserAttributes",GetUserAttributesLists:"getUserAttributesLists",GetAllUserAttributes:"getAllUserAttributes",Identify:"identify",Logout:"logout",Login:"login",Modify:"modify",Alias:"aliasUsers",Upload:"upload"},StorageNames:{localStorageName:"mprtcl-api",// Name of the mP localstorage, had cp and pb even if cookies were used, skipped v2
  localStorageNameV3:"mprtcl-v3",// v3 Name of the mP localstorage, final version on SDKv1
  cookieName:"mprtcl-api",// v1 Name of the cookie stored on the user's machine
  cookieNameV2:"mprtcl-v2",// v2 Name of the cookie stored on the user's machine. Removed keys with no values, moved cartProducts and productBags to localStorage.
  cookieNameV3:"mprtcl-v3",// v3 Name of the cookie stored on the user's machine. Base64 encoded keys in Base64CookieKeys object, final version on SDKv1
  localStorageNameV4:"mprtcl-v4",// v4 Name of the mP localstorage, Current Version
  localStorageProductsV4:"mprtcl-prodv4",// The name for mP localstorage that contains products for cartProducs and productBags
  cookieNameV4:"mprtcl-v4",// v4 Name of the cookie stored on the user's machine. Base64 encoded keys in Base64CookieKeys object, current version on SDK v2
  currentStorageName:"mprtcl-v4",currentStorageProductsName:"mprtcl-prodv4"},DefaultConfig:{cookieDomain:null,// If null, defaults to current location.host
  cookieExpiration:365,// Cookie expiration time in days
  logLevel:null,// What logging will be provided in the console
  timeout:300,// timeout in milliseconds for logging functions
  sessionTimeout:30,// Session timeout in minutes
  maxProducts:20,// Number of products persisted in cartProducts and productBags
  forwarderStatsTimeout:5e3,// Milliseconds for forwarderStats timeout
  integrationDelayTimeout:5e3,// Milliseconds for forcing the integration delay to un-suspend event queueing due to integration partner errors
  maxCookieSize:3e3,// Number of bytes for cookie size to not exceed
  aliasMaxWindow:90,// Max age of Alias request startTime, in days
  uploadInterval:0// Maximum milliseconds in between batch uploads, below 500 will mean immediate upload
  },DefaultUrls:{v1SecureServiceUrl:"jssdks.mparticle.com/v1/JS/",v2SecureServiceUrl:"jssdks.mparticle.com/v2/JS/",v3SecureServiceUrl:"jssdks.mparticle.com/v3/JS/",configUrl:"jssdkcdns.mparticle.com/JS/v2/",identityUrl:"identity.mparticle.com/v1/",aliasUrl:"jssdks.mparticle.com/v1/identity/"},Base64CookieKeys:{csm:1,sa:1,ss:1,ua:1,ui:1,csd:1,ia:1,con:1},SDKv2NonMPIDCookieKeys:{gs:1,cu:1,l:1,globalSettings:1,currentUserMPID:1},HTTPCodes:{noHttpCoverage:-1,activeIdentityRequest:-2,activeSession:-3,validationIssue:-4,nativeIdentityRequest:-5,loggingDisabledOrMissingAPIKey:-6,tooManyRequests:429},FeatureFlags:{ReportBatching:"reportBatching",EventsV3:"eventsV3",EventBatchingIntervalMillis:"eventBatchingIntervalMillis"},DefaultInstance:"default_instance"};

  var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
  });

  var setPrototypeOf = createCommonjsModule(function (module) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf;
  });

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }

  var inherits = _inherits;

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var assertThisInitialized = _assertThisInitialized;

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
      return call;
    }

    return assertThisInitialized(self);
  }

  var possibleConstructorReturn = _possibleConstructorReturn;

  var getPrototypeOf = createCommonjsModule(function (module) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  module.exports = _getPrototypeOf;
  });

  var runtime_1 = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var runtime = (function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] =
      GeneratorFunction.displayName = "GeneratorFunction";

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        prototype[method] = function(arg) {
          return this._invoke(method, arg);
        };
      });
    }

    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };

    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;

      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );

      return exports.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;

          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);

          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };

          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }

      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    Gp[toStringTagSymbol] = "Generator";

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };

    Gp.toString = function() {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    exports.values = values;

    function doneResult() {
      return { value: undefined$1, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined$1;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },

      stop: function() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !! caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }

            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;

  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
     module.exports 
  ));

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  });

  var regenerator = runtime_1;

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  var arrayLikeToArray = _arrayLikeToArray;

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }

  var arrayWithoutHoles = _arrayWithoutHoles;

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  var iterableToArray = _iterableToArray;

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
  }

  var unsupportedIterableToArray = _unsupportedIterableToArray;

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var nonIterableSpread = _nonIterableSpread;

  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
  }

  var toConsumableArray = _toConsumableArray;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var asyncToGenerator = _asyncToGenerator;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var createClass = _createClass;

  var SDKProductActionType;
  (function (a) { a[a.Unknown = 0] = "Unknown", a[a.AddToCart = 1] = "AddToCart", a[a.RemoveFromCart = 2] = "RemoveFromCart", a[a.Checkout = 3] = "Checkout", a[a.CheckoutOption = 4] = "CheckoutOption", a[a.Click = 5] = "Click", a[a.ViewDetail = 6] = "ViewDetail", a[a.Purchase = 7] = "Purchase", a[a.Refund = 8] = "Refund", a[a.AddToWishlist = 9] = "AddToWishlist", a[a.RemoveFromWishlist = 10] = "RemoveFromWishlist"; })(SDKProductActionType || (SDKProductActionType = {}));
  var SDKIdentityTypeEnum;
  (function (a) { a.other = "other", a.customerId = "customerid", a.facebook = "facebook", a.twitter = "twitter", a.google = "google", a.microsoft = "microsoft", a.yahoo = "yahoo", a.email = "email", a.alias = "alias", a.facebookCustomAudienceId = "facebookcustomaudienceid", a.otherId2 = "other2", a.otherId3 = "other3", a.otherId4 = "other4", a.otherId5 = "other5", a.otherId6 = "other6", a.otherId7 = "other7", a.otherId8 = "other8", a.otherId9 = "other9", a.otherId10 = "other10", a.mobileNumber = "mobile_number", a.phoneNumber2 = "phone_number_2", a.phoneNumber3 = "phone_number_3"; })(SDKIdentityTypeEnum || (SDKIdentityTypeEnum = {}));

  var dist = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  (function (ApplicationInformationOsEnum) {
      ApplicationInformationOsEnum["unknown"] = "Unknown";
      ApplicationInformationOsEnum["iOS"] = "IOS";
      ApplicationInformationOsEnum["android"] = "Android";
      ApplicationInformationOsEnum["windowsPhone"] = "WindowsPhone";
      ApplicationInformationOsEnum["mobileWeb"] = "MobileWeb";
      ApplicationInformationOsEnum["unityIOS"] = "UnityIOS";
      ApplicationInformationOsEnum["unityAndroid"] = "UnityAndroid";
      ApplicationInformationOsEnum["desktop"] = "Desktop";
      ApplicationInformationOsEnum["tvOS"] = "TVOS";
      ApplicationInformationOsEnum["roku"] = "Roku";
      ApplicationInformationOsEnum["outOfBand"] = "OutOfBand";
      ApplicationInformationOsEnum["alexa"] = "Alexa";
      ApplicationInformationOsEnum["smartTV"] = "SmartTV";
      ApplicationInformationOsEnum["fireTV"] = "FireTV";
      ApplicationInformationOsEnum["xbox"] = "Xbox";
  })(exports.ApplicationInformationOsEnum || (exports.ApplicationInformationOsEnum = {}));
  (function (ApplicationStateTransitionEventEventTypeEnum) {
      ApplicationStateTransitionEventEventTypeEnum["applicationStateTransition"] = "application_state_transition";
  })(exports.ApplicationStateTransitionEventEventTypeEnum || (exports.ApplicationStateTransitionEventEventTypeEnum = {}));
  (function (ApplicationStateTransitionEventDataApplicationTransitionTypeEnum) {
      ApplicationStateTransitionEventDataApplicationTransitionTypeEnum["applicationInitialized"] = "application_initialized";
      ApplicationStateTransitionEventDataApplicationTransitionTypeEnum["applicationExit"] = "application_exit";
      ApplicationStateTransitionEventDataApplicationTransitionTypeEnum["applicationBackground"] = "application_background";
      ApplicationStateTransitionEventDataApplicationTransitionTypeEnum["applicationForeground"] = "application_foreground";
  })(exports.ApplicationStateTransitionEventDataApplicationTransitionTypeEnum || (exports.ApplicationStateTransitionEventDataApplicationTransitionTypeEnum = {}));
  (function (BatchEnvironmentEnum) {
      BatchEnvironmentEnum["unknown"] = "unknown";
      BatchEnvironmentEnum["development"] = "development";
      BatchEnvironmentEnum["production"] = "production";
  })(exports.BatchEnvironmentEnum || (exports.BatchEnvironmentEnum = {}));
  (function (BreadcrumbEventEventTypeEnum) {
      BreadcrumbEventEventTypeEnum["breadcrumb"] = "breadcrumb";
  })(exports.BreadcrumbEventEventTypeEnum || (exports.BreadcrumbEventEventTypeEnum = {}));
  (function (CommerceEventEventTypeEnum) {
      CommerceEventEventTypeEnum["commerceEvent"] = "commerce_event";
  })(exports.CommerceEventEventTypeEnum || (exports.CommerceEventEventTypeEnum = {}));
  (function (CommerceEventDataCustomEventTypeEnum) {
      CommerceEventDataCustomEventTypeEnum["addToCart"] = "add_to_cart";
      CommerceEventDataCustomEventTypeEnum["removeFromCart"] = "remove_from_cart";
      CommerceEventDataCustomEventTypeEnum["checkout"] = "checkout";
      CommerceEventDataCustomEventTypeEnum["checkoutOption"] = "checkout_option";
      CommerceEventDataCustomEventTypeEnum["click"] = "click";
      CommerceEventDataCustomEventTypeEnum["viewDetail"] = "view_detail";
      CommerceEventDataCustomEventTypeEnum["purchase"] = "purchase";
      CommerceEventDataCustomEventTypeEnum["refund"] = "refund";
      CommerceEventDataCustomEventTypeEnum["promotionView"] = "promotion_view";
      CommerceEventDataCustomEventTypeEnum["promotionClick"] = "promotion_click";
      CommerceEventDataCustomEventTypeEnum["addToWishlist"] = "add_to_wishlist";
      CommerceEventDataCustomEventTypeEnum["removeFromWishlist"] = "remove_from_wishlist";
      CommerceEventDataCustomEventTypeEnum["impression"] = "impression";
  })(exports.CommerceEventDataCustomEventTypeEnum || (exports.CommerceEventDataCustomEventTypeEnum = {}));
  (function (CrashReportEventEventTypeEnum) {
      CrashReportEventEventTypeEnum["crashReport"] = "crash_report";
  })(exports.CrashReportEventEventTypeEnum || (exports.CrashReportEventEventTypeEnum = {}));
  (function (CustomEventEventTypeEnum) {
      CustomEventEventTypeEnum["customEvent"] = "custom_event";
  })(exports.CustomEventEventTypeEnum || (exports.CustomEventEventTypeEnum = {}));
  (function (CustomEventDataCustomEventTypeEnum) {
      CustomEventDataCustomEventTypeEnum["navigation"] = "navigation";
      CustomEventDataCustomEventTypeEnum["location"] = "location";
      CustomEventDataCustomEventTypeEnum["search"] = "search";
      CustomEventDataCustomEventTypeEnum["transaction"] = "transaction";
      CustomEventDataCustomEventTypeEnum["userContent"] = "user_content";
      CustomEventDataCustomEventTypeEnum["userPreference"] = "user_preference";
      CustomEventDataCustomEventTypeEnum["social"] = "social";
      CustomEventDataCustomEventTypeEnum["media"] = "media";
      CustomEventDataCustomEventTypeEnum["other"] = "other";
      CustomEventDataCustomEventTypeEnum["unknown"] = "unknown";
  })(exports.CustomEventDataCustomEventTypeEnum || (exports.CustomEventDataCustomEventTypeEnum = {}));
  (function (DeviceCurrentStateDeviceOrientationEnum) {
      DeviceCurrentStateDeviceOrientationEnum["portrait"] = "portrait";
      DeviceCurrentStateDeviceOrientationEnum["portraitUpsideDown"] = "portrait_upside_down";
      DeviceCurrentStateDeviceOrientationEnum["landscape"] = "landscape";
      DeviceCurrentStateDeviceOrientationEnum["landscapeLeft"] = "LandscapeLeft";
      DeviceCurrentStateDeviceOrientationEnum["landscapeRight"] = "LandscapeRight";
      DeviceCurrentStateDeviceOrientationEnum["faceUp"] = "FaceUp";
      DeviceCurrentStateDeviceOrientationEnum["faceDown"] = "FaceDown";
      DeviceCurrentStateDeviceOrientationEnum["square"] = "Square";
  })(exports.DeviceCurrentStateDeviceOrientationEnum || (exports.DeviceCurrentStateDeviceOrientationEnum = {}));
  (function (DeviceCurrentStateStatusBarOrientationEnum) {
      DeviceCurrentStateStatusBarOrientationEnum["portrait"] = "portrait";
      DeviceCurrentStateStatusBarOrientationEnum["portraitUpsideDown"] = "portrait_upside_down";
      DeviceCurrentStateStatusBarOrientationEnum["landscape"] = "landscape";
      DeviceCurrentStateStatusBarOrientationEnum["landscapeLeft"] = "LandscapeLeft";
      DeviceCurrentStateStatusBarOrientationEnum["landscapeRight"] = "LandscapeRight";
      DeviceCurrentStateStatusBarOrientationEnum["faceUp"] = "FaceUp";
      DeviceCurrentStateStatusBarOrientationEnum["faceDown"] = "FaceDown";
      DeviceCurrentStateStatusBarOrientationEnum["square"] = "Square";
  })(exports.DeviceCurrentStateStatusBarOrientationEnum || (exports.DeviceCurrentStateStatusBarOrientationEnum = {}));
  (function (DeviceInformationPlatformEnum) {
      DeviceInformationPlatformEnum["iOS"] = "iOS";
      DeviceInformationPlatformEnum["android"] = "Android";
      DeviceInformationPlatformEnum["web"] = "web";
      DeviceInformationPlatformEnum["desktop"] = "desktop";
      DeviceInformationPlatformEnum["tvOS"] = "tvOS";
      DeviceInformationPlatformEnum["roku"] = "roku";
      DeviceInformationPlatformEnum["outOfBand"] = "out_of_band";
      DeviceInformationPlatformEnum["smartTV"] = "smart_tv";
      DeviceInformationPlatformEnum["xbox"] = "xbox";
  })(exports.DeviceInformationPlatformEnum || (exports.DeviceInformationPlatformEnum = {}));
  (function (EventTypeEnum) {
      EventTypeEnum["unknown"] = "unknown";
      EventTypeEnum["sessionStart"] = "session_start";
      EventTypeEnum["sessionEnd"] = "session_end";
      EventTypeEnum["screenView"] = "screen_view";
      EventTypeEnum["customEvent"] = "custom_event";
      EventTypeEnum["crashReport"] = "crash_report";
      EventTypeEnum["optOut"] = "opt_out";
      EventTypeEnum["firstRun"] = "first_run";
      EventTypeEnum["preAttribution"] = "pre_attribution";
      EventTypeEnum["pushRegistration"] = "push_registration";
      EventTypeEnum["applicationStateTransition"] = "application_state_transition";
      EventTypeEnum["pushMessage"] = "push_message";
      EventTypeEnum["networkPerformance"] = "network_performance";
      EventTypeEnum["breadcrumb"] = "breadcrumb";
      EventTypeEnum["profile"] = "profile";
      EventTypeEnum["pushReaction"] = "push_reaction";
      EventTypeEnum["commerceEvent"] = "commerce_event";
      EventTypeEnum["userAttributeChange"] = "user_attribute_change";
      EventTypeEnum["userIdentityChange"] = "user_identity_change";
      EventTypeEnum["uninstall"] = "uninstall";
      EventTypeEnum["validationResult"] = "validation_result";
  })(exports.EventTypeEnum || (exports.EventTypeEnum = {}));
  (function (IdentityTypeEnum) {
      IdentityTypeEnum["other"] = "other";
      IdentityTypeEnum["customerId"] = "customer_id";
      IdentityTypeEnum["facebook"] = "facebook";
      IdentityTypeEnum["twitter"] = "twitter";
      IdentityTypeEnum["google"] = "google";
      IdentityTypeEnum["microsoft"] = "microsoft";
      IdentityTypeEnum["yahoo"] = "yahoo";
      IdentityTypeEnum["email"] = "email";
      IdentityTypeEnum["alias"] = "alias";
      IdentityTypeEnum["facebookCustomAudienceId"] = "facebook_custom_audience_id";
      IdentityTypeEnum["otherId2"] = "other_id_2";
      IdentityTypeEnum["otherId3"] = "other_id_3";
      IdentityTypeEnum["otherId4"] = "other_id_4";
      IdentityTypeEnum["otherId5"] = "other_id_5";
      IdentityTypeEnum["otherId6"] = "other_id_6";
      IdentityTypeEnum["otherId7"] = "other_id_7";
      IdentityTypeEnum["otherId8"] = "other_id_8";
      IdentityTypeEnum["otherId9"] = "other_id_9";
      IdentityTypeEnum["otherId10"] = "other_id_10";
      IdentityTypeEnum["mobileNumber"] = "mobile_number";
      IdentityTypeEnum["phoneNumber2"] = "phone_number_2";
      IdentityTypeEnum["phoneNumber3"] = "phone_number_3";
  })(exports.IdentityTypeEnum || (exports.IdentityTypeEnum = {}));
  (function (NetworkPerformanceEventEventTypeEnum) {
      NetworkPerformanceEventEventTypeEnum["networkPerformance"] = "network_performance";
  })(exports.NetworkPerformanceEventEventTypeEnum || (exports.NetworkPerformanceEventEventTypeEnum = {}));
  (function (OptOutEventEnum) {
      OptOutEventEnum["optOut"] = "opt_out";
  })(exports.OptOutEventEnum || (exports.OptOutEventEnum = {}));
  (function (ProductActionActionEnum) {
      ProductActionActionEnum["unknown"] = "unknown";
      ProductActionActionEnum["addToCart"] = "add_to_cart";
      ProductActionActionEnum["removeFromCart"] = "remove_from_cart";
      ProductActionActionEnum["checkout"] = "checkout";
      ProductActionActionEnum["checkoutOption"] = "checkout_option";
      ProductActionActionEnum["click"] = "click";
      ProductActionActionEnum["viewDetail"] = "view_detail";
      ProductActionActionEnum["purchase"] = "purchase";
      ProductActionActionEnum["refund"] = "refund";
      ProductActionActionEnum["addToWishlist"] = "add_to_wishlist";
      ProductActionActionEnum["removeFromWishlist"] = "remove_from_wish_list";
  })(exports.ProductActionActionEnum || (exports.ProductActionActionEnum = {}));
  (function (ProfileEventEventTypeEnum) {
      ProfileEventEventTypeEnum["profile"] = "profile";
  })(exports.ProfileEventEventTypeEnum || (exports.ProfileEventEventTypeEnum = {}));
  (function (ProfileEventDataProfileEventTypeEnum) {
      ProfileEventDataProfileEventTypeEnum["signup"] = "signup";
      ProfileEventDataProfileEventTypeEnum["login"] = "login";
      ProfileEventDataProfileEventTypeEnum["logout"] = "logout";
      ProfileEventDataProfileEventTypeEnum["update"] = "update";
      ProfileEventDataProfileEventTypeEnum["delete"] = "delete";
  })(exports.ProfileEventDataProfileEventTypeEnum || (exports.ProfileEventDataProfileEventTypeEnum = {}));
  (function (PromotionActionActionEnum) {
      PromotionActionActionEnum["view"] = "view";
      PromotionActionActionEnum["click"] = "click";
  })(exports.PromotionActionActionEnum || (exports.PromotionActionActionEnum = {}));
  (function (PushMessageEventEventTypeEnum) {
      PushMessageEventEventTypeEnum["pushMessage"] = "push_message";
  })(exports.PushMessageEventEventTypeEnum || (exports.PushMessageEventEventTypeEnum = {}));
  (function (PushMessageEventDataPushMessageTypeEnum) {
      PushMessageEventDataPushMessageTypeEnum["sent"] = "sent";
      PushMessageEventDataPushMessageTypeEnum["received"] = "received";
      PushMessageEventDataPushMessageTypeEnum["action"] = "action";
  })(exports.PushMessageEventDataPushMessageTypeEnum || (exports.PushMessageEventDataPushMessageTypeEnum = {}));
  (function (PushMessageEventDataApplicationStateEnum) {
      PushMessageEventDataApplicationStateEnum["notRunning"] = "not_running";
      PushMessageEventDataApplicationStateEnum["background"] = "background";
      PushMessageEventDataApplicationStateEnum["foreground"] = "foreground";
  })(exports.PushMessageEventDataApplicationStateEnum || (exports.PushMessageEventDataApplicationStateEnum = {}));
  (function (PushMessageEventDataPushMessageBehaviorEnum) {
      PushMessageEventDataPushMessageBehaviorEnum["received"] = "Received";
      PushMessageEventDataPushMessageBehaviorEnum["directOpen"] = "DirectOpen";
      PushMessageEventDataPushMessageBehaviorEnum["read"] = "Read";
      PushMessageEventDataPushMessageBehaviorEnum["influencedOpen"] = "InfluencedOpen";
      PushMessageEventDataPushMessageBehaviorEnum["displayed"] = "Displayed";
  })(exports.PushMessageEventDataPushMessageBehaviorEnum || (exports.PushMessageEventDataPushMessageBehaviorEnum = {}));
  (function (PushRegistrationEventEventTypeEnum) {
      PushRegistrationEventEventTypeEnum["pushRegistration"] = "push_registration";
  })(exports.PushRegistrationEventEventTypeEnum || (exports.PushRegistrationEventEventTypeEnum = {}));
  (function (SessionEndEventEventTypeEnum) {
      SessionEndEventEventTypeEnum["sessionEnd"] = "session_end";
  })(exports.SessionEndEventEventTypeEnum || (exports.SessionEndEventEventTypeEnum = {}));
  (function (SessionStartEventEventTypeEnum) {
      SessionStartEventEventTypeEnum["sessionStart"] = "session_start";
  })(exports.SessionStartEventEventTypeEnum || (exports.SessionStartEventEventTypeEnum = {}));
  (function (SourceInformationChannelEnum) {
      SourceInformationChannelEnum["native"] = "native";
      SourceInformationChannelEnum["javascript"] = "javascript";
      SourceInformationChannelEnum["pixel"] = "pixel";
      SourceInformationChannelEnum["desktop"] = "desktop";
      SourceInformationChannelEnum["partner"] = "partner";
      SourceInformationChannelEnum["serverToServer"] = "server_to_server";
  })(exports.SourceInformationChannelEnum || (exports.SourceInformationChannelEnum = {}));
  (function (UserAttributeChangeEventEventTypeEnum) {
      UserAttributeChangeEventEventTypeEnum["userAttributeChange"] = "user_attribute_change";
  })(exports.UserAttributeChangeEventEventTypeEnum || (exports.UserAttributeChangeEventEventTypeEnum = {}));
  (function (UserIdentityChangeEventEventTypeEnum) {
      UserIdentityChangeEventEventTypeEnum["userIdentityChange"] = "user_identity_change";
  })(exports.UserIdentityChangeEventEventTypeEnum || (exports.UserIdentityChangeEventEventTypeEnum = {}));
  });

  unwrapExports(dist);
  dist.ApplicationInformationOsEnum;
  dist.ApplicationStateTransitionEventEventTypeEnum;
  var dist_3 = dist.ApplicationStateTransitionEventDataApplicationTransitionTypeEnum;
  var dist_4 = dist.BatchEnvironmentEnum;
  dist.BreadcrumbEventEventTypeEnum;
  dist.CommerceEventEventTypeEnum;
  var dist_7 = dist.CommerceEventDataCustomEventTypeEnum;
  dist.CrashReportEventEventTypeEnum;
  dist.CustomEventEventTypeEnum;
  var dist_10 = dist.CustomEventDataCustomEventTypeEnum;
  dist.DeviceCurrentStateDeviceOrientationEnum;
  dist.DeviceCurrentStateStatusBarOrientationEnum;
  var dist_13 = dist.DeviceInformationPlatformEnum;
  var dist_14 = dist.EventTypeEnum;
  var dist_15 = dist.IdentityTypeEnum;
  dist.NetworkPerformanceEventEventTypeEnum;
  dist.OptOutEventEnum;
  var dist_18 = dist.ProductActionActionEnum;
  dist.ProfileEventEventTypeEnum;
  dist.ProfileEventDataProfileEventTypeEnum;
  dist.PromotionActionActionEnum;
  dist.PushMessageEventEventTypeEnum;
  dist.PushMessageEventDataPushMessageTypeEnum;
  dist.PushMessageEventDataApplicationStateEnum;
  dist.PushMessageEventDataPushMessageBehaviorEnum;
  dist.PushRegistrationEventEventTypeEnum;
  dist.SessionEndEventEventTypeEnum;
  dist.SessionStartEventEventTypeEnum;
  dist.SourceInformationChannelEnum;
  dist.UserAttributeChangeEventEventTypeEnum;
  dist.UserIdentityChangeEventEventTypeEnum;

  function ownKeys(a, b) { var c = Object.keys(a); if (Object.getOwnPropertySymbols) {
      var d = Object.getOwnPropertySymbols(a);
      b && (d = d.filter(function (b) { return Object.getOwnPropertyDescriptor(a, b).enumerable; })), c.push.apply(c, d);
  } return c; }
  function _objectSpread(a) { for (var b, c = 1; c < arguments.length; c++)
      b = null == arguments[c] ? {} : arguments[c], c % 2 ? ownKeys(Object(b), !0).forEach(function (c) { defineProperty(a, c, b[c]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(b)) : ownKeys(Object(b)).forEach(function (c) { Object.defineProperty(a, c, Object.getOwnPropertyDescriptor(b, c)); }); return a; }
  function _createForOfIteratorHelper(a) { if ("undefined" == typeof Symbol || null == a[Symbol.iterator]) {
      if (Array.isArray(a) || (a = _unsupportedIterableToArray$1(a))) {
          var b = 0, c = function () { };
          return { s: c, n: function n() { return b >= a.length ? { done: !0 } : { done: !1, value: a[b++] }; }, e: function e(a) { throw a; }, f: c };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  } var d, e, g = !1; return { s: function s() { d = a[Symbol.iterator](); }, n: function n() { var a = d.next(); return a.done, a; }, e: function e(a) { g = !0, e = a; }, f: function f() { try {
          f || null == d["return"] || d["return"]();
      }
      finally {
          if (g)
              throw e;
      } } }; }
  function _unsupportedIterableToArray$1(a, b) { if (a) {
      if ("string" == typeof a)
          return _arrayLikeToArray$1(a, b);
      var c = Object.prototype.toString.call(a).slice(8, -1);
      return "Object" === c && a.constructor && (c = a.constructor.name), "Map" === c || "Set" === c ? Array.from(a) : "Arguments" === c || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c) ? _arrayLikeToArray$1(a, b) : void 0;
  } }
  function _arrayLikeToArray$1(a, b) { (null == b || b > a.length) && (b = a.length); for (var c = 0, d = Array(b); c < b; c++)
      d[c] = a[c]; return d; }
  function convertEvents(a, b, c) { if (!a)
      return null; if (!b || 1 > b.length)
      return null; var d, e = [], f = null, g = _createForOfIteratorHelper(b); try {
      for (g.s(); !(d = g.n()).done;) {
          var i = d.value;
          if (i) {
              f = i;
              var j = convertEvent(i);
              j && e.push(j);
          }
      }
  }
  catch (a) {
      g.e(a);
  }
  finally {
      g.f();
  } if (!f)
      return null; var h = { source_request_id: c._Helpers.generateUniqueId(), mpid: a, timestamp_unixtime_ms: new Date().getTime(), environment: f.Debug ? dist_4.development : dist_4.production, events: e, mp_deviceid: f.DeviceId, sdk_version: f.SDKVersion, application_info: { application_version: f.AppVersion, application_name: f.AppName }, device_info: { platform: dist_13.web, screen_width: window.screen.width, screen_height: window.screen.height }, user_attributes: f.UserAttributes, user_identities: convertUserIdentities(f.UserIdentities), consent_state: convertConsentState(f.ConsentState), integration_attributes: f.IntegrationAttributes }; return f.DataPlan && f.DataPlan.PlanId && (h.context = { data_plan: { plan_id: f.DataPlan.PlanId, plan_version: f.DataPlan.PlanVersion || void 0 } }), h; }
  function convertConsentState(a) { if (!a)
      return null; var b = { gdpr: convertGdprConsentState(a.getGDPRConsentState()), ccpa: convertCcpaConsentState(a.getCCPAConsentState()) }; return b; }
  function convertGdprConsentState(a) { if (!a)
      return null; var b = {}; for (var c in a)
      a.hasOwnProperty(c) && (b[c] = { consented: a[c].Consented, hardware_id: a[c].HardwareId, document: a[c].ConsentDocument, timestamp_unixtime_ms: a[c].Timestamp, location: a[c].Location }); return b; }
  function convertCcpaConsentState(a) { if (!a)
      return null; var b = { data_sale_opt_out: { consented: a.Consented, hardware_id: a.HardwareId, document: a.ConsentDocument, timestamp_unixtime_ms: a.Timestamp, location: a.Location } }; return b; }
  function convertUserIdentities(a) { if (!a || !a.length)
      return null; var b, c = {}, d = _createForOfIteratorHelper(a); try {
      for (d.s(); !(b = d.n()).done;) {
          var e = b.value;
          switch (e.Type) {
              case Types.IdentityType.CustomerId:
                  c.customer_id = e.Identity;
                  break;
              case Types.IdentityType.Email:
                  c.email = e.Identity;
                  break;
              case Types.IdentityType.Facebook:
                  c.facebook = e.Identity;
                  break;
              case Types.IdentityType.FacebookCustomAudienceId:
                  c.facebook_custom_audience_id = e.Identity;
                  break;
              case Types.IdentityType.Google:
                  c.google = e.Identity;
                  break;
              case Types.IdentityType.Microsoft:
                  c.microsoft = e.Identity;
                  break;
              case Types.IdentityType.Other:
                  c.other = e.Identity;
                  break;
              case Types.IdentityType.Other2:
                  c.other_id_2 = e.Identity;
                  break;
              case Types.IdentityType.Other3:
                  c.other_id_3 = e.Identity;
                  break;
              case Types.IdentityType.Other4:
                  c.other_id_4 = e.Identity;
                  break;
              case Types.IdentityType.Other5:
                  c.other_id_5 = e.Identity;
                  break;
              case Types.IdentityType.Other6:
                  c.other_id_6 = e.Identity;
                  break;
              case Types.IdentityType.Other7:
                  c.other_id_7 = e.Identity;
                  break;
              case Types.IdentityType.Other8:
                  c.other_id_8 = e.Identity;
                  break;
              case Types.IdentityType.Other9:
                  c.other_id_9 = e.Identity;
                  break;
              case Types.IdentityType.Other10:
                  c.other_id_10 = e.Identity;
                  break;
              case Types.IdentityType.MobileNumber:
                  c.mobile_number = e.Identity;
                  break;
              case Types.IdentityType.PhoneNumber2:
                  c.phone_number_2 = e.Identity;
                  break;
              case Types.IdentityType.PhoneNumber3:
                  c.phone_number_3 = e.Identity;
                  break;
              default:
          }
      }
  }
  catch (a) {
      d.e(a);
  }
  finally {
      d.f();
  } return c; }
  function convertEvent(a) {
      if (!a)
          return null;
      switch (a.EventDataType) {
          case Types.MessageType.AppStateTransition: return convertAST(a);
          case Types.MessageType.Commerce: return convertCommerceEvent(a);
          case Types.MessageType.CrashReport: return convertCrashReportEvent(a);
          case Types.MessageType.OptOut: return convertOptOutEvent(a);
          case Types.MessageType.PageEvent: // Note: Media Events are also sent as PageEvents/CustomEvents
              return convertCustomEvent(a);
          case Types.MessageType.PageView: return convertPageViewEvent(a);
          case Types.MessageType.Profile: //deprecated and not supported by the web SDK
              return null;
          case Types.MessageType.SessionEnd: return convertSessionEndEvent(a);
          case Types.MessageType.SessionStart: return convertSessionStartEvent(a);
          case Types.MessageType.UserAttributeChange: return convertUserAttributeChangeEvent(a);
          case Types.MessageType.UserIdentityChange: return convertUserIdentityChangeEvent(a);
      }
      return null;
  }
  function convertProductActionType(a) { if (!a)
      return dist_18.unknown; return a === SDKProductActionType.AddToCart ? dist_18.addToCart : a === SDKProductActionType.AddToWishlist ? dist_18.addToWishlist : a === SDKProductActionType.Checkout ? dist_18.checkout : a === SDKProductActionType.CheckoutOption ? dist_18.checkoutOption : a === SDKProductActionType.Click ? dist_18.click : a === SDKProductActionType.Purchase ? dist_18.purchase : a === SDKProductActionType.Refund ? dist_18.refund : a === SDKProductActionType.RemoveFromCart ? dist_18.removeFromCart : a === SDKProductActionType.RemoveFromWishlist ? dist_18.removeFromWishlist : a === SDKProductActionType.ViewDetail ? dist_18.viewDetail : dist_18.unknown; }
  function convertProductAction(a) { if (!a.ProductAction)
      return null; var b = { action: convertProductActionType(a.ProductAction.ProductActionType), checkout_step: a.ProductAction.CheckoutStep, checkout_options: a.ProductAction.CheckoutOptions, transaction_id: a.ProductAction.TransactionId, affiliation: a.ProductAction.Affiliation, total_amount: a.ProductAction.TotalAmount, tax_amount: a.ProductAction.TaxAmount, shipping_amount: a.ProductAction.ShippingAmount, coupon_code: a.ProductAction.CouponCode, products: convertProducts(a.ProductAction.ProductList) }; return b; }
  function convertProducts(a) { if (!a || !a.length)
      return null; var b, c = [], d = _createForOfIteratorHelper(a); try {
      for (d.s(); !(b = d.n()).done;) {
          var e = b.value, f = { id: e.Sku, name: e.Name, brand: e.Brand, category: e.Category, variant: e.Variant, total_product_amount: e.TotalAmount, position: e.Position, price: e.Price, quantity: e.Quantity, coupon_code: e.CouponCode, custom_attributes: e.Attributes };
          c.push(f);
      }
  }
  catch (a) {
      d.e(a);
  }
  finally {
      d.f();
  } return c; }
  function convertPromotionAction(a) { if (!a.PromotionAction)
      return null; var b = { action: a.PromotionAction.PromotionActionType, promotions: convertPromotions(a.PromotionAction.PromotionList) }; return b; }
  function convertPromotions(a) { if (!a || !a.length)
      return null; var b, c = [], d = _createForOfIteratorHelper(a); try {
      for (d.s(); !(b = d.n()).done;) {
          var e = b.value, f = { id: e.Id, name: e.Name, creative: e.Creative, position: e.Position };
          c.push(f);
      }
  }
  catch (a) {
      d.e(a);
  }
  finally {
      d.f();
  } return c; }
  function convertImpressions(a) { if (!a.ProductImpressions)
      return null; var b, c = [], d = _createForOfIteratorHelper(a.ProductImpressions); try {
      for (d.s(); !(b = d.n()).done;) {
          var e = b.value, f = { product_impression_list: e.ProductImpressionList, products: convertProducts(e.ProductList) };
          c.push(f);
      }
  }
  catch (a) {
      d.e(a);
  }
  finally {
      d.f();
  } return c; }
  function convertShoppingCart(a) { if (!a.ShoppingCart || !a.ShoppingCart.ProductList || !a.ShoppingCart.ProductList.length)
      return null; var b = { products: convertProducts(a.ShoppingCart.ProductList) }; return b; }
  function convertCommerceEvent(a) { var b = convertBaseEventData(a), c = { custom_flags: a.CustomFlags, product_action: convertProductAction(a), promotion_action: convertPromotionAction(a), product_impressions: convertImpressions(a), shopping_cart: convertShoppingCart(a), currency_code: a.CurrencyCode }; return c = Object.assign(c, b), { event_type: dist_14.commerceEvent, data: c }; }
  function convertCrashReportEvent(a) { var b = convertBaseEventData(a), c = { message: a.EventName }; return c = Object.assign(c, b), { event_type: dist_14.crashReport, data: c }; }
  function convertAST(a) { var b = convertBaseEventData(a), c = { application_transition_type: dist_3.applicationInitialized, is_first_run: a.IsFirstRun, is_upgrade: !1 }; return c = Object.assign(c, b), { event_type: dist_14.applicationStateTransition, data: c }; }
  function convertSessionEndEvent(a) {
      var b = convertBaseEventData(a), c = { session_duration_ms: a.SessionLength //note: External Events DTO does not support the session mpids array as of this time.
          //spanning_mpids: sdkEvent.SessionMpids
      };
      return c = Object.assign(c, b), { event_type: dist_14.sessionEnd, data: c };
  }
  function convertSessionStartEvent(a) { var b = convertBaseEventData(a), c = {}; return c = Object.assign(c, b), { event_type: dist_14.sessionStart, data: c }; }
  function convertPageViewEvent(a) { var b = convertBaseEventData(a), c = { custom_flags: a.CustomFlags, screen_name: a.EventName }; return c = Object.assign(c, b), { event_type: dist_14.screenView, data: c }; }
  function convertOptOutEvent(a) { var b = convertBaseEventData(a), c = { is_opted_out: a.OptOut }; return c = Object.assign(c, b), { event_type: dist_14.optOut, data: c }; }
  function convertCustomEvent(a) { var b = convertBaseEventData(a), c = { custom_event_type: convertSdkEventType(a.EventCategory), custom_flags: a.CustomFlags, event_name: a.EventName }; return c = Object.assign(c, b), { event_type: dist_14.customEvent, data: c }; }
  function convertSdkEventType(a) { return a === Types.EventType.Other ? dist_10.other : a === Types.EventType.Location ? dist_10.location : a === Types.EventType.Navigation ? dist_10.navigation : a === Types.EventType.Search ? dist_10.search : a === Types.EventType.Social ? dist_10.social : a === Types.EventType.Transaction ? dist_10.transaction : a === Types.EventType.UserContent ? dist_10.userContent : a === Types.EventType.UserPreference ? dist_10.userPreference : a === Types.EventType.Media ? dist_10.media : a === Types.CommerceEventType.ProductAddToCart ? dist_7.addToCart : a === Types.CommerceEventType.ProductAddToWishlist ? dist_7.addToWishlist : a === Types.CommerceEventType.ProductCheckout ? dist_7.checkout : a === Types.CommerceEventType.ProductCheckoutOption ? dist_7.checkoutOption : a === Types.CommerceEventType.ProductClick ? dist_7.click : a === Types.CommerceEventType.ProductImpression ? dist_7.impression : a === Types.CommerceEventType.ProductPurchase ? dist_7.purchase : a === Types.CommerceEventType.ProductRefund ? dist_7.refund : a === Types.CommerceEventType.ProductRemoveFromCart ? dist_7.removeFromCart : a === Types.CommerceEventType.ProductRemoveFromWishlist ? dist_7.removeFromWishlist : a === Types.CommerceEventType.ProductViewDetail ? dist_7.viewDetail : a === Types.CommerceEventType.PromotionClick ? dist_7.promotionClick : a === Types.CommerceEventType.PromotionView ? dist_7.promotionView : dist_10.unknown; }
  function convertBaseEventData(a) { var b = { timestamp_unixtime_ms: a.Timestamp, session_uuid: a.SessionId, session_start_unixtime_ms: a.SessionStartDate, custom_attributes: a.EventAttributes, location: convertSDKLocation(a.Location) }; return b; }
  function convertSDKLocation(a) { return a && Object.keys(a).length ? { latitude: a.lat, longitude: a.lng } : null; }
  function convertUserAttributeChangeEvent(a) { var b = convertBaseEventData(a), c = { user_attribute_name: a.UserAttributeChanges.UserAttributeName, new: a.UserAttributeChanges.New, old: a.UserAttributeChanges.Old, deleted: a.UserAttributeChanges.Deleted, is_new_attribute: a.UserAttributeChanges.IsNewAttribute }; return c = _objectSpread(_objectSpread({}, c), b), { event_type: dist_14.userAttributeChange, data: c }; }
  function convertUserIdentityChangeEvent(a) { var b = convertBaseEventData(a), c = { new: { identity_type: convertUserIdentityTypeToServerIdentityType(a.UserIdentityChanges.New.IdentityType), identity: a.UserIdentityChanges.New.Identity || null, timestamp_unixtime_ms: a.Timestamp, created_this_batch: a.UserIdentityChanges.New.CreatedThisBatch }, old: { identity_type: convertUserIdentityTypeToServerIdentityType(a.UserIdentityChanges.Old.IdentityType), identity: a.UserIdentityChanges.Old.Identity || null, timestamp_unixtime_ms: a.Timestamp, created_this_batch: a.UserIdentityChanges.Old.CreatedThisBatch } }; return c = Object.assign(c, b), { event_type: dist_14.userIdentityChange, data: c }; }
  function convertUserIdentityTypeToServerIdentityType(a) { return a === SDKIdentityTypeEnum.other ? dist_15.other : a === SDKIdentityTypeEnum.customerId ? dist_15.customerId : a === SDKIdentityTypeEnum.facebook ? dist_15.facebook : a === SDKIdentityTypeEnum.twitter ? dist_15.twitter : a === SDKIdentityTypeEnum.google ? dist_15.google : a === SDKIdentityTypeEnum.microsoft ? dist_15.microsoft : a === SDKIdentityTypeEnum.yahoo ? dist_15.yahoo : a === SDKIdentityTypeEnum.email ? dist_15.email : a === SDKIdentityTypeEnum.alias ? dist_15.alias : a === SDKIdentityTypeEnum.facebookCustomAudienceId ? dist_15.facebookCustomAudienceId : a === SDKIdentityTypeEnum.otherId2 ? dist_15.otherId2 : a === SDKIdentityTypeEnum.otherId3 ? dist_15.otherId3 : a === SDKIdentityTypeEnum.otherId4 ? dist_15.otherId4 : a === SDKIdentityTypeEnum.otherId5 ? dist_15.otherId5 : a === SDKIdentityTypeEnum.otherId6 ? dist_15.otherId6 : a === SDKIdentityTypeEnum.otherId7 ? dist_15.otherId7 : a === SDKIdentityTypeEnum.otherId8 ? dist_15.otherId8 : a === SDKIdentityTypeEnum.otherId9 ? dist_15.otherId9 : a === SDKIdentityTypeEnum.otherId10 ? dist_15.otherId10 : a === SDKIdentityTypeEnum.mobileNumber ? dist_15.mobileNumber : a === SDKIdentityTypeEnum.phoneNumber2 ? dist_15.phoneNumber2 : a === SDKIdentityTypeEnum.phoneNumber3 ? dist_15.phoneNumber3 : void 0; }

  function _createSuper(a) { var b = _isNativeReflectConstruct(); return function () { var c, d = getPrototypeOf(a); if (b) {
      var e = getPrototypeOf(this).constructor;
      c = Reflect.construct(d, arguments, e);
  }
  else
      c = d.apply(this, arguments); return possibleConstructorReturn(this, c); }; }
  function _isNativeReflectConstruct() { if ("undefined" == typeof Reflect || !Reflect.construct)
      return !1; if (Reflect.construct.sham)
      return !1; if ("function" == typeof Proxy)
      return !0; try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0;
  }
  catch (a) {
      return !1;
  } }
  function _createForOfIteratorHelper$1(a) { if ("undefined" == typeof Symbol || null == a[Symbol.iterator]) {
      if (Array.isArray(a) || (a = _unsupportedIterableToArray$2(a))) {
          var b = 0, c = function () { };
          return { s: c, n: function n() { return b >= a.length ? { done: !0 } : { done: !1, value: a[b++] }; }, e: function e(a) { throw a; }, f: c };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  } var d, e, g = !1; return { s: function s() { d = a[Symbol.iterator](); }, n: function n() { var a = d.next(); return a.done, a; }, e: function e(a) { g = !0, e = a; }, f: function f() { try {
          f || null == d["return"] || d["return"]();
      }
      finally {
          if (g)
              throw e;
      } } }; }
  function _unsupportedIterableToArray$2(a, b) { if (a) {
      if ("string" == typeof a)
          return _arrayLikeToArray$2(a, b);
      var c = Object.prototype.toString.call(a).slice(8, -1);
      return "Object" === c && a.constructor && (c = a.constructor.name), "Map" === c || "Set" === c ? Array.from(a) : "Arguments" === c || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c) ? _arrayLikeToArray$2(a, b) : void 0;
  } }
  function _arrayLikeToArray$2(a, b) { (null == b || b > a.length) && (b = a.length); for (var c = 0, d = Array(b); c < b; c++)
      d[c] = a[c]; return d; }
  var BatchUploader = /*#__PURE__*/ function () {
      function a(b, c) { var d = this; classCallCheck(this, a), defineProperty(this, "uploadIntervalMillis", void 0), defineProperty(this, "pendingEvents", void 0), defineProperty(this, "pendingUploads", void 0), defineProperty(this, "mpInstance", void 0), defineProperty(this, "uploadUrl", void 0), defineProperty(this, "batchingEnabled", void 0), this.mpInstance = b, this.uploadIntervalMillis = c, this.batchingEnabled = c >= a.MINIMUM_INTERVAL_MILLIS, this.uploadIntervalMillis < a.MINIMUM_INTERVAL_MILLIS && (this.uploadIntervalMillis = a.MINIMUM_INTERVAL_MILLIS), this.pendingEvents = [], this.pendingUploads = []; var e = this.mpInstance._Store, f = e.SDKConfig, g = e.devToken, h = this.mpInstance._Helpers.createServiceUrl(f.v3SecureServiceUrl, g); this.uploadUrl = "".concat(h, "/events"), setTimeout(function () { d.prepareAndUpload(!0, !1); }, this.uploadIntervalMillis), this.addEventListeners(); }
      return createClass(a, [{ key: "addEventListeners", value: function addEventListeners() { var a = this; window.onbeforeunload = function () { a.prepareAndUpload(!1, a.isBeaconAvailable()); }, window.onpagehide = function () { a.prepareAndUpload(!1, a.isBeaconAvailable()); }; } }, { key: "isBeaconAvailable", value: function isBeaconAvailable() { return !!navigator.sendBeacon; } }, { key: "queueEvent", value: function queueEvent(a) { a && (a.IsFirstRun = this.mpInstance._Store.isFirstRun, this.pendingEvents.push(a), this.mpInstance.Logger.verbose("Queuing event: ".concat(JSON.stringify(a))), this.mpInstance.Logger.verbose("Queued event count: ".concat(this.pendingEvents.length)), (!this.batchingEnabled || Types.TriggerUploadType[a.EventDataType]) && this.prepareAndUpload(!1, !1)); } /**
                   * This implements crucial logic to:
                   * - bucket pending events by MPID, and then by Session, and upload individual batches for each bucket.
                   *
                   * In the future this should enforce other requirements such as maximum batch size.
                   *
                   * @param sdkEvents current pending events
                   * @param defaultUser the user to reference for events that are missing data
                   */
          }, { key: "prepareAndUpload", /**
              * This is the main loop function:
              *  - take all pending events and turn them into batches
              *  - attempt to upload each batch
              *
              * @param triggerFuture whether to trigger the loop again - for manual/forced uploads this should be false
              * @param useBeacon whether to use the beacon API - used when the page is being unloaded
              */ value: function () { var b = asyncToGenerator(/*#__PURE__*/ regenerator.mark(function b(c, d) { var e, f, g, h, i, j, k, l = this; return regenerator.wrap(function (b) { for (;;)
                  switch (b.prev = b.next) {
                      case 0: return e = this.mpInstance.Identity.getCurrentUser(), f = this.pendingEvents, this.pendingEvents = [], g = a.createNewUploads(f, e, this.mpInstance), g && g.length && (h = this.pendingUploads).push.apply(h, toConsumableArray(g)), i = this.pendingUploads, this.pendingUploads = [], b.next = 9, this.upload(this.mpInstance.Logger, i, d);
                      case 9: j = b.sent, j && j.length && (k = this.pendingUploads).unshift.apply(k, toConsumableArray(j)), c && setTimeout(function () { l.prepareAndUpload(!0, !1); }, this.uploadIntervalMillis);
                      case 12:
                      case "end": return b.stop();
                  } }, b, this); })); return function prepareAndUpload() { return b.apply(this, arguments); }; }() }, { key: "upload", value: function () { var b = asyncToGenerator(/*#__PURE__*/ regenerator.mark(function b(c, d, e) { var f, g, h, j, k; return regenerator.wrap(function (b) { for (;;)
                  switch (b.prev = b.next) {
                      case 0:
                          if (d && !(1 > d.length)) {
                              b.next = 2;
                              break;
                          }
                          return b.abrupt("return", null);
                      case 2: c.verbose("Uploading batches: ".concat(JSON.stringify(d))), c.verbose("Batch count: ".concat(d.length)), g = 0;
                      case 5:
                          if (!(g < d.length)) {
                              b.next = 38;
                              break;
                          }
                          if (h = { method: "POST", headers: { Accept: a.CONTENT_TYPE, "Content-Type": "text/plain;charset=UTF-8" }, body: JSON.stringify(d[g]) }, !(e && this.isBeaconAvailable())) {
                              b.next = 12;
                              break;
                          }
                          j = new Blob([h.body], { type: "text/plain;charset=UTF-8" }), navigator.sendBeacon(this.uploadUrl, j), b.next = 35;
                          break;
                      case 12: return f || (window.fetch ? f = new FetchUploader(this.uploadUrl, c) : f = new XHRUploader(this.uploadUrl, c)), b.prev = 13, b.next = 16, f.upload(h, d, g);
                      case 16:
                          if (k = b.sent, !(200 <= k.status && 300 > k.status)) {
                              b.next = 21;
                              break;
                          }
                          c.verbose("Upload success for request ID: ".concat(d[g].source_request_id)), b.next = 29;
                          break;
                      case 21:
                          if (!(500 <= k.status || 429 === k.status)) {
                              b.next = 26;
                              break;
                          }
                          return c.error("HTTP error status ".concat(k.status, " received")), b.abrupt("return", d.slice(g, d.length));
                      case 26:
                          if (!(401 <= k.status)) {
                              b.next = 29;
                              break;
                          }
                          return c.error("HTTP error status ".concat(k.status, " while uploading - please verify your API key.")), b.abrupt("return", null);
                      case 29:
                          b.next = 35;
                          break;
                      case 31: return b.prev = 31, b.t0 = b["catch"](13), c.error("Error sending event to mParticle servers. ".concat(b.t0)), b.abrupt("return", d.slice(g, d.length));
                      case 35:
                          g++, b.next = 5;
                          break;
                      case 38: return b.abrupt("return", null);
                      case 39:
                      case "end": return b.stop();
                  } }, b, this, [[13, 31]]); })); return function upload() { return b.apply(this, arguments); }; }() }], [{ key: "createNewUploads", value: function createNewUploads(a, b, c) {
                  if (!b || !a || !a.length)
                      return null; //bucket by MPID, and then by session, ordered by timestamp
                  var d, e = [], f = new Map, g = _createForOfIteratorHelper$1(a);
                  try {
                      for (g.s(); !(d = g.n()).done;) {
                          var v = d.value; //on initial startup, there may be events logged without an mpid.
                          if (!v.MPID) {
                              var w = b.getMPID();
                              v.MPID = w;
                          }
                          var x = f.get(v.MPID);
                          x || (x = []), x.push(v), f.set(v.MPID, x);
                      }
                  }
                  catch (a) {
                      g.e(a);
                  }
                  finally {
                      g.f();
                  }
                  for (var h = 0, i = Array.from(f.entries()); h < i.length; h++) {
                      var j, k = i[h], l = k[0], m = k[1], n = new Map, o = _createForOfIteratorHelper$1(m);
                      try {
                          for (o.s(); !(j = o.n()).done;) {
                              var p = j.value, q = n.get(p.SessionId);
                              q || (q = []), q.push(p), n.set(p.SessionId, q);
                          }
                      }
                      catch (a) {
                          o.e(a);
                      }
                      finally {
                          o.f();
                      }
                      for (var r = 0, s = Array.from(n.entries()); r < s.length; r++) {
                          var t = s[r], u = convertEvents(l, t[1], c);
                          u && e.push(u);
                      }
                  }
                  return e;
              } }]), a;
  }();
  defineProperty(BatchUploader, "CONTENT_TYPE", "text/plain;charset=UTF-8"), defineProperty(BatchUploader, "MINIMUM_INTERVAL_MILLIS", 500);
  var AsyncUploader = function a(b, c) { classCallCheck(this, a), defineProperty(this, "url", void 0), defineProperty(this, "logger", void 0), this.url = b, this.logger = c; }, FetchUploader = /*#__PURE__*/ function (a) { function b() { return classCallCheck(this, b), c.apply(this, arguments); } inherits(b, a); var c = _createSuper(b); return createClass(b, [{ key: "upload", value: function () { var a = asyncToGenerator(/*#__PURE__*/ regenerator.mark(function a(b) { var c; return regenerator.wrap(function (a) { for (;;)
              switch (a.prev = a.next) {
                  case 0: return a.next = 2, fetch(this.url, b);
                  case 2: return c = a.sent, a.abrupt("return", c);
                  case 4:
                  case "end": return a.stop();
              } }, a, this); })); return function upload() { return a.apply(this, arguments); }; }() }]), b; }(AsyncUploader), XHRUploader = /*#__PURE__*/ function (a) { function b() { return classCallCheck(this, b), c.apply(this, arguments); } inherits(b, a); var c = _createSuper(b); return createClass(b, [{ key: "upload", value: function () { var a = asyncToGenerator(/*#__PURE__*/ regenerator.mark(function a(b) { var c; return regenerator.wrap(function (a) { for (;;)
              switch (a.prev = a.next) {
                  case 0: return a.next = 2, this.makeRequest(this.url, this.logger, b.body);
                  case 2: return c = a.sent, a.abrupt("return", c);
                  case 4:
                  case "end": return a.stop();
              } }, a, this); })); return function upload() { return a.apply(this, arguments); }; }() }, { key: "makeRequest", value: function () { var a = asyncToGenerator(/*#__PURE__*/ regenerator.mark(function a(b, c, d) { var e; return regenerator.wrap(function (a) { for (;;)
              switch (a.prev = a.next) {
                  case 0: return e = new XMLHttpRequest, a.abrupt("return", new Promise(function (a, c) { e.onreadystatechange = function () { 4 !== e.readyState || (200 <= e.status && 300 > e.status ? a(e) : c(e)); }, e.open("post", b), e.send(d); }));
                  case 2:
                  case "end": return a.stop();
              } }, a); })); return function makeRequest() { return a.apply(this, arguments); }; }() }]), b; }(AsyncUploader);

  var Messages=Constants.Messages;function APIClient(a,b){this.uploader=null;var c=this;this.queueEventForBatchUpload=function(b){if(!this.uploader){var c=a._Helpers.getFeatureFlag(Constants.FeatureFlags.EventBatchingIntervalMillis);this.uploader=new BatchUploader(a,c);}this.uploader.queueEvent(b);},this.shouldEnableBatching=function(){// Returns a string of a number that must be parsed
  // Invalid strings will be parsed to NaN which is falsey
  var b=parseInt(a._Helpers.getFeatureFlag(Constants.FeatureFlags.EventsV3),10);if(!b)return !1;var c=a._Helpers.getRampNumber(a._Store.deviceId);return b>=c},this.processQueuedEvents=function(){var b,d=a.Identity.getCurrentUser();if(d&&(b=d.getMPID()),a._Store.eventQueue.length&&b){var e=a._Store.eventQueue;a._Store.eventQueue=[],this.appendUserInfoToEvents(d,e),e.forEach(function(a){c.sendEventToServer(a);});}},this.appendUserInfoToEvents=function(b,c){c.forEach(function(c){c.MPID||a._ServerModel.appendUserInfo(b,c);});},this.sendEventToServer=function(c){if(a._Store.webviewBridgeEnabled)return void a._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.LogEvent,JSON.stringify(c));var d,e=a.Identity.getCurrentUser();// We queue events if there is no MPID (MPID is null, or === 0), or there are integrations that that require this to stall because integration attributes
  // need to be set, or if we are still fetching the config (self hosted only), and so require delaying events
  return e&&(d=e.getMPID()),a._Store.requireDelay=a._Helpers.isDelayedByIntegration(a._preInit.integrationDelays,a._Store.integrationDelayTimeoutStart,Date.now()),d&&!a._Store.requireDelay&&a._Store.configurationLoaded?void(this.processQueuedEvents(),this.shouldEnableBatching()?this.queueEventForBatchUpload(c):this.sendSingleEventToServer(c),c&&c.EventName!==Types.MessageType.AppStateTransition&&(b&&b.kitBlockingEnabled&&(c=b.createBlockedEvent(c)),c&&a._Forwarders.sendEventToForwarders(c))):(a.Logger.verbose("Event was added to eventQueue. eventQueue will be processed once a valid MPID is returned or there is no more integration imposed delay."),void a._Store.eventQueue.push(c))},this.sendSingleEventToServer=function(b){if(b.EventDataType!==Types.MessageType.Media){var c,d=function(){4===c.readyState&&(a.Logger.verbose("Received "+c.statusText+" from server"),a._Persistence.update());};if(!b)return void a.Logger.error(Messages.ErrorMessages.EventEmpty);if(a.Logger.verbose(Messages.InformationMessages.SendHttp),c=a._Helpers.createXHR(d),c)try{c.open("post",a._Helpers.createServiceUrl(a._Store.SDKConfig.v2SecureServiceUrl,a._Store.devToken)+"/Events"),c.send(JSON.stringify(a._ServerModel.convertEventToDTO(b,a._Store.isFirstRun)));}catch(b){a.Logger.error("Error sending event to mParticle servers. "+b);}}},this.sendBatchForwardingStatsToServer=function(b,c){var d,e;try{d=a._Helpers.createServiceUrl(a._Store.SDKConfig.v2SecureServiceUrl,a._Store.devToken),e={uuid:a._Helpers.generateUniqueId(),data:b},c&&(c.open("post",d+"/Forwarding"),c.send(JSON.stringify(e)));}catch(b){a.Logger.error("Error sending forwarding stats to mParticle servers.");}},this.sendSingleForwardingStatsToServer=function(b){var c,d;try{var e=function(){4===f.readyState&&202===f.status&&a.Logger.verbose("Successfully sent  "+f.statusText+" from server");},f=a._Helpers.createXHR(e);c=a._Helpers.createServiceUrl(a._Store.SDKConfig.v1SecureServiceUrl,a._Store.devToken),d=b,f&&(f.open("post",c+"/Forwarding"),f.send(JSON.stringify(d)));}catch(b){a.Logger.error("Error sending forwarding stats to mParticle servers.");}},this.prepareForwardingStats=function(b,d){var e,f=a._Forwarders.getForwarderStatsQueue();b&&b.isVisible&&(e={mid:b.id,esid:b.eventSubscriptionId,n:d.EventName,attrs:d.EventAttributes,sdk:d.SDKVersion,dt:d.EventDataType,et:d.EventCategory,dbg:d.Debug,ct:d.Timestamp,eec:d.ExpandedEventCount,dp:d.DataPlan},a._Helpers.getFeatureFlag(Constants.FeatureFlags.ReportBatching)?(f.push(e),a._Forwarders.setForwarderStatsQueue(f)):c.sendSingleForwardingStatsToServer(e));};}

  var slugify = createCommonjsModule(function (module, exports) {
  (function (name, root, factory) {
    {
      module.exports = factory();
      module.exports['default'] = factory();
    }
  }('slugify', commonjsGlobal$1, function () {
    var charMap = JSON.parse('{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","¢":"cent","£":"pound","¤":"currency","¥":"yen","©":"(c)","ª":"a","®":"(r)","º":"o","À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","Æ":"AE","Ç":"C","È":"E","É":"E","Ê":"E","Ë":"E","Ì":"I","Í":"I","Î":"I","Ï":"I","Ð":"D","Ñ":"N","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","Ù":"U","Ú":"U","Û":"U","Ü":"U","Ý":"Y","Þ":"TH","ß":"ss","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","æ":"ae","ç":"c","è":"e","é":"e","ê":"e","ë":"e","ì":"i","í":"i","î":"i","ï":"i","ð":"d","ñ":"n","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","ù":"u","ú":"u","û":"u","ü":"u","ý":"y","þ":"th","ÿ":"y","Ā":"A","ā":"a","Ă":"A","ă":"a","Ą":"A","ą":"a","Ć":"C","ć":"c","Č":"C","č":"c","Ď":"D","ď":"d","Đ":"DJ","đ":"dj","Ē":"E","ē":"e","Ė":"E","ė":"e","Ę":"e","ę":"e","Ě":"E","ě":"e","Ğ":"G","ğ":"g","Ģ":"G","ģ":"g","Ĩ":"I","ĩ":"i","Ī":"i","ī":"i","Į":"I","į":"i","İ":"I","ı":"i","Ķ":"k","ķ":"k","Ļ":"L","ļ":"l","Ľ":"L","ľ":"l","Ł":"L","ł":"l","Ń":"N","ń":"n","Ņ":"N","ņ":"n","Ň":"N","ň":"n","Ő":"O","ő":"o","Œ":"OE","œ":"oe","Ŕ":"R","ŕ":"r","Ř":"R","ř":"r","Ś":"S","ś":"s","Ş":"S","ş":"s","Š":"S","š":"s","Ţ":"T","ţ":"t","Ť":"T","ť":"t","Ũ":"U","ũ":"u","Ū":"u","ū":"u","Ů":"U","ů":"u","Ű":"U","ű":"u","Ų":"U","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","ź":"z","Ż":"Z","ż":"z","Ž":"Z","ž":"z","ƒ":"f","Ơ":"O","ơ":"o","Ư":"U","ư":"u","ǈ":"LJ","ǉ":"lj","ǋ":"NJ","ǌ":"nj","Ș":"S","ș":"s","Ț":"T","ț":"t","˚":"o","Ά":"A","Έ":"E","Ή":"H","Ί":"I","Ό":"O","Ύ":"Y","Ώ":"W","ΐ":"i","Α":"A","Β":"B","Γ":"G","Δ":"D","Ε":"E","Ζ":"Z","Η":"H","Θ":"8","Ι":"I","Κ":"K","Λ":"L","Μ":"M","Ν":"N","Ξ":"3","Ο":"O","Π":"P","Ρ":"R","Σ":"S","Τ":"T","Υ":"Y","Φ":"F","Χ":"X","Ψ":"PS","Ω":"W","Ϊ":"I","Ϋ":"Y","ά":"a","έ":"e","ή":"h","ί":"i","ΰ":"y","α":"a","β":"b","γ":"g","δ":"d","ε":"e","ζ":"z","η":"h","θ":"8","ι":"i","κ":"k","λ":"l","μ":"m","ν":"n","ξ":"3","ο":"o","π":"p","ρ":"r","ς":"s","σ":"s","τ":"t","υ":"y","φ":"f","χ":"x","ψ":"ps","ω":"w","ϊ":"i","ϋ":"y","ό":"o","ύ":"y","ώ":"w","Ё":"Yo","Ђ":"DJ","Є":"Ye","І":"I","Ї":"Yi","Ј":"J","Љ":"LJ","Њ":"NJ","Ћ":"C","Џ":"DZ","А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ж":"Zh","З":"Z","И":"I","Й":"J","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"H","Ц":"C","Ч":"Ch","Ш":"Sh","Щ":"Sh","Ъ":"U","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"c","ч":"ch","ш":"sh","щ":"sh","ъ":"u","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","ё":"yo","ђ":"dj","є":"ye","і":"i","ї":"yi","ј":"j","љ":"lj","њ":"nj","ћ":"c","ѝ":"u","џ":"dz","Ґ":"G","ґ":"g","Ғ":"GH","ғ":"gh","Қ":"KH","қ":"kh","Ң":"NG","ң":"ng","Ү":"UE","ү":"ue","Ұ":"U","ұ":"u","Һ":"H","һ":"h","Ә":"AE","ә":"ae","Ө":"OE","ө":"oe","฿":"baht","ა":"a","ბ":"b","გ":"g","დ":"d","ე":"e","ვ":"v","ზ":"z","თ":"t","ი":"i","კ":"k","ლ":"l","მ":"m","ნ":"n","ო":"o","პ":"p","ჟ":"zh","რ":"r","ს":"s","ტ":"t","უ":"u","ფ":"f","ქ":"k","ღ":"gh","ყ":"q","შ":"sh","ჩ":"ch","ც":"ts","ძ":"dz","წ":"ts","ჭ":"ch","ხ":"kh","ჯ":"j","ჰ":"h","Ẁ":"W","ẁ":"w","Ẃ":"W","ẃ":"w","Ẅ":"W","ẅ":"w","ẞ":"SS","Ạ":"A","ạ":"a","Ả":"A","ả":"a","Ấ":"A","ấ":"a","Ầ":"A","ầ":"a","Ẩ":"A","ẩ":"a","Ẫ":"A","ẫ":"a","Ậ":"A","ậ":"a","Ắ":"A","ắ":"a","Ằ":"A","ằ":"a","Ẳ":"A","ẳ":"a","Ẵ":"A","ẵ":"a","Ặ":"A","ặ":"a","Ẹ":"E","ẹ":"e","Ẻ":"E","ẻ":"e","Ẽ":"E","ẽ":"e","Ế":"E","ế":"e","Ề":"E","ề":"e","Ể":"E","ể":"e","Ễ":"E","ễ":"e","Ệ":"E","ệ":"e","Ỉ":"I","ỉ":"i","Ị":"I","ị":"i","Ọ":"O","ọ":"o","Ỏ":"O","ỏ":"o","Ố":"O","ố":"o","Ồ":"O","ồ":"o","Ổ":"O","ổ":"o","Ỗ":"O","ỗ":"o","Ộ":"O","ộ":"o","Ớ":"O","ớ":"o","Ờ":"O","ờ":"o","Ở":"O","ở":"o","Ỡ":"O","ỡ":"o","Ợ":"O","ợ":"o","Ụ":"U","ụ":"u","Ủ":"U","ủ":"u","Ứ":"U","ứ":"u","Ừ":"U","ừ":"u","Ử":"U","ử":"u","Ữ":"U","ữ":"u","Ự":"U","ự":"u","Ỳ":"Y","ỳ":"y","Ỵ":"Y","ỵ":"y","Ỷ":"Y","ỷ":"y","Ỹ":"Y","ỹ":"y","‘":"\'","’":"\'","“":"\\\"","”":"\\\"","†":"+","•":"*","…":"...","₠":"ecu","₢":"cruzeiro","₣":"french franc","₤":"lira","₥":"mill","₦":"naira","₧":"peseta","₨":"rupee","₩":"won","₪":"new shequel","₫":"dong","€":"euro","₭":"kip","₮":"tugrik","₯":"drachma","₰":"penny","₱":"peso","₲":"guarani","₳":"austral","₴":"hryvnia","₵":"cedi","₸":"kazakhstani tenge","₹":"indian rupee","₽":"russian ruble","₿":"bitcoin","℠":"sm","™":"tm","∂":"d","∆":"delta","∑":"sum","∞":"infinity","♥":"love","元":"yuan","円":"yen","﷼":"rial"}');
    var locales = JSON.parse('{"vi":{"Đ":"D","đ":"d"}}');

    function replace (string, options) {
      if (typeof string !== 'string') {
        throw new Error('slugify: string argument expected')
      }

      options = (typeof options === 'string')
        ? {replacement: options}
        : options || {};

      var locale = locales[options.locale] || {};

      var replacement = options.replacement || '-';

      var slug = string.split('')
        // replace characters based on charMap
        .reduce(function (result, ch) {
          return result + (locale[ch] || charMap[ch] || ch)
        }, '')
        // remove not allowed characters
        .replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, '')
        // trim leading/trailing spaces
        .trim()
        // convert spaces to replacement character
        // also remove duplicates of the replacement character
        .replace(new RegExp('[\\s' + replacement + ']+', 'g'), replacement);

      if (options.lower) {
        slug = slug.toLowerCase();
      }

      if (options.strict) {
        // remove anything besides letters, numbers, and the replacement char
        slug = slug
          .replace(new RegExp('[^a-zA-Z0-9' + replacement + ']', 'g'), '');
      }

      return slug
    }

    replace.extend = function (customMap) {
      for (var key in customMap) {
        charMap[key] = customMap[key];
      }
    };

    return replace
  }));
  });

  var StorageNames=Constants.StorageNames,pluses=/\+/g;function Helpers(a){function b(b){var a;return window.crypto&&window.crypto.getRandomValues&&(a=window.crypto.getRandomValues(new Uint8Array(1))),a?(b^a[0]%16>>b/4).toString(16):(b^16*Math.random()>>b/4).toString(16)}var c=this;/**
       * Returns a value between 1-100 inclusive.
       */ // Standalone version of jQuery.extend, from https://github.com/dansdom/extend
  this.canLog=function(){return !!(a._Store.isEnabled&&(a._Store.devToken||a._Store.webviewBridgeEnabled))},this.returnConvertedBoolean=function(a){return "false"!==a&&"0"!==a&&!!a},this.getFeatureFlag=function(b){return a._Store.SDKConfig.flags.hasOwnProperty(b)?a._Store.SDKConfig.flags[b]:null},this.getRampNumber=function(a){if(!a)return 100;var b=c.generateHash(a);return Math.abs(b%100)+1},this.invokeCallback=function(b,d,e,f,g){b||a.Logger.warning("There is no callback provided");try{c.Validators.isFunction(b)&&b({httpCode:d,body:e,getUser:function getUser(){return f?f:a.Identity.getCurrentUser()},getPreviousUser:function getPreviousUser(){if(!g){var b=a.Identity.getUsers(),c=b.shift(),d=f||a.Identity.getCurrentUser();return c&&d&&c.getMPID()===d.getMPID()&&(c=b.shift()),c||null}return a.Identity.getUser(g)}});}catch(b){a.Logger.error("There was an error with your callback: "+b);}},this.invokeAliasCallback=function(b,d,e){b||a.Logger.warning("There is no callback provided");try{if(c.Validators.isFunction(b)){var f={httpCode:d};e&&(f.message=e),b(f);}}catch(b){a.Logger.error("There was an error with your callback: "+b);}},this.extend=function(){var a,b,d,e,f,g,h=arguments[0]||{},j=1,k=arguments.length,l=!1,// helper which replicates the jquery internal functions
  m={hasOwn:Object.prototype.hasOwnProperty,class2type:{},type:function type(a){return null==a?a+"":m.class2type[Object.prototype.toString.call(a)]||"object"},isPlainObject:function isPlainObject(a){if(!a||"object"!==m.type(a)||a.nodeType||m.isWindow(a))return !1;try{if(a.constructor&&!m.hasOwn.call(a,"constructor")&&!m.hasOwn.call(a.constructor.prototype,"isPrototypeOf"))return !1}catch(a){return !1}for(var b in a);// eslint-disable-line no-empty
  return b===void 0||m.hasOwn.call(a,b)},isArray:Array.isArray||function(a){return "array"===m.type(a)},isFunction:function isFunction(a){return "function"===m.type(a)},isWindow:function isWindow(a){return null!=a&&a==a.window}};// end of objectHelper
  // Handle a deep copy situation
  for("boolean"==typeof h&&(l=h,h=arguments[1]||{},j=2),"object"===_typeof_1(h)||m.isFunction(h)||(h={}),k===j&&(h=this,--j);j<k;j++)// Only deal with non-null/undefined values
  if(null!=(a=arguments[j]))// Extend the base object
  for(b in a)// Prevent never-ending loop
  (d=h[b],e=a[b],h!==e)&&(l&&e&&(m.isPlainObject(e)||(f=m.isArray(e)))?(f?(f=!1,g=d&&m.isArray(d)?d:[]):g=d&&m.isPlainObject(d)?d:{},h[b]=c.extend(l,g,e)):void 0!==e&&(h[b]=e));// Recurse if we're merging plain objects or arrays
  // Return the modified object
  return h},this.isObject=function(a){var b=Object.prototype.toString.call(a);return "[object Object]"===b||"[object Error]"===b},this.inArray=function(a,b){var c=0;if(Array.prototype.indexOf)return 0<=a.indexOf(b,0);for(var d=a.length;c<d;c++)if(c in a&&a[c]===b)return !0},this.createServiceUrl=function(b,c){var d,e=window.mParticle&&a._Store.SDKConfig.forceHttps?"https://":window.location.protocol+"//";return d=a._Store.SDKConfig.forceHttps?"https://"+b:e+b,c&&(d+=c),d},this.createXHR=function(b){var c;try{c=new window.XMLHttpRequest;}catch(b){a.Logger.error("Error creating XMLHttpRequest object.");}if(c&&b&&"withCredentials"in c)c.onreadystatechange=b;else if("undefined"!=typeof window.XDomainRequest){a.Logger.verbose("Creating XDomainRequest object");try{c=new window.XDomainRequest,c.onload=b;}catch(b){a.Logger.error("Error creating XDomainRequest object");}}return c},this.generateUniqueId=function(d){// https://gist.github.com/jed/982883
  // Added support for crypto for better random
  return d// if the placeholder was passed, return
  ?b(d)// a random number
  :// or otherwise a concatenated string:
  "10000000-1000-4000-8000-100000000000".// -100000000000,
  replace(// replacing
  /[018]/g,// zeroes, ones, and eights with
  c.generateUniqueId// random hex digits
  )},this.filterUserIdentities=function(a,b){var d=[];if(a&&Object.keys(a).length)for(var e in a)if(a.hasOwnProperty(e)){var f=Types.IdentityType.getIdentityType(e);if(!c.inArray(b,f)){var g={Type:f,Identity:a[e]};f===Types.IdentityType.CustomerId?d.unshift(g):d.push(g);}}return d},this.filterUserIdentitiesForForwarders=function(a,b){var d={};if(a&&Object.keys(a).length)for(var e in a)if(a.hasOwnProperty(e)){var f=Types.IdentityType.getIdentityType(e);c.inArray(b,f)||(d[e]=a[e]);}return d},this.filterUserAttributes=function(a,b){var d={};if(a&&Object.keys(a).length)for(var e in a)if(a.hasOwnProperty(e)){var f=c.generateHash(e);c.inArray(b,f)||(d[e]=a[e]);}return d},this.findKeyInObject=function(a,b){if(b&&a)for(var c in a)if(a.hasOwnProperty(c)&&c.toLowerCase()===b.toLowerCase())return c;return null},this.decoded=function(a){return decodeURIComponent(a.replace(pluses," "))},this.converted=function(a){return 0===a.indexOf("\"")&&(a=a.slice(1,-1).replace(/\\"/g,"\"").replace(/\\\\/g,"\\")),a},this.isEventType=function(a){for(var b in Types.EventType)if(Types.EventType.hasOwnProperty(b)&&Types.EventType[b]===a)return !0;return !1},this.parseNumber=function(a){if(isNaN(a)||!isFinite(a))return 0;var b=parseFloat(a);return isNaN(b)?0:b},this.parseStringOrNumber=function(a){return c.Validators.isStringOrNumber(a)?a:null},this.generateHash=function(a){var b,c=0,d=0;if(void 0===a||null===a)return 0;if(a=a.toString().toLowerCase(),Array.prototype.reduce)return a.split("").reduce(function(c,d){return c=(c<<5)-c+d.charCodeAt(0),c&c},0);if(0===a.length)return c;for(d=0;d<a.length;d++)b=a.charCodeAt(d),c=(c<<5)-c+b,c&=c;return c},this.sanitizeAttributes=function(b,d){if(!b||!c.isObject(b))return null;var e={};for(var f in b)// Make sure that attribute values are not objects or arrays, which are not valid
  b.hasOwnProperty(f)&&c.Validators.isValidAttributeValue(b[f])?e[f]=b[f]:a.Logger.warning("For '"+d+"', the corresponding attribute value of '"+f+"' must be a string, number, boolean, or null.");return e},this.Validators={isValidAttributeValue:function isValidAttributeValue(a){return a!==void 0&&!c.isObject(a)&&!Array.isArray(a)},// Neither null nor undefined can be a valid Key
  isValidKeyValue:function isValidKeyValue(a){return !(!a||c.isObject(a)||Array.isArray(a))},isStringOrNumber:function isStringOrNumber(a){return "string"==typeof a||"number"==typeof a},isNumber:function isNumber(a){return "number"==typeof a},isFunction:function isFunction(a){return "function"==typeof a},validateIdentities:function validateIdentities(b,d){var e={userIdentities:1,onUserAlias:1,copyUserAttributes:1};if(b){if("modify"===d&&(c.isObject(b.userIdentities)&&!Object.keys(b.userIdentities).length||!c.isObject(b.userIdentities)))return {valid:!1,error:Constants.Messages.ValidationMessages.ModifyIdentityRequestUserIdentitiesPresent};for(var f in b)if(b.hasOwnProperty(f)){if(!e[f])return {valid:!1,error:Constants.Messages.ValidationMessages.IdentityRequesetInvalidKey};if("onUserAlias"===f&&!a._Helpers.Validators.isFunction(b[f]))return {valid:!1,error:Constants.Messages.ValidationMessages.OnUserAliasType+_typeof_1(b[f])}}if(0===Object.keys(b).length)return {valid:!0};// identityApiData.userIdentities can't be undefined
  if(void 0===b.userIdentities)return {valid:!1,error:Constants.Messages.ValidationMessages.UserIdentities};// identityApiData.userIdentities can be null, but if it isn't null or undefined (above conditional), it must be an object
  if(null!==b.userIdentities&&!c.isObject(b.userIdentities))return {valid:!1,error:Constants.Messages.ValidationMessages.UserIdentities};if(c.isObject(b.userIdentities)&&Object.keys(b.userIdentities).length)for(var g in b.userIdentities)if(b.userIdentities.hasOwnProperty(g)){if(!1===Types.IdentityType.getIdentityType(g))return {valid:!1,error:Constants.Messages.ValidationMessages.UserIdentitiesInvalidKey};if("string"!=typeof b.userIdentities[g]&&null!==b.userIdentities[g])return {valid:!1,error:Constants.Messages.ValidationMessages.UserIdentitiesInvalidValues}}}return {valid:!0}}},this.isDelayedByIntegration=function(b,c,d){if(d-c>a._Store.SDKConfig.integrationDelayTimeout)return !1;for(var e in b){if(!0===b[e])return !0;continue}return !1},this.createMainStorageName=function(a){return a?StorageNames.currentStorageName+"_"+a:StorageNames.currentStorageName},this.createProductStorageName=function(a){return a?StorageNames.currentStorageProductsName+"_"+a:StorageNames.currentStorageProductsName},this.isSlug=function(a){return a===slugify(a)};}

  var Messages$1=Constants.Messages,androidBridgeNameBase="mParticleAndroid",iosBridgeNameBase="mParticle";function NativeSdkHelpers(a){var b=this;this.isBridgeV2Available=function(a){if(!a)return !1;var b=iosBridgeNameBase+"_"+a+"_v2";// iOS v2 bridge
  return !!(window.webkit&&window.webkit.messageHandlers&&window.webkit.messageHandlers.hasOwnProperty(b))||!!(window.mParticle&&window.mParticle.uiwebviewBridgeName&&window.mParticle.uiwebviewBridgeName===b)||!!window.hasOwnProperty(androidBridgeNameBase+"_"+a+"_v2");// other iOS v2 bridge
  // TODO: what to do about people setting things on mParticle itself?
  // android
  },this.isWebviewEnabled=function(c,d){return a._Store.bridgeV2Available=b.isBridgeV2Available(c),a._Store.bridgeV1Available=b.isBridgeV1Available(),2===d?a._Store.bridgeV2Available:!(window.mParticle&&window.mParticle.uiwebviewBridgeName&&window.mParticle.uiwebviewBridgeName!==iosBridgeNameBase+"_"+c+"_v2")&&!!(2>d)&&(a._Store.bridgeV2Available||a._Store.bridgeV1Available);// iOS BridgeV1 can be available via mParticle.isIOS, but return false if uiwebviewBridgeName doesn't match requiredWebviewBridgeName
  },this.isBridgeV1Available=function(){return !!(a._Store.SDKConfig.useNativeSdk||window.mParticleAndroid||a._Store.SDKConfig.isIOS)},this.sendToNative=function(c,d){return a._Store.bridgeV2Available&&2===a._Store.SDKConfig.minWebviewBridgeVersion?void b.sendViaBridgeV2(c,d,a._Store.SDKConfig.requiredWebviewBridgeName):a._Store.bridgeV2Available&&2>a._Store.SDKConfig.minWebviewBridgeVersion?void b.sendViaBridgeV2(c,d,a._Store.SDKConfig.requiredWebviewBridgeName):a._Store.bridgeV1Available&&2>a._Store.SDKConfig.minWebviewBridgeVersion?void b.sendViaBridgeV1(c,d):void 0},this.sendViaBridgeV1=function(c,d){window.mParticleAndroid&&window.mParticleAndroid.hasOwnProperty(c)?(a.Logger.verbose(Messages$1.InformationMessages.SendAndroid+c),window.mParticleAndroid[c](d)):a._Store.SDKConfig.isIOS&&(a.Logger.verbose(Messages$1.InformationMessages.SendIOS+c),b.sendViaIframeToIOS(c,d));},this.sendViaIframeToIOS=function(a,b){var c=document.createElement("IFRAME");c.setAttribute("src","mp-sdk://"+a+"/"+encodeURIComponent(b)),document.documentElement.appendChild(c),c.parentNode.removeChild(c);},this.sendViaBridgeV2=function(c,d,e){if(e){var f,g,h=window[androidBridgeNameBase+"_"+e+"_v2"],i=iosBridgeNameBase+"_"+e+"_v2";return window.webkit&&window.webkit.messageHandlers&&window.webkit.messageHandlers[i]&&(f=window.webkit.messageHandlers[i]),a.uiwebviewBridgeName===i&&(g=a[i]),h&&h.hasOwnProperty(c)?(a.Logger.verbose(Messages$1.InformationMessages.SendAndroid+c),void h[c](d)):void(f?(a.Logger.verbose(Messages$1.InformationMessages.SendIOS+c),f.postMessage(JSON.stringify({path:c,value:d?JSON.parse(d):null}))):g&&(a.Logger.verbose(Messages$1.InformationMessages.SendIOS+c),b.sendViaIframeToIOS(c,d)))}};}

  var Messages$2=Constants.Messages;function cookieSyncManager(a){var b=this;this.attemptCookieSync=function(c,d){var e,f,g,h,i;d&&!a._Store.webviewBridgeEnabled&&a._Store.pixelConfigurations.forEach(function(j){e={moduleId:j.moduleId,frequencyCap:j.frequencyCap,pixelUrl:b.replaceAmp(j.pixelUrl),redirectUrl:j.redirectUrl?b.replaceAmp(j.redirectUrl):null},g=b.replaceMPID(e.pixelUrl,d),h=e.redirectUrl?b.replaceMPID(e.redirectUrl,d):"",i=g+encodeURIComponent(h);var k=a._Persistence.getPersistence();return c&&c!==d?void(k&&k[d]&&(!k[d].csd&&(k[d].csd={}),b.performCookieSync(i,e.moduleId,d,k[d].csd))):void(k[d]&&(!k[d].csd&&(k[d].csd={}),f=k[d].csd[e.moduleId.toString()]?k[d].csd[e.moduleId.toString()]:null,f?new Date().getTime()>new Date(f).getTime()+24*(60*(1e3*(60*e.frequencyCap)))&&b.performCookieSync(i,e.moduleId,d,k[d].csd):b.performCookieSync(i,e.moduleId,d,k[d].csd)))});},this.replaceMPID=function(a,b){return a.replace("%%mpid%%",b)},this.replaceAmp=function(a){return a.replace(/&amp;/g,"&")},this.performCookieSync=function(b,c,d,e){var f=document.createElement("img");a.Logger.verbose(Messages$2.InformationMessages.CookieSync),f.src=b,e[c.toString()]=new Date().getTime(),a._Persistence.saveUserCookieSyncDatesToPersistence(d,e);};}

  var Messages$3=Constants.Messages;function SessionManager(a){var b=this;this.initialize=function(){if(a._Store.sessionId){var c=6e4*a._Store.SDKConfig.sessionTimeout;if(new Date>new Date(a._Store.dateLastEventSent.getTime()+c))b.endSession(),b.startNewSession();else {var d=a._Persistence.getPersistence();d&&!d.cu&&(a.Identity.identify(a._Store.SDKConfig.identifyRequest,a._Store.SDKConfig.identityCallback),a._Store.identifyCalled=!0,a._Store.SDKConfig.identityCallback=null);}}else b.startNewSession();},this.getSession=function(){return a._Store.sessionId},this.startNewSession=function(){if(a.Logger.verbose(Messages$3.InformationMessages.StartingNewSession),a._Helpers.canLog()){a._Store.sessionId=a._Helpers.generateUniqueId().toUpperCase();var c=a.Identity.getCurrentUser(),d=c?c.getMPID():null;if(d&&(a._Store.currentSessionMPIDs=[d]),!a._Store.sessionStartDate){var e=new Date;a._Store.sessionStartDate=e,a._Store.dateLastEventSent=e;}b.setSessionTimer(),a._Store.identifyCalled||(a.Identity.identify(a._Store.SDKConfig.identifyRequest,a._Store.SDKConfig.identityCallback),a._Store.identifyCalled=!0,a._Store.SDKConfig.identityCallback=null),a._Events.logEvent({messageType:Types.MessageType.SessionStart});}else a.Logger.verbose(Messages$3.InformationMessages.AbandonStartSession);},this.endSession=function(c){if(a.Logger.verbose(Messages$3.InformationMessages.StartingEndSession),c)a._Events.logEvent({messageType:Types.MessageType.SessionEnd}),a._Store.sessionId=null,a._Store.dateLastEventSent=null,a._Store.sessionAttributes={},a._Persistence.update();else if(a._Helpers.canLog()){var d,e,f;if(e=a._Persistence.getPersistence(),!e)return;if(e.gs&&!e.gs.sid)return void a.Logger.verbose(Messages$3.InformationMessages.NoSessionToEnd);// sessionId is not equal to cookies.sid if cookies.sid is changed in another tab
  if(e.gs.sid&&a._Store.sessionId!==e.gs.sid&&(a._Store.sessionId=e.gs.sid),e.gs&&e.gs.les){d=6e4*a._Store.SDKConfig.sessionTimeout;var g=new Date().getTime();f=g-e.gs.les,f<d?b.setSessionTimer():(a._Events.logEvent({messageType:Types.MessageType.SessionEnd}),a._Store.sessionId=null,a._Store.dateLastEventSent=null,a._Store.sessionStartDate=null,a._Store.sessionAttributes={},a._Persistence.update());}}else a.Logger.verbose(Messages$3.InformationMessages.AbandonEndSession);},this.setSessionTimer=function(){var c=6e4*a._Store.SDKConfig.sessionTimeout;a._Store.globalTimer=window.setTimeout(function(){b.endSession();},c);},this.resetSessionTimer=function(){a._Store.webviewBridgeEnabled||(!a._Store.sessionId&&b.startNewSession(),b.clearSessionTimeout(),b.setSessionTimer()),b.startNewSessionIfNeeded();},this.clearSessionTimeout=function(){clearTimeout(a._Store.globalTimer);},this.startNewSessionIfNeeded=function(){if(!a._Store.webviewBridgeEnabled){var c=a._Persistence.getPersistence();!a._Store.sessionId&&c&&(c.sid?a._Store.sessionId=c.sid:b.startNewSession());}};}

  var Messages$4=Constants.Messages;function Ecommerce(a){var b=this;this.convertTransactionAttributesToProductAction=function(a,b){a.hasOwnProperty("Id")&&(b.TransactionId=a.Id),a.hasOwnProperty("Affiliation")&&(b.Affiliation=a.Affiliation),a.hasOwnProperty("CouponCode")&&(b.CouponCode=a.CouponCode),a.hasOwnProperty("Revenue")&&(b.TotalAmount=a.Revenue),a.hasOwnProperty("Shipping")&&(b.ShippingAmount=a.Shipping),a.hasOwnProperty("Tax")&&(b.TaxAmount=a.Tax),a.hasOwnProperty("Step")&&(b.CheckoutStep=a.Step),a.hasOwnProperty("Option")&&(b.CheckoutOptions=a.Option);},this.getProductActionEventName=function(a){switch(a){case Types.ProductActionType.AddToCart:return "AddToCart";case Types.ProductActionType.AddToWishlist:return "AddToWishlist";case Types.ProductActionType.Checkout:return "Checkout";case Types.ProductActionType.CheckoutOption:return "CheckoutOption";case Types.ProductActionType.Click:return "Click";case Types.ProductActionType.Purchase:return "Purchase";case Types.ProductActionType.Refund:return "Refund";case Types.ProductActionType.RemoveFromCart:return "RemoveFromCart";case Types.ProductActionType.RemoveFromWishlist:return "RemoveFromWishlist";case Types.ProductActionType.ViewDetail:return "ViewDetail";case Types.ProductActionType.Unknown:default:return "Unknown";}},this.getPromotionActionEventName=function(a){return a===Types.PromotionActionType.PromotionClick?"PromotionClick":a===Types.PromotionActionType.PromotionView?"PromotionView":"Unknown"},this.convertProductActionToEventType=function(b){return b===Types.ProductActionType.AddToCart?Types.CommerceEventType.ProductAddToCart:b===Types.ProductActionType.AddToWishlist?Types.CommerceEventType.ProductAddToWishlist:b===Types.ProductActionType.Checkout?Types.CommerceEventType.ProductCheckout:b===Types.ProductActionType.CheckoutOption?Types.CommerceEventType.ProductCheckoutOption:b===Types.ProductActionType.Click?Types.CommerceEventType.ProductClick:b===Types.ProductActionType.Purchase?Types.CommerceEventType.ProductPurchase:b===Types.ProductActionType.Refund?Types.CommerceEventType.ProductRefund:b===Types.ProductActionType.RemoveFromCart?Types.CommerceEventType.ProductRemoveFromCart:b===Types.ProductActionType.RemoveFromWishlist?Types.CommerceEventType.ProductRemoveFromWishlist:b===Types.ProductActionType.Unknown?Types.EventType.Unknown:b===Types.ProductActionType.ViewDetail?Types.CommerceEventType.ProductViewDetail:(a.Logger.error("Could not convert product action type "+b+" to event type"),null)},this.convertPromotionActionToEventType=function(b){return b===Types.PromotionActionType.PromotionClick?Types.CommerceEventType.PromotionClick:b===Types.PromotionActionType.PromotionView?Types.CommerceEventType.PromotionView:(a.Logger.error("Could not convert promotion action type "+b+" to event type"),null)},this.generateExpandedEcommerceName=function(a,b){return "eCommerce - "+a+" - "+(b?"Total":"Item")},this.extractProductAttributes=function(a,b){b.CouponCode&&(a["Coupon Code"]=b.CouponCode),b.Brand&&(a.Brand=b.Brand),b.Category&&(a.Category=b.Category),b.Name&&(a.Name=b.Name),b.Sku&&(a.Id=b.Sku),b.Price&&(a["Item Price"]=b.Price),b.Quantity&&(a.Quantity=b.Quantity),b.Position&&(a.Position=b.Position),b.Variant&&(a.Variant=b.Variant),a["Total Product Amount"]=b.TotalAmount||0;},this.extractTransactionId=function(a,b){b.TransactionId&&(a["Transaction Id"]=b.TransactionId);},this.extractActionAttributes=function(a,c){b.extractTransactionId(a,c),c.Affiliation&&(a.Affiliation=c.Affiliation),c.CouponCode&&(a["Coupon Code"]=c.CouponCode),c.TotalAmount&&(a["Total Amount"]=c.TotalAmount),c.ShippingAmount&&(a["Shipping Amount"]=c.ShippingAmount),c.TaxAmount&&(a["Tax Amount"]=c.TaxAmount),c.CheckoutOptions&&(a["Checkout Options"]=c.CheckoutOptions),c.CheckoutStep&&(a["Checkout Step"]=c.CheckoutStep);},this.extractPromotionAttributes=function(a,b){b.Id&&(a.Id=b.Id),b.Creative&&(a.Creative=b.Creative),b.Name&&(a.Name=b.Name),b.Position&&(a.Position=b.Position);},this.buildProductList=function(a,b){return b?Array.isArray(b)?b:[b]:a.ShoppingCart.ProductList},this.createProduct=function(b,c,d,e,f,g,h,i,j,k){return (k=a._Helpers.sanitizeAttributes(k,b),"string"!=typeof b)?(a.Logger.error("Name is required when creating a product"),null):a._Helpers.Validators.isStringOrNumber(c)?a._Helpers.Validators.isStringOrNumber(d)?(i&&!a._Helpers.Validators.isNumber(i)&&(a.Logger.error("Position must be a number, it will be set to null."),i=null),e||(e=1),{Name:b,Sku:c,Price:d,Quantity:e,Brand:h,Variant:f,Category:g,Position:i,CouponCode:j,TotalAmount:e*d,Attributes:k}):(a.Logger.error("Price is required when creating a product, and must be a string or a number"),null):(a.Logger.error("SKU is required when creating a product, and must be a string or a number"),null)},this.createPromotion=function(b,c,d,e){return a._Helpers.Validators.isStringOrNumber(b)?{Id:b,Creative:c,Name:d,Position:e}:(a.Logger.error(Messages$4.ErrorMessages.PromotionIdRequired),null)},this.createImpression=function(b,c){return "string"==typeof b?c?{Name:b,Product:c}:(a.Logger.error("Product is required when creating an impression."),null):(a.Logger.error("Name is required when creating an impression."),null)},this.createTransactionAttributes=function(b,c,d,e,f,g){return a._Helpers.Validators.isStringOrNumber(b)?{Id:b,Affiliation:c,CouponCode:d,Revenue:e,Shipping:f,Tax:g}:(a.Logger.error(Messages$4.ErrorMessages.TransactionIdRequired),null)},this.expandProductImpression=function(c){var d=[];return c.ProductImpressions?(c.ProductImpressions.forEach(function(e){e.ProductList&&e.ProductList.forEach(function(f){var g=a._Helpers.extend(!1,{},c.EventAttributes);if(f.Attributes)for(var h in f.Attributes)g[h]=f.Attributes[h];b.extractProductAttributes(g,f),e.ProductImpressionList&&(g["Product Impression List"]=e.ProductImpressionList);var i=a._ServerModel.createEventObject({messageType:Types.MessageType.PageEvent,name:b.generateExpandedEcommerceName("Impression"),data:g,eventType:Types.EventType.Transaction});d.push(i);});}),d):d},this.expandCommerceEvent=function(a){return a?b.expandProductAction(a).concat(b.expandPromotionAction(a)).concat(b.expandProductImpression(a)):null},this.expandPromotionAction=function(c){var d=[];if(!c.PromotionAction)return d;var e=c.PromotionAction.PromotionList;return e.forEach(function(e){var f=a._Helpers.extend(!1,{},c.EventAttributes);b.extractPromotionAttributes(f,e);var g=a._ServerModel.createEventObject({messageType:Types.MessageType.PageEvent,name:b.generateExpandedEcommerceName(Types.PromotionActionType.getExpansionName(c.PromotionAction.PromotionActionType)),data:f,eventType:Types.EventType.Transaction});d.push(g);}),d},this.expandProductAction=function(c){var d=[];if(!c.ProductAction)return d;var e=!1;if(c.ProductAction.ProductActionType===Types.ProductActionType.Purchase||c.ProductAction.ProductActionType===Types.ProductActionType.Refund){var f=a._Helpers.extend(!1,{},c.EventAttributes);f["Product Count"]=c.ProductAction.ProductList?c.ProductAction.ProductList.length:0,b.extractActionAttributes(f,c.ProductAction),c.CurrencyCode&&(f["Currency Code"]=c.CurrencyCode);var g=a._ServerModel.createEventObject({messageType:Types.MessageType.PageEvent,name:b.generateExpandedEcommerceName(Types.ProductActionType.getExpansionName(c.ProductAction.ProductActionType),!0),data:f,eventType:Types.EventType.Transaction});d.push(g);}else e=!0;var h=c.ProductAction.ProductList;return h?(h.forEach(function(f){var g=a._Helpers.extend(!1,c.EventAttributes,f.Attributes);e?b.extractActionAttributes(g,c.ProductAction):b.extractTransactionId(g,c.ProductAction),b.extractProductAttributes(g,f);var h=a._ServerModel.createEventObject({messageType:Types.MessageType.PageEvent,name:b.generateExpandedEcommerceName(Types.ProductActionType.getExpansionName(c.ProductAction.ProductActionType)),data:g,eventType:Types.EventType.Transaction});d.push(h);}),d):d},this.createCommerceEventObject=function(b){var c;return (a.Logger.verbose(Messages$4.InformationMessages.StartingLogCommerceEvent),a._Helpers.canLog())?(c=a._ServerModel.createEventObject({messageType:Types.MessageType.Commerce}),c.EventName="eCommerce - ",c.CurrencyCode=a._Store.currencyCode,c.ShoppingCart=[],c.CustomFlags=b,c):(a.Logger.verbose(Messages$4.InformationMessages.AbandonLogEvent),null)};}

  function createSDKConfig(a){var b={};for(var c in Constants.DefaultConfig)Constants.DefaultConfig.hasOwnProperty(c)&&(b[c]=Constants.DefaultConfig[c]);if(a)for(c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);for(c in Constants.DefaultUrls)b[c]=Constants.DefaultUrls[c];return b}function Store(a,b){var c={isEnabled:!0,sessionAttributes:{},currentSessionMPIDs:[],consentState:null,sessionId:null,isFirstRun:null,clientId:null,deviceId:null,devToken:null,migrationData:{},serverSettings:{},dateLastEventSent:null,sessionStartDate:null,currentPosition:null,isTracking:!1,watchPositionId:null,cartProducts:[],eventQueue:[],currencyCode:null,globalTimer:null,context:"",configurationLoaded:!1,identityCallInFlight:!1,SDKConfig:{},migratingToIDSyncCookies:!1,nonCurrentUserMPIDs:{},identifyCalled:!1,isLoggedIn:!1,cookieSyncDates:{},integrationAttributes:{},requireDelay:!0,isLocalStorageAvailable:null,storageName:null,prodStorageName:null,activeForwarders:[],kits:{},configuredForwarders:[],pixelConfigurations:[]};for(var d in c)this[d]=c[d];// Set configuration to default settings
  if(this.integrationDelayTimeoutStart=Date.now(),this.SDKConfig=createSDKConfig(a),a){if(this.SDKConfig.isDevelopmentMode=!!a.hasOwnProperty("isDevelopmentMode")&&b._Helpers.returnConvertedBoolean(a.isDevelopmentMode),a.hasOwnProperty("v1SecureServiceUrl")&&(this.SDKConfig.v1SecureServiceUrl=a.v1SecureServiceUrl),a.hasOwnProperty("v2SecureServiceUrl")&&(this.SDKConfig.v2SecureServiceUrl=a.v2SecureServiceUrl),a.hasOwnProperty("v3SecureServiceUrl")&&(this.SDKConfig.v3SecureServiceUrl=a.v3SecureServiceUrl),a.hasOwnProperty("identityUrl")&&(this.SDKConfig.identityUrl=a.identityUrl),a.hasOwnProperty("aliasUrl")&&(this.SDKConfig.aliasUrl=a.aliasUrl),a.hasOwnProperty("configUrl")&&(this.SDKConfig.configUrl=a.configUrl),a.hasOwnProperty("logLevel")&&(this.SDKConfig.logLevel=a.logLevel),this.SDKConfig.useNativeSdk=!!a.hasOwnProperty("useNativeSdk")&&a.useNativeSdk,a.hasOwnProperty("kits")&&(this.SDKConfig.kits=a.kits),this.SDKConfig.isIOS=a.hasOwnProperty("isIOS")?a.isIOS:!!(window.mParticle&&window.mParticle.isIOS)&&window.mParticle.isIOS,this.SDKConfig.useCookieStorage=!!a.hasOwnProperty("useCookieStorage")&&a.useCookieStorage,this.SDKConfig.maxProducts=a.hasOwnProperty("maxProducts")?a.maxProducts:Constants.DefaultConfig.maxProducts,this.SDKConfig.maxCookieSize=a.hasOwnProperty("maxCookieSize")?a.maxCookieSize:Constants.DefaultConfig.maxCookieSize,a.hasOwnProperty("appName")&&(this.SDKConfig.appName=a.appName),this.SDKConfig.integrationDelayTimeout=a.hasOwnProperty("integrationDelayTimeout")?a.integrationDelayTimeout:Constants.DefaultConfig.integrationDelayTimeout,a.hasOwnProperty("identifyRequest")&&(this.SDKConfig.identifyRequest=a.identifyRequest),a.hasOwnProperty("identityCallback")){var e=a.identityCallback;b._Helpers.Validators.isFunction(e)?this.SDKConfig.identityCallback=a.identityCallback:b.Logger.warning("The optional callback must be a function. You tried entering a(n) "+_typeof_1(e)," . Callback not set. Please set your callback again.");}if(a.hasOwnProperty("appVersion")&&(this.SDKConfig.appVersion=a.appVersion),a.hasOwnProperty("appName")&&(this.SDKConfig.appName=a.appName),a.hasOwnProperty("sessionTimeout")&&(this.SDKConfig.sessionTimeout=a.sessionTimeout),a.hasOwnProperty("dataPlan")&&(this.SDKConfig.dataPlan={PlanVersion:null,PlanId:null},a.dataPlan.hasOwnProperty("planId")&&("string"==typeof a.dataPlan.planId?b._Helpers.isSlug(a.dataPlan.planId)?this.SDKConfig.dataPlan.PlanId=a.dataPlan.planId:b.Logger.error("Your data plan id must be in a slug format"):b.Logger.error("Your data plan id must be a string")),a.dataPlan.hasOwnProperty("planVersion")&&("number"==typeof a.dataPlan.planVersion?this.SDKConfig.dataPlan.PlanVersion=a.dataPlan.planVersion:b.Logger.error("Your data plan version must be a number"))),this.SDKConfig.forceHttps=!a.hasOwnProperty("forceHttps")||a.forceHttps,a.hasOwnProperty("customFlags")&&(this.SDKConfig.customFlags=a.customFlags),this.SDKConfig.minWebviewBridgeVersion=a.hasOwnProperty("minWebviewBridgeVersion")?a.minWebviewBridgeVersion:1,this.SDKConfig.aliasMaxWindow=a.hasOwnProperty("aliasMaxWindow")?a.aliasMaxWindow:Constants.DefaultConfig.aliasMaxWindow,a.hasOwnProperty("dataPlanOptions")){var f=a.dataPlanOptions;f.hasOwnProperty("dataPlanVersion")&&f.hasOwnProperty("blockUserAttributes")&&f.hasOwnProperty("blockEventAttributes")&&f.hasOwnProperty("blockEvents")&&f.hasOwnProperty("blockUserIdentities")||b.Logger.error("Ensure your config.dataPlanOptions object has the following keys: a \"dataPlanVersion\" object, and \"blockUserAttributes\", \"blockEventAttributes\", \"blockEvents\", \"blockUserIdentities\" booleans");}a.hasOwnProperty("flags")||(this.SDKConfig.flags={}),this.SDKConfig.flags.hasOwnProperty(Constants.FeatureFlags.EventsV3)||(this.SDKConfig.flags[Constants.FeatureFlags.EventsV3]=0),this.SDKConfig.flags.hasOwnProperty(Constants.FeatureFlags.EventBatchingIntervalMillis)||(this.SDKConfig.flags[Constants.FeatureFlags.EventBatchingIntervalMillis]=Constants.DefaultConfig.uploadInterval),this.SDKConfig.flags.hasOwnProperty(Constants.FeatureFlags.ReportBatching)||(this.SDKConfig.flags[Constants.FeatureFlags.ReportBatching]=!1);}}

  function Logger(a){var b=this,c=a.logLevel||"warning";this.logger=a.hasOwnProperty("logger")?a.logger:new ConsoleLogger,this.verbose=function(a){"none"!==c&&b.logger.verbose&&"verbose"===c&&b.logger.verbose(a);},this.warning=function(a){"none"!==c&&b.logger.warning&&("verbose"===c||"warning"===c)&&b.logger.warning(a);},this.error=function(a){"none"!==c&&b.logger.error&&b.logger.error(a);},this.setLogLevel=function(a){c=a;};}function ConsoleLogger(){this.verbose=function(a){console&&console.info&&console.info(a);},this.error=function(a){console&&console.error&&console.error(a);},this.warning=function(a){console&&console.warn&&console.warn(a);};}

  var Base64$1=Polyfill.Base64,Messages$5=Constants.Messages,Base64CookieKeys=Constants.Base64CookieKeys,SDKv2NonMPIDCookieKeys=Constants.SDKv2NonMPIDCookieKeys,StorageNames$1=Constants.StorageNames;function _Persistence(a){function b(b){var c=a._Store;return b.gs.sid=c.sessionId,b.gs.ie=c.isEnabled,b.gs.sa=c.sessionAttributes,b.gs.ss=c.serverSettings,b.gs.dt=c.devToken,b.gs.les=c.dateLastEventSent?c.dateLastEventSent.getTime():null,b.gs.av=c.SDKConfig.appVersion,b.gs.cgid=c.clientId,b.gs.das=c.deviceId,b.gs.c=c.context,b.gs.ssd=c.sessionStartDate?c.sessionStartDate.getTime():null,b.gs.ia=c.integrationAttributes,b}function c(a){localStorage.removeItem(a);}function d(a,b,c){return f.encodePersistence(JSON.stringify(a))+";expires="+b+";path=/"+c}var f=this;// only used in persistence
  /*  This function determines if a cookie is greater than the configured maxCookieSize.
          - If it is, we remove an MPID and its associated UI/UA/CSD from the cookie.
          - Once removed, check size, and repeat.
          - Never remove the currentUser's MPID from the cookie.

      MPID removal priority:
      1. If there are no currentSessionMPIDs, remove a random MPID from the the cookie.
      2. If there are currentSessionMPIDs:
          a. Remove at random MPIDs on the cookie that are not part of the currentSessionMPIDs
          b. Then remove MPIDs based on order in currentSessionMPIDs array, which
          stores MPIDs based on earliest login.
  */ // This function loops through the parts of a full hostname, attempting to set a cookie on that domain. It will set a cookie at the highest level possible.
  // For example subdomain.domain.co.uk would try the following combinations:
  // "co.uk" -> fail
  // "domain.co.uk" -> success, return
  // "subdomain.domain.co.uk" -> skipped, because already found
  /**
       * set the "first seen" time for a user. the time will only be set once for a given
       * mpid after which subsequent calls will be ignored
       */ /**
       * returns the "last seen" time for a user. If the mpid represents the current user, the
       * return value will always be the current time, otherwise it will be to stored "last seen"
       * time
       */ // Forwarder Batching Code
  this.useLocalStorage=function(){return !a._Store.SDKConfig.useCookieStorage&&a._Store.isLocalStorageAvailable},this.initializeStorage=function(){try{var b,c,d=f.getLocalStorage(),e=f.getCookie();// Determine if there is any data in cookies or localStorage to figure out if it is the first time the browser is loading mParticle
  d||e?a._Store.isFirstRun=!1:(a._Store.isFirstRun=!0,a._Store.mpid=0),a._Store.isLocalStorageAvailable||(a._Store.SDKConfig.useCookieStorage=!0),a._Store.isLocalStorageAvailable?(b=window.localStorage,a._Store.SDKConfig.useCookieStorage?(d?(c=e?a._Helpers.extend(!1,d,e):d,b.removeItem(a._Store.storageName)):e&&(c=e),f.storeDataInMemory(c)):e?(c=d?a._Helpers.extend(!1,d,e):e,f.storeDataInMemory(c),f.expireCookies(a._Store.storageName)):f.storeDataInMemory(d)):f.storeDataInMemory(e);try{if(a._Store.isLocalStorageAvailable){var g=localStorage.getItem(a._Store.prodStorageName);if(g)var h=JSON.parse(Base64$1.decode(g));a._Store.mpid&&f.storeProductsInMemory(h,a._Store.mpid);}}catch(b){a._Store.isLocalStorageAvailable&&localStorage.removeItem(a._Store.prodStorageName),a._Store.cartProducts=[],a.Logger.error("Error loading products in initialization: "+b);}for(var i in c)c.hasOwnProperty(i)&&(SDKv2NonMPIDCookieKeys[i]||(a._Store.nonCurrentUserMPIDs[i]=c[i]));f.update();}catch(b){f.useLocalStorage()&&a._Store.isLocalStorageAvailable?localStorage.removeItem(a._Store.storageName):f.expireCookies(a._Store.storageName),a.Logger.error("Error initializing storage: "+b);}},this.update=function(){a._Store.webviewBridgeEnabled||(a._Store.SDKConfig.useCookieStorage&&f.setCookie(),f.setLocalStorage());},this.storeProductsInMemory=function(b,c){if(b)try{a._Store.cartProducts=b[c]&&b[c].cp?b[c].cp:[];}catch(b){a.Logger.error(Messages$5.ErrorMessages.CookieParseError);}},this.storeDataInMemory=function(b,c){try{b?(a._Store.mpid=c?c:b.cu||0,b.gs=b.gs||{},a._Store.sessionId=b.gs.sid||a._Store.sessionId,a._Store.isEnabled="undefined"==typeof b.gs.ie?a._Store.isEnabled:b.gs.ie,a._Store.sessionAttributes=b.gs.sa||a._Store.sessionAttributes,a._Store.serverSettings=b.gs.ss||a._Store.serverSettings,a._Store.devToken=a._Store.devToken||b.gs.dt,a._Store.SDKConfig.appVersion=a._Store.SDKConfig.appVersion||b.gs.av,a._Store.clientId=b.gs.cgid||a._Store.clientId||a._Helpers.generateUniqueId(),a._Store.deviceId=b.gs.das||a._Store.deviceId||a._Helpers.generateUniqueId(),a._Store.integrationAttributes=b.gs.ia||{},a._Store.context=b.gs.c||a._Store.context,a._Store.currentSessionMPIDs=b.gs.csm||a._Store.currentSessionMPIDs,a._Store.isLoggedIn=!0===b.l,b.gs.les&&(a._Store.dateLastEventSent=new Date(b.gs.les)),a._Store.sessionStartDate=b.gs.ssd?new Date(b.gs.ssd):new Date,b=c?b[c]:b[b.cu]):(a.Logger.verbose(Messages$5.InformationMessages.CookieNotFound),a._Store.clientId=a._Store.clientId||a._Helpers.generateUniqueId(),a._Store.deviceId=a._Store.deviceId||a._Helpers.generateUniqueId());}catch(b){a.Logger.error(Messages$5.ErrorMessages.CookieParseError);}},this.determineLocalStorageAvailability=function(a){var b;window.mParticle&&window.mParticle._forceNoLocalStorage&&(a=void 0);try{return a.setItem("mparticle","test"),b="test"===a.getItem("mparticle"),a.removeItem("mparticle"),b&&a}catch(a){return !1}},this.getUserProductsFromLS=function(b){if(!a._Store.isLocalStorageAvailable)return [];var c,d,e,f=localStorage.getItem(a._Store.prodStorageName);// if there is an MPID, we are retrieving the user's products, which is an array
  if(f&&(c=Base64$1.decode(f)),b)try{return c&&(e=JSON.parse(c)),d=c&&e[b]&&e[b].cp&&Array.isArray(e[b].cp)?e[b].cp:[],d}catch(a){return []}else return []},this.getAllUserProductsFromLS=function(){var b,c,d=localStorage.getItem(a._Store.prodStorageName);d&&(b=Base64$1.decode(d));// returns an object with keys of MPID and values of array of products
  try{c=JSON.parse(b);}catch(a){c={};}return c},this.setLocalStorage=function(){if(a._Store.isLocalStorageAvailable){var c=a._Store.storageName,d=f.getAllUserProductsFromLS(),e=f.getLocalStorage()||{},g=a.Identity.getCurrentUser(),h=g?g.getMPID():null,i={cp:d[h]?d[h].cp:[]};if(h){d=d||{},d[h]=i;try{window.localStorage.setItem(encodeURIComponent(a._Store.prodStorageName),Base64$1.encode(JSON.stringify(d)));}catch(b){a.Logger.error("Error with setting products on localStorage.");}}if(!a._Store.SDKConfig.useCookieStorage){e.gs=e.gs||{},e.l=a._Store.isLoggedIn?1:0,a._Store.sessionId&&(e.gs.csm=a._Store.currentSessionMPIDs),e.gs.ie=a._Store.isEnabled,h&&(e.cu=h),Object.keys(a._Store.nonCurrentUserMPIDs).length&&(e=a._Helpers.extend({},e,a._Store.nonCurrentUserMPIDs),a._Store.nonCurrentUserMPIDs={}),e=b(e);try{window.localStorage.setItem(encodeURIComponent(c),f.encodePersistence(JSON.stringify(e)));}catch(b){a.Logger.error("Error with setting localStorage item.");}}}},this.getLocalStorage=function(){if(!a._Store.isLocalStorageAvailable)return null;var b,c=a._Store.storageName,d=f.decodePersistence(window.localStorage.getItem(c)),e={};if(d)for(b in d=JSON.parse(d),d)d.hasOwnProperty(b)&&(e[b]=d[b]);return Object.keys(e).length?e:null},this.expireCookies=function(a){var b,c,d,e=new Date;d=f.getCookieDomain(),c=""===d?"":";domain="+d,e.setTime(e.getTime()-86400000),b="; expires="+e.toUTCString(),document.cookie=a+"="+b+"; path=/"+c;},this.getCookie=function(){var b,c,d,g,h,j=window.document.cookie.split("; "),k=a._Store.storageName,m=k?void 0:{};for(a.Logger.verbose(Messages$5.InformationMessages.CookieSearch),b=0,c=j.length;b<c;b++){try{d=j[b].split("="),g=a._Helpers.decoded(d.shift()),h=a._Helpers.decoded(d.join("="));}catch(b){a.Logger.verbose("Unable to parse cookie: "+g+". Skipping.");}if(k&&k===g){m=a._Helpers.converted(h);break}k||(m[g]=a._Helpers.converted(h));}return m?(a.Logger.verbose(Messages$5.InformationMessages.CookieFound),JSON.parse(f.decodePersistence(m))):null},this.setCookie=function(){var c,d=a.Identity.getCurrentUser();d&&(c=d.getMPID());var e,g,h,i=new Date,j=a._Store.storageName,k=f.getCookie()||{},l=new Date(i.getTime()+1e3*(60*(60*(24*a._Store.SDKConfig.cookieExpiration)))).toGMTString();e=f.getCookieDomain(),g=""===e?"":";domain="+e,k.gs=k.gs||{},a._Store.sessionId&&(k.gs.csm=a._Store.currentSessionMPIDs),c&&(k.cu=c),k.l=a._Store.isLoggedIn?1:0,k=b(k),Object.keys(a._Store.nonCurrentUserMPIDs).length&&(k=a._Helpers.extend({},k,a._Store.nonCurrentUserMPIDs),a._Store.nonCurrentUserMPIDs={}),h=f.reduceAndEncodePersistence(k,l,g,a._Store.SDKConfig.maxCookieSize),a.Logger.verbose(Messages$5.InformationMessages.CookieSet),window.document.cookie=encodeURIComponent(j)+"="+h;},this.reduceAndEncodePersistence=function(b,c,e,f){var g,h=b.gs.csm?b.gs.csm:[];// Comment 1 above
  if(!h.length)for(var j in b)b.hasOwnProperty(j)&&(g=d(b,c,e),g.length>f&&!SDKv2NonMPIDCookieKeys[j]&&j!==b.cu&&delete b[j]);else {// Comment 2 above - First create an object of all MPIDs on the cookie
  var k={};for(var l in b)b.hasOwnProperty(l)&&(SDKv2NonMPIDCookieKeys[l]||l===b.cu||(k[l]=1));// Comment 2a above
  if(Object.keys(k).length)for(var m in k)g=d(b,c,e),g.length>f&&k.hasOwnProperty(m)&&-1===h.indexOf(m)&&delete b[m];// Comment 2b above
  for(var n,o=0;o<h.length&&(g=d(b,c,e),g.length>f);o++)n=h[o],b[n]?(a.Logger.verbose("Size of new encoded cookie is larger than maxCookieSize setting of "+f+". Removing from cookie the earliest logged in MPID containing: "+JSON.stringify(b[n],0,2)),delete b[n]):a.Logger.error("Unable to save MPID data to cookies because the resulting encoded cookie is larger than the maxCookieSize setting of "+f+". We recommend using a maxCookieSize of 1500.");}return g},this.findPrevCookiesBasedOnUI=function(b){var c,d=a._Persistence.getPersistence();if(b)for(var e in b.userIdentities)if(d&&Object.keys(d).length)for(var g in d)// any value in persistence that has an MPID key will be an MPID to search through
  // other keys on the cookie are currentSessionMPIDs and currentMPID which should not be searched
  if(d[g].mpid){var h=d[g].ui;for(var i in h)if(e===i&&b.userIdentities[e]===h[i]){c=g;break}}c&&f.storeDataInMemory(d,c);},this.encodePersistence=function(b){for(var c in b=JSON.parse(b),b.gs)b.gs.hasOwnProperty(c)&&(Base64CookieKeys[c]?b.gs[c]?Array.isArray(b.gs[c])&&b.gs[c].length||a._Helpers.isObject(b.gs[c])&&Object.keys(b.gs[c]).length?b.gs[c]=Base64$1.encode(JSON.stringify(b.gs[c])):delete b.gs[c]:delete b.gs[c]:"ie"===c?b.gs[c]=b.gs[c]?1:0:!b.gs[c]&&delete b.gs[c]);for(var d in b)if(b.hasOwnProperty(d)&&!SDKv2NonMPIDCookieKeys[d])for(c in b[d])b[d].hasOwnProperty(c)&&Base64CookieKeys[c]&&(a._Helpers.isObject(b[d][c])&&Object.keys(b[d][c]).length?b[d][c]=Base64$1.encode(JSON.stringify(b[d][c])):delete b[d][c]);return f.createCookieString(JSON.stringify(b))},this.decodePersistence=function(b){try{if(b){if(b=JSON.parse(f.revertCookieString(b)),a._Helpers.isObject(b)&&Object.keys(b).length){for(var c in b.gs)b.gs.hasOwnProperty(c)&&(Base64CookieKeys[c]?b.gs[c]=JSON.parse(Base64$1.decode(b.gs[c])):"ie"===c&&(b.gs[c]=!!b.gs[c]));for(var d in b)if(b.hasOwnProperty(d))if(!SDKv2NonMPIDCookieKeys[d])for(c in b[d])b[d].hasOwnProperty(c)&&Base64CookieKeys[c]&&b[d][c].length&&(b[d][c]=JSON.parse(Base64$1.decode(b[d][c])));else "l"===d&&(b[d]=!!b[d]);}return JSON.stringify(b)}}catch(b){a.Logger.error("Problem with decoding cookie",b);}},this.replaceCommasWithPipes=function(a){return a.replace(/,/g,"|")},this.replacePipesWithCommas=function(a){return a.replace(/\|/g,",")},this.replaceApostrophesWithQuotes=function(a){return a.replace(/\'/g,"\"")},this.replaceQuotesWithApostrophes=function(a){return a.replace(/\"/g,"'")},this.createCookieString=function(a){return f.replaceCommasWithPipes(f.replaceQuotesWithApostrophes(a))},this.revertCookieString=function(a){return f.replacePipesWithCommas(f.replaceApostrophesWithQuotes(a))},this.getCookieDomain=function(){if(a._Store.SDKConfig.cookieDomain)return a._Store.SDKConfig.cookieDomain;var b=f.getDomain(document,location.hostname);return ""===b?"":"."+b},this.getDomain=function(a,b){var c,d,e=b.split(".");for(c=e.length-1;0<=c;c--)if(d=e.slice(c).join("."),a.cookie="mptest=cookie;domain=."+d+";",-1<a.cookie.indexOf("mptest=cookie"))return a.cookie="mptest=;domain=."+d+";expires=Thu, 01 Jan 1970 00:00:01 GMT;",d;return ""},this.getUserIdentities=function(a){var b=f.getPersistence();return b&&b[a]&&b[a].ui?b[a].ui:{}},this.getAllUserAttributes=function(a){var b=f.getPersistence();return b&&b[a]&&b[a].ua?b[a].ua:{}},this.getCartProducts=function(b){var c,d=localStorage.getItem(a._Store.prodStorageName);return d&&(c=JSON.parse(Base64$1.decode(d)),c&&c[b]&&c[b].cp)?c[b].cp:[]},this.setCartProducts=function(b){if(a._Store.isLocalStorageAvailable)try{window.localStorage.setItem(encodeURIComponent(a._Store.prodStorageName),Base64$1.encode(JSON.stringify(b)));}catch(b){a.Logger.error("Error with setting products on localStorage.");}},this.saveUserIdentitiesToPersistence=function(a,b){if(b){var c=f.getPersistence();c&&(c[a]?c[a].ui=b:c[a]={ui:b},f.savePersistence(c));}},this.saveUserAttributesToPersistence=function(a,b){var c=f.getPersistence();b&&(c&&(c[a]?c[a].ui=b:c[a]={ui:b}),f.savePersistence(c));},this.saveUserCookieSyncDatesToPersistence=function(a,b){if(b){var c=f.getPersistence();c&&(c[a]?c[a].csd=b:c[a]={csd:b}),f.savePersistence(c);}},this.saveUserConsentStateToCookies=function(b,c){//it's currently not supported to set persistence
  //for any MPID that's not the current one.
  if(c||null===c){var d=f.getPersistence();d&&(d[b]?d[b].con=a._Consent.ConsentSerialization.toMinifiedJsonObject(c):d[b]={con:a._Consent.ConsentSerialization.toMinifiedJsonObject(c)},f.savePersistence(d));}},this.savePersistence=function(b){var c,d=f.encodePersistence(JSON.stringify(b)),e=new Date,g=a._Store.storageName,h=new Date(e.getTime()+1e3*(60*(60*(24*a._Store.SDKConfig.cookieExpiration)))).toGMTString(),i=f.getCookieDomain();if(c=""===i?"":";domain="+i,a._Store.SDKConfig.useCookieStorage){var j=f.reduceAndEncodePersistence(b,h,c,a._Store.SDKConfig.maxCookieSize);window.document.cookie=encodeURIComponent(g)+"="+j;}else a._Store.isLocalStorageAvailable&&localStorage.setItem(a._Store.storageName,d);},this.getPersistence=function(){var a=this.useLocalStorage()?this.getLocalStorage():this.getCookie();return a},this.getConsentState=function(b){var c=f.getPersistence();return c&&c[b]&&c[b].con?a._Consent.ConsentSerialization.fromMinifiedJsonObject(c[b].con):null},this.getFirstSeenTime=function(a){if(!a)return null;var b=f.getPersistence();return b&&b[a]&&b[a].fst?b[a].fst:null},this.setFirstSeenTime=function(a,b){if(a){b||(b=new Date().getTime());var c=f.getPersistence();c&&(!c[a]&&(c[a]={}),!c[a].fst&&(c[a].fst=b,f.savePersistence(c)));}},this.getLastSeenTime=function(b){if(!b)return null;if(b===a.Identity.getCurrentUser().getMPID())//if the mpid is the current user, its last seen time is the current time
  return new Date().getTime();var c=f.getPersistence();return c&&c[b]&&c[b].lst?c[b].lst:null},this.setLastSeenTime=function(a,b){if(a){b||(b=new Date().getTime());var c=f.getPersistence();c&&c[a]&&(c[a].lst=b,f.savePersistence(c));}},this.getDeviceId=function(){return a._Store.deviceId},this.resetPersistence=function(){if(c(StorageNames$1.localStorageName),c(StorageNames$1.localStorageNameV3),c(StorageNames$1.localStorageNameV4),c(a._Store.prodStorageName),c(a._Store.storageName),c(StorageNames$1.localStorageProductsV4),f.expireCookies(StorageNames$1.cookieName),f.expireCookies(StorageNames$1.cookieNameV2),f.expireCookies(StorageNames$1.cookieNameV3),f.expireCookies(StorageNames$1.cookieNameV4),f.expireCookies(a._Store.prodStorageName),f.expireCookies(a._Store.storageName),mParticle._isTestEnv){c(a._Helpers.createMainStorageName("abcdef")),f.expireCookies(a._Helpers.createMainStorageName("abcdef")),c(a._Helpers.createProductStorageName("abcdef"));}},this.forwardingStatsBatches={uploadsTable:{},forwardingStatsEventQueue:[]};}

  var Messages$6=Constants.Messages;function Events(a){var b=this;this.logEvent=function(b){if(a.Logger.verbose(Messages$6.InformationMessages.StartingLogEvent+": "+b.name),a._Helpers.canLog()){var c=a._ServerModel.createEventObject(b);a._APIClient.sendEventToServer(c);}else a.Logger.verbose(Messages$6.InformationMessages.AbandonLogEvent);},this.startTracking=function(b){function c(c){// prevents callback from being fired multiple times
  a._Store.currentPosition={lat:c.coords.latitude,lng:c.coords.longitude},e(b,c),b=null,a._Store.isTracking=!0;}function d(){// prevents callback from being fired multiple times
  e(b),b=null,a._Store.isTracking=!1;}function e(b,c){if(b)try{c?b(c):b();}catch(b){a.Logger.error("Error invoking the callback passed to startTrackingLocation."),a.Logger.error(b);}}if(!a._Store.isTracking)"geolocation"in navigator&&(a._Store.watchPositionId=navigator.geolocation.watchPosition(c,d));else {var f={coords:{latitude:a._Store.currentPosition.lat,longitude:a._Store.currentPosition.lng}};e(b,f);}},this.stopTracking=function(){a._Store.isTracking&&(navigator.geolocation.clearWatch(a._Store.watchPositionId),a._Store.currentPosition=null,a._Store.isTracking=!1);},this.logOptOut=function(){a.Logger.verbose(Messages$6.InformationMessages.StartingLogOptOut);var b=a._ServerModel.createEventObject({messageType:Types.MessageType.OptOut,eventType:Types.EventType.Other});a._APIClient.sendEventToServer(b);},this.logAST=function(){b.logEvent({messageType:Types.MessageType.AppStateTransition});},this.logCheckoutEvent=function(c,d,e,f){var g=a._Ecommerce.createCommerceEventObject(f);g&&(g.EventName+=a._Ecommerce.getProductActionEventName(Types.ProductActionType.Checkout),g.EventCategory=Types.CommerceEventType.ProductCheckout,g.ProductAction={ProductActionType:Types.ProductActionType.Checkout,CheckoutStep:c,CheckoutOptions:d,ProductList:[]},b.logCommerceEvent(g,e));},this.logProductActionEvent=function(c,d,e,f,g){var h=a._Ecommerce.createCommerceEventObject(f);h&&(h.EventCategory=a._Ecommerce.convertProductActionToEventType(c),h.EventName+=a._Ecommerce.getProductActionEventName(c),h.ProductAction={ProductActionType:c,ProductList:Array.isArray(d)?d:[d]},a._Helpers.isObject(g)&&a._Ecommerce.convertTransactionAttributesToProductAction(g,h.ProductAction),b.logCommerceEvent(h,e));},this.logPurchaseEvent=function(c,d,e,f){var g=a._Ecommerce.createCommerceEventObject(f);g&&(g.EventName+=a._Ecommerce.getProductActionEventName(Types.ProductActionType.Purchase),g.EventCategory=Types.CommerceEventType.ProductPurchase,g.ProductAction={ProductActionType:Types.ProductActionType.Purchase},g.ProductAction.ProductList=a._Ecommerce.buildProductList(g,d),a._Ecommerce.convertTransactionAttributesToProductAction(c,g.ProductAction),b.logCommerceEvent(g,e));},this.logRefundEvent=function(c,d,e,f){if(!c)return void a.Logger.error(Messages$6.ErrorMessages.TransactionRequired);var g=a._Ecommerce.createCommerceEventObject(f);g&&(g.EventName+=a._Ecommerce.getProductActionEventName(Types.ProductActionType.Refund),g.EventCategory=Types.CommerceEventType.ProductRefund,g.ProductAction={ProductActionType:Types.ProductActionType.Refund},g.ProductAction.ProductList=a._Ecommerce.buildProductList(g,d),a._Ecommerce.convertTransactionAttributesToProductAction(c,g.ProductAction),b.logCommerceEvent(g,e));},this.logPromotionEvent=function(c,d,e,f){var g=a._Ecommerce.createCommerceEventObject(f);g&&(g.EventName+=a._Ecommerce.getPromotionActionEventName(c),g.EventCategory=a._Ecommerce.convertPromotionActionToEventType(c),g.PromotionAction={PromotionActionType:c,PromotionList:[d]},b.logCommerceEvent(g,e));},this.logImpressionEvent=function(c,d,e){var f=a._Ecommerce.createCommerceEventObject(e);f&&(f.EventName+="Impression",f.EventCategory=Types.CommerceEventType.ProductImpression,!Array.isArray(c)&&(c=[c]),f.ProductImpressions=[],c.forEach(function(a){f.ProductImpressions.push({ProductImpressionList:a.Name,ProductList:Array.isArray(a.Product)?a.Product:[a.Product]});}),b.logCommerceEvent(f,d));},this.logCommerceEvent=function(b,c){a.Logger.verbose(Messages$6.InformationMessages.StartingLogCommerceEvent),c=a._Helpers.sanitizeAttributes(c,b.EventName),a._Helpers.canLog()?(a._Store.webviewBridgeEnabled&&(b.ShoppingCart={}),c&&(b.EventAttributes=c),a._APIClient.sendEventToServer(b),a._Persistence.update()):a.Logger.verbose(Messages$6.InformationMessages.AbandonLogEvent);},this.addEventHandler=function(c,d,f,g,h){var j,k,e=[],l=function(c){var d=function(){j.href?window.location.href=j.href:j.submit&&j.submit();};a.Logger.verbose("DOM event triggered, handling event"),b.logEvent({messageType:Types.MessageType.PageEvent,name:"function"==typeof f?f(j):f,data:"function"==typeof g?g(j):g,eventType:h||Types.EventType.Other}),(j.href&&"_blank"!==j.target||j.submit)&&(c.preventDefault?c.preventDefault():c.returnValue=!1,setTimeout(d,a._Store.SDKConfig.timeout));};if(!d)return void a.Logger.error("Can't bind event, selector is required");// Handle a css selector string or a dom element
  if("string"==typeof d?e=document.querySelectorAll(d):d.nodeType&&(e=[d]),e.length)for(a.Logger.verbose("Found "+e.length+" element"+(1<e.length?"s":"")+", attaching event handlers"),k=0;k<e.length;k++)j=e[k],j.addEventListener?j.addEventListener(c,l,!1):j.attachEvent?j.attachEvent("on"+c,l):j["on"+c]=l;else a.Logger.verbose("No elements found");};}

  var StorageNames$2=Constants.StorageNames,Base64$2=Polyfill.Base64,CookiesGlobalSettingsKeys={das:1},MPIDKeys={ui:1};function Migrations(a){function b(){var b,d,f,g,j,k,m=window.document.cookie.split("; ");for(a.Logger.verbose(Constants.Messages.InformationMessages.CookieSearch),d=0,f=m.length;d<f;d++){try{g=m[d].split("="),j=a._Helpers.decoded(g.shift()),k=a._Helpers.decoded(g.join("="));}catch(b){a.Logger.verbose("Unable to parse cookie: "+j+". Skipping.");}//most recent version needs no migration
  if(j===a._Store.storageName)return;if(j===StorageNames$2.cookieNameV4)return c(k,StorageNames$2.cookieNameV4),void(a._Store.isLocalStorageAvailable&&e());// migration path for SDKv1CookiesV3, doesn't need to be encoded
  if(j===StorageNames$2.cookieNameV3){b=h.convertSDKv1CookiesV3ToSDKv2CookiesV4(k),c(b,StorageNames$2.cookieNameV3);break}}}function c(b,c){var d,e,f=new Date,g=a._Persistence.getCookieDomain();d=new Date(f.getTime()+1e3*(60*(60*(24*StorageNames$2.CookieExpiration)))).toGMTString(),e=""===g?"":";domain="+g,a.Logger.verbose(Constants.Messages.InformationMessages.CookieSet),window.document.cookie=encodeURIComponent(a._Store.storageName)+"="+b+";expires="+d+";path=/"+e,a._Persistence.expireCookies(c),a._Store.migratingToIDSyncCookies=!0;}function d(b){try{var c={gs:{csm:[]}};for(var d in b=JSON.parse(b),b)b.hasOwnProperty(d)&&(CookiesGlobalSettingsKeys[d]?c.gs[d]=b[d]:"mpid"===d?c.cu=b[d]:b.mpid&&(c[b.mpid]=c[b.mpid]||{},MPIDKeys[d]&&(c[b.mpid][d]=b[d])));return JSON.stringify(c)}catch(b){a.Logger.error("Failed to restructure previous cookie into most current cookie schema");}}function e(){var b=StorageNames$2.localStorageProductsV4,c=localStorage.getItem(StorageNames$2.localStorageProductsV4);localStorage.setItem(a._Store.prodStorageName,c),localStorage.removeItem(b);}function f(b,c){if(a._Store.isLocalStorageAvailable){var d={};if(d[c]={},b.cp){try{d[c].cp=JSON.parse(Base64$2.decode(b.cp));}catch(a){d[c].cp=b.cp;}Array.isArray(d[c].cp)||(d[c].cp=[]);}localStorage.setItem(a._Store.prodStorageName,Base64$2.encode(JSON.stringify(d)));}}function g(){function b(b,c){try{window.localStorage.setItem(encodeURIComponent(a._Store.storageName),b);}catch(b){a.Logger.error("Error with setting localStorage item.");}window.localStorage.removeItem(encodeURIComponent(c));}var c,d,g,i,j=StorageNames$2.localStorageNameV3,k=StorageNames$2.localStorageNameV4,l=window.localStorage.getItem(a._Store.storageName);if(!l){if(d=window.localStorage.getItem(k),d)return b(d,k),void e();if(g=window.localStorage.getItem(j),g){// localStorage may contain only products, or the full persistence
  // when there is an MPID on the cookie, it is the full persistence
  if(a._Store.migratingToIDSyncCookies=!0,i=g.slice(),g=JSON.parse(a._Persistence.replacePipesWithCommas(a._Persistence.replaceApostrophesWithQuotes(g))),g.mpid)return g=JSON.parse(h.convertSDKv1CookiesV3ToSDKv2CookiesV4(i)),void b(JSON.stringify(g),j);// if no MPID, it is only the products
  if((g.cp||g.pb)&&!g.mpid)return c=a._Persistence.getCookie(),c?(f(g,c.cu),void localStorage.removeItem(StorageNames$2.localStorageNameV3)):void localStorage.removeItem(StorageNames$2.localStorageNameV3)}}}var h=this;//  if there is a cookie or localStorage:
  //  1. determine which version it is ('mprtcl-api', 'mprtcl-v2', 'mprtcl-v3', 'mprtcl-v4')
  //  2. return if 'mprtcl-v4', otherwise migrate to mprtclv4 schema
  // 3. if 'mprtcl-api', could be JSSDKv2 or JSSDKv1. JSSDKv2 cookie has a 'globalSettings' key on it
  this.migrate=function(){try{b();}catch(b){a._Persistence.expireCookies(StorageNames$2.cookieNameV3),a._Persistence.expireCookies(StorageNames$2.cookieNameV4),a.Logger.error("Error migrating cookie: "+b);}if(a._Store.isLocalStorageAvailable)try{g();}catch(b){localStorage.removeItem(StorageNames$2.localStorageNameV3),localStorage.removeItem(StorageNames$2.localStorageNameV4),a.Logger.error("Error migrating localStorage: "+b);}},this.convertSDKv1CookiesV3ToSDKv2CookiesV4=function(b){b=a._Persistence.replacePipesWithCommas(a._Persistence.replaceApostrophesWithQuotes(b));var c=JSON.parse(b),e=JSON.parse(d(b));return c.mpid&&(e.gs.csm.push(c.mpid),e.gs.csm=Base64$2.encode(JSON.stringify(e.gs.csm)),f(c,c.mpid)),JSON.stringify(e)};}

  function filteredMparticleUser(a,b,c,d){var e=this;return {getUserIdentities:function getUserIdentities(){var e={},f=c._Persistence.getUserIdentities(a);for(var g in f)if(f.hasOwnProperty(g)){var h=Types.IdentityType.getIdentityName(c._Helpers.parseNumber(g));d&&(!d||d.isIdentityBlocked(h))||(//if identity type is not blocked
  e[h]=f[g]);}return e=c._Helpers.filterUserIdentitiesForForwarders(e,b.userIdentityFilters),{userIdentities:e}},getMPID:function getMPID(){return a},getUserAttributesLists:function getUserAttributesLists(a){var b,f={};for(var g in b=e.getAllUserAttributes(),b)b.hasOwnProperty(g)&&Array.isArray(b[g])&&(d&&(!d||d.isAttributeKeyBlocked(g))||(f[g]=b[g].slice()));return f=c._Helpers.filterUserAttributes(f,a.userAttributeFilters),f},getAllUserAttributes:function getAllUserAttributes(){var e={},f=c._Persistence.getAllUserAttributes(a);if(f)for(var g in f)f.hasOwnProperty(g)&&(d&&(!d||d.isAttributeKeyBlocked(g))||(Array.isArray(f[g])?e[g]=f[g].slice():e[g]=f[g]));return e=c._Helpers.filterUserAttributes(e,b.userAttributeFilters),e}}}

  function Forwarders(a,b){var c=this;this.initForwarders=function(b,d){var e=a.Identity.getCurrentUser();!a._Store.webviewBridgeEnabled&&a._Store.configuredForwarders&&(a._Store.configuredForwarders.sort(function(a,b){return a.settings.PriorityValue=a.settings.PriorityValue||0,b.settings.PriorityValue=b.settings.PriorityValue||0,-1*(a.settings.PriorityValue-b.settings.PriorityValue)}),a._Store.activeForwarders=a._Store.configuredForwarders.filter(function(f){if(!c.isEnabledForUserConsent(f.filteringConsentRuleValues,e))return !1;if(!c.isEnabledForUserAttributes(f.filteringUserAttributeValue,e))return !1;if(!c.isEnabledForUnknownUser(f.excludeAnonymousUser,e))return !1;var g=a._Helpers.filterUserIdentities(b,f.userIdentityFilters),h=a._Helpers.filterUserAttributes(e?e.getAllUserAttributes():{},f.userAttributeFilters);return f.initialized||(f.init(f.settings,d,!1,null,h,g,a._Store.SDKConfig.appVersion,a._Store.SDKConfig.appName,a._Store.SDKConfig.customFlags,a._Store.clientId),f.initialized=!0),!0}));},this.isEnabledForUserConsent=function(b,c){if(!b||!b.values||!b.values.length)return !0;if(!c)return !1;var d={},e=c.getConsentState();if(e){// the server hashes consent purposes in the following way:
  // GDPR - '1' + purpose name
  // CCPA - '2data_sale_opt_out' (there is only 1 purpose of data_sale_opt_out for CCPA)
  var f=e.getGDPRConsentState();if(f)for(var g in f)f.hasOwnProperty(g)&&(i=a._Helpers.generateHash("1"+g).toString(),d[i]=f[g].Consented);var h=e.getCCPAConsentState();if(h){var i=a._Helpers.generateHash("2"+"data_sale_opt_out").toString();d[i]=h.Consented;}}var j=!1;return b.values.forEach(function(a){if(!j){var b=a.consentPurpose,c=a.hasConsented;d.hasOwnProperty(b)&&d[b]===c&&(j=!0);}}),b.includeOnMatch===j},this.isEnabledForUserAttributes=function(b,c){if(!b||!a._Helpers.isObject(b)||!Object.keys(b).length)return !0;var d,e,f;if(!c)return !1;f=c.getAllUserAttributes();var g=!1;try{if(f&&a._Helpers.isObject(f)&&Object.keys(f).length)for(var h in f)if(f.hasOwnProperty(h)&&(d=a._Helpers.generateHash(h).toString(),e=a._Helpers.generateHash(f[h]).toString(),d===b.userAttributeName&&e===b.userAttributeValue)){g=!0;break}return !b||b.includeOnMatch===g}catch(a){// in any error scenario, err on side of returning true and forwarding event
  return !0}},this.isEnabledForUnknownUser=function(a,b){return !!(b&&b.isLoggedIn()||!a)},this.applyToForwarders=function(b,c){a._Store.activeForwarders.length&&a._Store.activeForwarders.forEach(function(d){var e=d[b];if(e)try{var f=d[b](c);f&&a.Logger.verbose(f);}catch(b){a.Logger.verbose(b);}});},this.sendEventToForwarders=function(b){var c,d,e,f=function(b,c){b.UserIdentities&&b.UserIdentities.length&&b.UserIdentities.forEach(function(d,e){a._Helpers.inArray(c,d.Type)&&(b.UserIdentities.splice(e,1),0<e&&e--);});},g=function(b,c){var d;if(c)for(var e in b.EventAttributes)b.EventAttributes.hasOwnProperty(e)&&(d=a._Helpers.generateHash(b.EventCategory+b.EventName+e),a._Helpers.inArray(c,d)&&delete b.EventAttributes[e]);},h=function(b,c){return !!(b&&b.length&&a._Helpers.inArray(b,c))},j=[Types.MessageType.PageEvent,Types.MessageType.PageView,Types.MessageType.Commerce];if(!a._Store.webviewBridgeEnabled&&a._Store.activeForwarders){d=a._Helpers.generateHash(b.EventCategory+b.EventName),e=a._Helpers.generateHash(b.EventCategory);for(var k=0;k<a._Store.activeForwarders.length;k++){// Check attribute forwarding rule. This rule allows users to only forward an event if a
  // specific attribute exists and has a specific value. Alternatively, they can specify
  // that an event not be forwarded if the specified attribute name and value exists.
  // The two cases are controlled by the "includeOnMatch" boolean value.
  // Supported message types for attribute forwarding rules are defined in the forwardingRuleMessageTypes array
  if(-1<j.indexOf(b.EventDataType)&&a._Store.activeForwarders[k].filteringEventAttributeValue&&a._Store.activeForwarders[k].filteringEventAttributeValue.eventAttributeName&&a._Store.activeForwarders[k].filteringEventAttributeValue.eventAttributeValue){var l=null;// Attempt to find the attribute in the collection of event attributes
  if(b.EventAttributes)for(var m in b.EventAttributes){var n;if(n=a._Helpers.generateHash(m).toString(),n===a._Store.activeForwarders[k].filteringEventAttributeValue.eventAttributeName&&(l={name:n,value:a._Helpers.generateHash(b.EventAttributes[m]).toString()}),l)break}var o=null!==l&&l.value===a._Store.activeForwarders[k].filteringEventAttributeValue.eventAttributeValue,p=!0===a._Store.activeForwarders[k].filteringEventAttributeValue.includeOnMatch?o:!o;if(!p)continue}// Clone the event object, as we could be sending different attributes to each forwarder
  // Check event filtering rules
  if(c={},c=a._Helpers.extend(!0,c,b),b.EventDataType===Types.MessageType.PageEvent&&(h(a._Store.activeForwarders[k].eventNameFilters,d)||h(a._Store.activeForwarders[k].eventTypeFilters,e)))continue;else if(b.EventDataType===Types.MessageType.Commerce&&h(a._Store.activeForwarders[k].eventTypeFilters,e))continue;else if(b.EventDataType===Types.MessageType.PageView&&h(a._Store.activeForwarders[k].screenNameFilters,d))continue;// Check attribute filtering rules
  if(c.EventAttributes&&(b.EventDataType===Types.MessageType.PageEvent?g(c,a._Store.activeForwarders[k].attributeFilters):b.EventDataType===Types.MessageType.PageView&&g(c,a._Store.activeForwarders[k].pageViewAttributeFilters)),f(c,a._Store.activeForwarders[k].userIdentityFilters),c.UserAttributes=a._Helpers.filterUserAttributes(c.UserAttributes,a._Store.activeForwarders[k].userAttributeFilters),a.Logger.verbose("Sending message to forwarder: "+a._Store.activeForwarders[k].name),a._Store.activeForwarders[k].process){var q=a._Store.activeForwarders[k].process(c);q&&a.Logger.verbose(q);}}}},this.callSetUserAttributeOnForwarders=function(c,d){b&&b.isAttributeKeyBlocked(c)||a._Store.activeForwarders.length&&a._Store.activeForwarders.forEach(function(b){if(b.setUserAttribute&&b.userAttributeFilters&&!a._Helpers.inArray(b.userAttributeFilters,a._Helpers.generateHash(c)))try{var e=b.setUserAttribute(c,d);e&&a.Logger.verbose(e);}catch(b){a.Logger.error(b);}});},this.setForwarderUserIdentities=function(b){a._Store.activeForwarders.forEach(function(c){var d=a._Helpers.filterUserIdentities(b,c.userIdentityFilters);c.setUserIdentity&&d.forEach(function(b){var d=c.setUserIdentity(b.Identity,b.Type);d&&a.Logger.verbose(d);});});},this.setForwarderOnUserIdentified=function(c){a._Store.activeForwarders.forEach(function(d){var e=filteredMparticleUser(c.getMPID(),d,a,b);if(d.onUserIdentified){var f=d.onUserIdentified(e);f&&a.Logger.verbose(f);}});},this.setForwarderOnIdentityComplete=function(c,d){var e;a._Store.activeForwarders.forEach(function(f){var g=filteredMparticleUser(c.getMPID(),f,a,b);"identify"===d?f.onIdentifyComplete&&(e=f.onIdentifyComplete(g),e&&a.Logger.verbose(e)):"login"===d?f.onLoginComplete&&(e=f.onLoginComplete(g),e&&a.Logger.verbose(e)):"logout"===d?f.onLogoutComplete&&(e=f.onLogoutComplete(g),e&&a.Logger.verbose(e)):"modify"==d&&f.onModifyComplete&&(e=f.onModifyComplete(g),e&&a.Logger.verbose(e));});},this.getForwarderStatsQueue=function(){return a._Persistence.forwardingStatsBatches.forwardingStatsEventQueue},this.setForwarderStatsQueue=function(b){a._Persistence.forwardingStatsBatches.forwardingStatsEventQueue=b;},this.configureForwarder=function(b){var c=null,d=b,e={};// if there are kits inside of mpInstance._Store.SDKConfig.kits, then mParticle is self hosted
  for(var f in a._Helpers.isObject(a._Store.SDKConfig.kits)&&0<Object.keys(a._Store.SDKConfig.kits).length?e=a._Store.SDKConfig.kits:0<a._preInit.forwarderConstructors.length&&a._preInit.forwarderConstructors.forEach(function(a){e[a.name]=a;}),e)if(f===d.name&&(d.isDebug===a._Store.SDKConfig.isDevelopmentMode||d.isSandbox===a._Store.SDKConfig.isDevelopmentMode)){c=new e[f].constructor,c.id=d.moduleId,c.isSandbox=d.isDebug||d.isSandbox,c.hasSandbox="true"===d.hasDebugString,c.isVisible=d.isVisible,c.settings=d.settings,c.eventNameFilters=d.eventNameFilters,c.eventTypeFilters=d.eventTypeFilters,c.attributeFilters=d.attributeFilters,c.screenNameFilters=d.screenNameFilters,c.screenNameFilters=d.screenNameFilters,c.pageViewAttributeFilters=d.pageViewAttributeFilters,c.userIdentityFilters=d.userIdentityFilters,c.userAttributeFilters=d.userAttributeFilters,c.filteringEventAttributeValue=d.filteringEventAttributeValue,c.filteringUserAttributeValue=d.filteringUserAttributeValue,c.eventSubscriptionId=d.eventSubscriptionId,c.filteringConsentRuleValues=d.filteringConsentRuleValues,c.excludeAnonymousUser=d.excludeAnonymousUser,a._Store.configuredForwarders.push(c);break}},this.configurePixel=function(b){(b.isDebug===a._Store.SDKConfig.isDevelopmentMode||b.isProduction!==a._Store.SDKConfig.isDevelopmentMode)&&a._Store.pixelConfigurations.push(b);},this.processForwarders=function(b,d){if(!b)a.Logger.warning("No config was passed. Cannot process forwarders");else try{Array.isArray(b.kitConfigs)&&b.kitConfigs.length&&b.kitConfigs.forEach(function(a){c.configureForwarder(a);}),Array.isArray(b.pixelConfigs)&&b.pixelConfigs.length&&b.pixelConfigs.forEach(function(a){c.configurePixel(a);}),c.initForwarders(a._Store.SDKConfig.identifyRequest.userIdentities,d);}catch(b){a.Logger.error("Config was not parsed propertly. Forwarders may not be initialized.");}};}

  var MessageType$1=Types.MessageType,ApplicationTransitionType$1=Types.ApplicationTransitionType;function ServerModel(a){function b(a,b){var c=[];for(var d in b.flags={},a.CustomFlags)c=[],a.CustomFlags.hasOwnProperty(d)&&(Array.isArray(a.CustomFlags[d])?a.CustomFlags[d].forEach(function(a){("number"==typeof a||"string"==typeof a||"boolean"==typeof a)&&c.push(a.toString());}):("number"==typeof a.CustomFlags[d]||"string"==typeof a.CustomFlags[d]||"boolean"==typeof a.CustomFlags[d])&&c.push(a.CustomFlags[d].toString()),c.length&&(b.flags[d]=c));}function c(a){return a?a.map(function(a){return d(a)}):[]}function d(b){return {id:a._Helpers.parseStringOrNumber(b.Sku),nm:a._Helpers.parseStringOrNumber(b.Name),pr:a._Helpers.parseNumber(b.Price),qt:a._Helpers.parseNumber(b.Quantity),br:a._Helpers.parseStringOrNumber(b.Brand),va:a._Helpers.parseStringOrNumber(b.Variant),ca:a._Helpers.parseStringOrNumber(b.Category),ps:a._Helpers.parseNumber(b.Position),cc:a._Helpers.parseStringOrNumber(b.CouponCode),tpa:a._Helpers.parseNumber(b.TotalAmount),attrs:b.Attributes}}var e=this;this.appendUserInfo=function(b,c){if(c){if(!b)return c.MPID=null,c.ConsentState=null,c.UserAttributes=null,void(c.UserIdentities=null);if(!(c.MPID&&c.MPID===b.getMPID())){c.MPID=b.getMPID(),c.ConsentState=b.getConsentState(),c.UserAttributes=b.getAllUserAttributes();var d=b.getUserIdentities().userIdentities,e={};for(var f in d){var g=Types.IdentityType.getIdentityType(f);!1!==g&&(e[g]=d[f]);}var h=[];if(a._Helpers.isObject(e)&&Object.keys(e).length)for(var i in e){var j={};j.Identity=e[i],j.Type=a._Helpers.parseNumber(i),h.push(j);}c.UserIdentities=h;}}},this.convertToConsentStateDTO=function(a){if(!a)return null;var b={},c=a.getGDPRConsentState();if(c){var d={};for(var e in b.gdpr=d,c)if(c.hasOwnProperty(e)){var f=c[e];b.gdpr[e]={},"boolean"==typeof f.Consented&&(d[e].c=f.Consented),"number"==typeof f.Timestamp&&(d[e].ts=f.Timestamp),"string"==typeof f.ConsentDocument&&(d[e].d=f.ConsentDocument),"string"==typeof f.Location&&(d[e].l=f.Location),"string"==typeof f.HardwareId&&(d[e].h=f.HardwareId);}}var g=a.getCCPAConsentState();return g&&(b.ccpa={data_sale_opt_out:{c:g.Consented,ts:g.Timestamp,d:g.ConsentDocument,l:g.Location,h:g.HardwareId}}),b},this.createEventObject=function(b,c){var d={},f={},g=b.messageType===Types.MessageType.OptOut?!a._Store.isEnabled:null;if(a._Store.sessionId||b.messageType==Types.MessageType.OptOut||a._Store.webviewBridgeEnabled){f=b.hasOwnProperty("toEventAPIObject")?b.toEventAPIObject():{EventName:b.name||b.messageType,EventCategory:b.eventType,EventAttributes:a._Helpers.sanitizeAttributes(b.data,b.name),EventDataType:b.messageType,CustomFlags:b.customFlags||{},UserAttributeChanges:b.userAttributeChanges,UserIdentityChanges:b.userIdentityChanges},b.messageType!==Types.MessageType.SessionEnd&&(a._Store.dateLastEventSent=new Date),d={Store:a._Store.serverSettings,SDKVersion:Constants.sdkVersion,SessionId:a._Store.sessionId,SessionStartDate:a._Store.sessionStartDate?a._Store.sessionStartDate.getTime():null,Debug:a._Store.SDKConfig.isDevelopmentMode,Location:a._Store.currentPosition,OptOut:g,ExpandedEventCount:0,AppVersion:a.getAppVersion(),AppName:a.getAppName(),ClientGeneratedId:a._Store.clientId,DeviceId:a._Store.deviceId,IntegrationAttributes:a._Store.integrationAttributes,CurrencyCode:a._Store.currencyCode,DataPlan:a._Store.SDKConfig.dataPlan?a._Store.SDKConfig.dataPlan:{}},f.CurrencyCode=a._Store.currencyCode;var h=c||a.Identity.getCurrentUser();return e.appendUserInfo(h,f),b.messageType===Types.MessageType.SessionEnd&&(f.SessionLength=a._Store.dateLastEventSent.getTime()-a._Store.sessionStartDate.getTime(),f.currentSessionMPIDs=a._Store.currentSessionMPIDs,f.EventAttributes=a._Store.sessionAttributes,a._Store.currentSessionMPIDs=[],a._Store.sessionStartDate=null),d.Timestamp=a._Store.dateLastEventSent.getTime(),a._Helpers.extend({},f,d)}return null},this.convertEventToDTO=function(d,f){var g={n:d.EventName,et:d.EventCategory,ua:d.UserAttributes,ui:d.UserIdentities,ia:d.IntegrationAttributes,str:d.Store,attrs:d.EventAttributes,sdk:d.SDKVersion,sid:d.SessionId,sl:d.SessionLength,ssd:d.SessionStartDate,dt:d.EventDataType,dbg:d.Debug,ct:d.Timestamp,lc:d.Location,o:d.OptOut,eec:d.ExpandedEventCount,av:d.AppVersion,cgid:d.ClientGeneratedId,das:d.DeviceId,mpid:d.MPID,smpids:d.currentSessionMPIDs};d.DataPlan&&d.DataPlan.PlanId&&(g.dp_id=d.DataPlan.PlanId,d.DataPlan.PlanVersion&&(g.dp_v=d.DataPlan.PlanVersion));var h=e.convertToConsentStateDTO(d.ConsentState);return h&&(g.con=h),d.EventDataType===MessageType$1.AppStateTransition&&(g.fr=f,g.iu=!1,g.at=ApplicationTransitionType$1.AppInit,g.lr=window.location.href||null,g.attrs=null),d.CustomFlags&&b(d,g),d.EventDataType===MessageType$1.Commerce?(g.cu=d.CurrencyCode,d.ShoppingCart&&(g.sc={pl:c(d.ShoppingCart.ProductList)}),d.ProductAction?g.pd={an:d.ProductAction.ProductActionType,cs:a._Helpers.parseNumber(d.ProductAction.CheckoutStep),co:d.ProductAction.CheckoutOptions,pl:c(d.ProductAction.ProductList),ti:d.ProductAction.TransactionId,ta:d.ProductAction.Affiliation,tcc:d.ProductAction.CouponCode,tr:a._Helpers.parseNumber(d.ProductAction.TotalAmount),ts:a._Helpers.parseNumber(d.ProductAction.ShippingAmount),tt:a._Helpers.parseNumber(d.ProductAction.TaxAmount)}:d.PromotionAction?g.pm={an:d.PromotionAction.PromotionActionType,pl:d.PromotionAction.PromotionList.map(function(a){return {id:a.Id,nm:a.Name,cr:a.Creative,ps:a.Position?a.Position:0}})}:d.ProductImpressions&&(g.pi=d.ProductImpressions.map(function(a){return {pil:a.ProductImpressionList,pl:c(a.ProductList)}}))):d.EventDataType===MessageType$1.Profile&&(g.pet=d.ProfileMessageType),g};}

  function forwardingStatsUploader(a){function b(){var b=a._Forwarders.getForwarderStatsQueue(),c=a._Persistence.forwardingStatsBatches.uploadsTable,d=Date.now();for(var e in b.length&&(c[d]={uploading:!1,data:b},a._Forwarders.setForwarderStatsQueue([])),c)(function(b){if(c.hasOwnProperty(b)&&!1===c[b].uploading){var d=function(){4===e.readyState&&(200===e.status||202===e.status?(a.Logger.verbose("Successfully sent  "+e.statusText+" from server"),delete c[b]):"4"===e.status.toString()[0]?429!==e.status&&delete c[b]:c[b].uploading=!1);},e=a._Helpers.createXHR(d),f=c[b].data;c[b].uploading=!0,a._APIClient.sendBatchForwardingStatsToServer(f,e);}})(e);}this.startForwardingStatsTimer=function(){mParticle._forwardingStatsTimer=setInterval(function(){b();},a._Store.SDKConfig.forwarderStatsTimeout);};}

  var Messages$7=Constants.Messages,HTTPCodes=Constants.HTTPCodes;function Identity(t){var s=this;/**
       * Invoke these methods on the mParticle.Identity object.
       * Example: mParticle.Identity.getCurrentUser().
       * @class mParticle.Identity
       */ /**
       * Invoke these methods on the mParticle.Identity.getCurrentUser() object.
       * Example: mParticle.Identity.getCurrentUser().getAllUserAttributes()
       * @class mParticle.Identity.getCurrentUser()
       */ /**
       * Invoke these methods on the mParticle.Identity.getCurrentUser().getCart() object.
       * Example: mParticle.Identity.getCurrentUser().getCart().add(...);
       * @class mParticle.Identity.getCurrentUser().getCart()
       * @deprecated
       */ // send a user identity change request on identify, login, logout, modify when any values change.
  // compare what identities exist vs what is previously was for the specific user if they were in memory before.
  // if it's the first time the user is logging in, send a user identity change request with
  this.checkIdentitySwap=function(e,s,r){if(e&&s&&e!==s){var i=t._Persistence.getPersistence();i&&(i.cu=s,i.gs.csm=r,t._Persistence.savePersistence(i));}},this.IdentityRequest={createKnownIdentities:function createKnownIdentities(e,s){var r={};if(e&&e.userIdentities&&t._Helpers.isObject(e.userIdentities))for(var i in e.userIdentities)r[i]=e.userIdentities[i];return r.device_application_stamp=s,r},preProcessIdentityRequest:function preProcessIdentityRequest(e,s,r){t.Logger.verbose(Messages$7.InformationMessages.StartingLogEvent+": "+r);var i=t._Helpers.Validators.validateIdentities(e,r);if(!i.valid)return t.Logger.error("ERROR: "+i.error),{valid:!1,error:i.error};if(s&&!t._Helpers.Validators.isFunction(s)){var n="The optional callback must be a function. You tried entering a(n) "+_typeof_1(s);return t.Logger.error(n),{valid:!1,error:n}}return {valid:!0}},createIdentityRequest:function createIdentityRequest(e,s,r,i,n,o,a){var d={client_sdk:{platform:s,sdk_vendor:r,sdk_version:i},context:o,environment:t._Store.SDKConfig.isDevelopmentMode?"development":"production",request_id:t._Helpers.generateUniqueId(),request_timestamp_ms:new Date().getTime(),previous_mpid:a||null,known_identities:this.createKnownIdentities(e,n)};return d},createModifyIdentityRequest:function createModifyIdentityRequest(e,s,r,i,n,o){return {client_sdk:{platform:r,sdk_vendor:i,sdk_version:n},context:o,environment:t._Store.SDKConfig.isDevelopmentMode?"development":"production",request_id:t._Helpers.generateUniqueId(),request_timestamp_ms:new Date().getTime(),identity_changes:this.createIdentityChanges(e,s)}},createIdentityChanges:function createIdentityChanges(e,s){var r,i=[];if(s&&t._Helpers.isObject(s)&&e&&t._Helpers.isObject(e))for(r in s)i.push({old_value:e[r]||null,new_value:s[r],identity_type:r});return i},// takes 2 UI objects keyed by name, combines them, returns them keyed by type
  combineUserIdentities:function combineUserIdentities(e,s){var r={},i=t._Helpers.extend(e,s);for(var n in i){var o=Types.IdentityType.getIdentityType(n);// this check removes anything that is not whitelisted as an identity type
  !1!==o&&0<=o&&(r[Types.IdentityType.getIdentityType(n)]=i[n]);}return r},createAliasNetworkRequest:function createAliasNetworkRequest(e){return {request_id:t._Helpers.generateUniqueId(),request_type:"alias",environment:t._Store.SDKConfig.isDevelopmentMode?"development":"production",api_key:t._Store.devToken,data:{destination_mpid:e.destinationMpid,source_mpid:e.sourceMpid,start_unixtime_ms:e.startTime,end_unixtime_ms:e.endTime,device_application_stamp:t._Store.deviceId}}},convertAliasToNative:function convertAliasToNative(e){return {DestinationMpid:e.destinationMpid,SourceMpid:e.sourceMpid,StartUnixtimeMs:e.startTime,EndUnixtimeMs:e.endTime}},convertToNative:function convertToNative(e){var t=[];if(e&&e.userIdentities){for(var s in e.userIdentities)e.userIdentities.hasOwnProperty(s)&&t.push({Type:Types.IdentityType.getIdentityType(s),Identity:e.userIdentities[s]});return {UserIdentities:t}}}},this.IdentityAPI={HTTPCodes:HTTPCodes,/**
           * Initiate a logout request to the mParticle server
           * @method identify
           * @param {Object} identityApiData The identityApiData object as indicated [here](https://github.com/mParticle/mparticle-sdk-javascript/blob/master-v2/README.md#1-customize-the-sdk)
           * @param {Function} [callback] A callback function that is called when the identify request completes
           */identify:function identify(e,r){var i,n=t.Identity.getCurrentUser(),o=t._Identity.IdentityRequest.preProcessIdentityRequest(e,r,"identify");if(n&&(i=n.getMPID()),o.valid){var a=t._Identity.IdentityRequest.createIdentityRequest(e,Constants.platform,Constants.sdkVendor,Constants.sdkVersion,t._Store.deviceId,t._Store.context,i);t._Helpers.canLog()?t._Store.webviewBridgeEnabled?(t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.Identify,JSON.stringify(t._Identity.IdentityRequest.convertToNative(e))),t._Helpers.invokeCallback(r,HTTPCodes.nativeIdentityRequest,"Identify request sent to native sdk")):t._IdentityAPIClient.sendIdentityRequest(a,"identify",r,e,s.parseIdentityResponse,i):(t._Helpers.invokeCallback(r,HTTPCodes.loggingDisabledOrMissingAPIKey,Messages$7.InformationMessages.AbandonLogEvent),t.Logger.verbose(Messages$7.InformationMessages.AbandonLogEvent));}else t._Helpers.invokeCallback(r,HTTPCodes.validationIssue,o.error),t.Logger.verbose(o);},/**
           * Initiate a logout request to the mParticle server
           * @method logout
           * @param {Object} identityApiData The identityApiData object as indicated [here](https://github.com/mParticle/mparticle-sdk-javascript/blob/master-v2/README.md#1-customize-the-sdk)
           * @param {Function} [callback] A callback function that is called when the logout request completes
           */logout:function logout(e,r){var i,n=t.Identity.getCurrentUser(),o=t._Identity.IdentityRequest.preProcessIdentityRequest(e,r,"logout");if(n&&(i=n.getMPID()),o.valid){var a,d=t._Identity.IdentityRequest.createIdentityRequest(e,Constants.platform,Constants.sdkVendor,Constants.sdkVersion,t._Store.deviceId,t._Store.context,i);t._Helpers.canLog()?t._Store.webviewBridgeEnabled?(t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.Logout,JSON.stringify(t._Identity.IdentityRequest.convertToNative(e))),t._Helpers.invokeCallback(r,HTTPCodes.nativeIdentityRequest,"Logout request sent to native sdk")):(t._IdentityAPIClient.sendIdentityRequest(d,"logout",r,e,s.parseIdentityResponse,i),a=t._ServerModel.createEventObject({messageType:Types.MessageType.Profile}),a.ProfileMessageType=Types.ProfileMessageType.Logout,t._Store.activeForwarders.length&&t._Store.activeForwarders.forEach(function(e){e.logOut&&e.logOut(a);})):(t._Helpers.invokeCallback(r,HTTPCodes.loggingDisabledOrMissingAPIKey,Messages$7.InformationMessages.AbandonLogEvent),t.Logger.verbose(Messages$7.InformationMessages.AbandonLogEvent));}else t._Helpers.invokeCallback(r,HTTPCodes.validationIssue,o.error),t.Logger.verbose(o);},/**
           * Initiate a login request to the mParticle server
           * @method login
           * @param {Object} identityApiData The identityApiData object as indicated [here](https://github.com/mParticle/mparticle-sdk-javascript/blob/master-v2/README.md#1-customize-the-sdk)
           * @param {Function} [callback] A callback function that is called when the login request completes
           */login:function login(e,r){var i,n=t.Identity.getCurrentUser(),o=t._Identity.IdentityRequest.preProcessIdentityRequest(e,r,"login");if(n&&(i=n.getMPID()),o.valid){var a=t._Identity.IdentityRequest.createIdentityRequest(e,Constants.platform,Constants.sdkVendor,Constants.sdkVersion,t._Store.deviceId,t._Store.context,i);t._Helpers.canLog()?t._Store.webviewBridgeEnabled?(t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.Login,JSON.stringify(t._Identity.IdentityRequest.convertToNative(e))),t._Helpers.invokeCallback(r,HTTPCodes.nativeIdentityRequest,"Login request sent to native sdk")):t._IdentityAPIClient.sendIdentityRequest(a,"login",r,e,s.parseIdentityResponse,i):(t._Helpers.invokeCallback(r,HTTPCodes.loggingDisabledOrMissingAPIKey,Messages$7.InformationMessages.AbandonLogEvent),t.Logger.verbose(Messages$7.InformationMessages.AbandonLogEvent));}else t._Helpers.invokeCallback(r,HTTPCodes.validationIssue,o.error),t.Logger.verbose(o);},/**
           * Initiate a modify request to the mParticle server
           * @method modify
           * @param {Object} identityApiData The identityApiData object as indicated [here](https://github.com/mParticle/mparticle-sdk-javascript/blob/master-v2/README.md#1-customize-the-sdk)
           * @param {Function} [callback] A callback function that is called when the modify request completes
           */modify:function modify(e,r){var i,n=t.Identity.getCurrentUser(),o=t._Identity.IdentityRequest.preProcessIdentityRequest(e,r,"modify");n&&(i=n.getMPID());var a=e&&e.userIdentities?e.userIdentities:{};if(o.valid){var d=t._Identity.IdentityRequest.createModifyIdentityRequest(n?n.getUserIdentities().userIdentities:{},a,Constants.platform,Constants.sdkVendor,Constants.sdkVersion,t._Store.context);t._Helpers.canLog()?t._Store.webviewBridgeEnabled?(t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.Modify,JSON.stringify(t._Identity.IdentityRequest.convertToNative(e))),t._Helpers.invokeCallback(r,HTTPCodes.nativeIdentityRequest,"Modify request sent to native sdk")):t._IdentityAPIClient.sendIdentityRequest(d,"modify",r,e,s.parseIdentityResponse,i):(t._Helpers.invokeCallback(r,HTTPCodes.loggingDisabledOrMissingAPIKey,Messages$7.InformationMessages.AbandonLogEvent),t.Logger.verbose(Messages$7.InformationMessages.AbandonLogEvent));}else t._Helpers.invokeCallback(r,HTTPCodes.validationIssue,o.error),t.Logger.verbose(o);},/**
           * Returns a user object with methods to interact with the current user
           * @method getCurrentUser
           * @return {Object} the current user object
           */getCurrentUser:function getCurrentUser(){var e;return t._Store?(e=t._Store.mpid,e?(e=t._Store.mpid.slice(),s.mParticleUser(e,t._Store.isLoggedIn)):t._Store.webviewBridgeEnabled?s.mParticleUser():null):null},/**
           * Returns a the user object associated with the mpid parameter or 'null' if no such
           * user exists
           * @method getUser
           * @param {String} mpid of the desired user
           * @return {Object} the user for  mpid
           */getUser:function getUser(e){var r=t._Persistence.getPersistence();return r?r[e]&&!Constants.SDKv2NonMPIDCookieKeys.hasOwnProperty(e)?s.mParticleUser(e):null:null},/**
           * Returns all users, including the current user and all previous users that are stored on the device.
           * @method getUsers
           * @return {Array} array of users
           */getUsers:function getUsers(){var e=t._Persistence.getPersistence(),r=[];if(e)for(var i in e)Constants.SDKv2NonMPIDCookieKeys.hasOwnProperty(i)||r.push(s.mParticleUser(i));return r.sort(function(e,t){var s=e.getLastSeenTime()||0,r=t.getLastSeenTime()||0;return s>r?-1:1}),r},/**
           * Initiate an alias request to the mParticle server
           * @method aliasUsers
           * @param {Object} aliasRequest  object representing an AliasRequest
           * @param {Function} [callback] A callback function that is called when the aliasUsers request completes
           */aliasUsers:function aliasUsers(e,s){var r;if(e.destinationMpid&&e.sourceMpid||(r=Messages$7.ValidationMessages.AliasMissingMpid),e.destinationMpid===e.sourceMpid&&(r=Messages$7.ValidationMessages.AliasNonUniqueMpid),e.startTime&&e.endTime||(r=Messages$7.ValidationMessages.AliasMissingTime),e.startTime>e.endTime&&(r=Messages$7.ValidationMessages.AliasStartBeforeEndTime),r)return t.Logger.warning(r),void t._Helpers.invokeAliasCallback(s,HTTPCodes.validationIssue,r);if(!t._Helpers.canLog())t._Helpers.invokeAliasCallback(s,HTTPCodes.loggingDisabledOrMissingAPIKey,Messages$7.InformationMessages.AbandonAliasUsers),t.Logger.verbose(Messages$7.InformationMessages.AbandonAliasUsers);else if(t._Store.webviewBridgeEnabled)t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.Alias,JSON.stringify(t._Identity.IdentityRequest.convertAliasToNative(e))),t._Helpers.invokeAliasCallback(s,HTTPCodes.nativeIdentityRequest,"Alias request sent to native sdk");else {t.Logger.verbose(Messages$7.InformationMessages.StartingAliasRequest+": "+e.sourceMpid+" -> "+e.destinationMpid);var i=t._Identity.IdentityRequest.createAliasNetworkRequest(e);t._IdentityAPIClient.sendAliasRequest(i,s);}},/**
           Create a default AliasRequest for 2 MParticleUsers. This will construct the request
          using the sourceUser's firstSeenTime as the startTime, and its lastSeenTime as the endTime.
          
          In the unlikely scenario that the sourceUser does not have a firstSeenTime, which will only
          be the case if they have not been the current user since this functionality was added, the 
          startTime will be populated with the earliest firstSeenTime out of any stored user. Similarly,
          if the sourceUser does not have a lastSeenTime, the endTime will be populated with the current time
          
          There is a limit to how old the startTime can be, represented by the config field 'aliasMaxWindow', in days.
          If the startTime falls before the limit, it will be adjusted to the oldest allowed startTime. 
          In rare cases, where the sourceUser's lastSeenTime also falls outside of the aliasMaxWindow limit, 
          after applying this adjustment it will be impossible to create an aliasRequest passes the aliasUsers() 
          validation that the startTime must be less than the endTime 
          */createAliasRequest:function createAliasRequest(e,s){try{if(!s||!e)return t.Logger.error("'destinationUser' and 'sourceUser' must both be present"),null;var r=e.getFirstSeenTime();r||t.Identity.getUsers().forEach(function(e){e.getFirstSeenTime()&&(!r||e.getFirstSeenTime()<r)&&(r=e.getFirstSeenTime());});var i=new Date().getTime()-1e3*(60*(60*(24*t._Store.SDKConfig.aliasMaxWindow))),n=e.getLastSeenTime()||new Date().getTime();return r<i&&(r=i,n<r&&t.Logger.warning("Source User has not been seen in the last "+t._Store.SDKConfig.maxAliasWindow+" days, Alias Request will likely fail")),{destinationMpid:s.getMPID(),sourceMpid:e.getMPID(),startTime:r,endTime:n}}catch(s){return t.Logger.error("There was a problem with creating an alias request: "+s),null}}},this.mParticleUser=function(e,s){var r=this;return {/**
               * Get user identities for current user
               * @method getUserIdentities
               * @return {Object} an object with userIdentities as its key
               */getUserIdentities:function getUserIdentities(){var s={},r=t._Persistence.getUserIdentities(e);for(var i in r)r.hasOwnProperty(i)&&(s[Types.IdentityType.getIdentityName(t._Helpers.parseNumber(i))]=r[i]);return {userIdentities:s}},/**
               * Get the MPID of the current user
               * @method getMPID
               * @return {String} the current user MPID as a string
               */getMPID:function getMPID(){return e},/**
               * Sets a user tag
               * @method setUserTag
               * @param {String} tagName
               */setUserTag:function setUserTag(e){return t._Helpers.Validators.isValidKeyValue(e)?void this.setUserAttribute(e,null):void t.Logger.error(Messages$7.ErrorMessages.BadKey)},/**
               * Removes a user tag
               * @method removeUserTag
               * @param {String} tagName
               */removeUserTag:function removeUserTag(e){return t._Helpers.Validators.isValidKeyValue(e)?void this.removeUserAttribute(e):void t.Logger.error(Messages$7.ErrorMessages.BadKey)},/**
               * Sets a user attribute
               * @method setUserAttribute
               * @param {String} key
               * @param {String} value
               */setUserAttribute:function setUserAttribute(s,i){var n,o,a,d;if(t._SessionManager.resetSessionTimer(),t._Helpers.canLog()){if(!t._Helpers.Validators.isValidAttributeValue(i))return void t.Logger.error(Messages$7.ErrorMessages.BadAttribute);if(!t._Helpers.Validators.isValidKeyValue(s))return void t.Logger.error(Messages$7.ErrorMessages.BadKey);if(t._Store.webviewBridgeEnabled)t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.SetUserAttribute,JSON.stringify({key:s,value:i}));else {n=t._Persistence.getPersistence(),o=this.getAllUserAttributes();var g=t._Helpers.findKeyInObject(o,s);g?(d=!1,a=o[g],delete o[g]):d=!0,o[s]=i,n&&n[e]&&(n[e].ua=o,t._Persistence.savePersistence(n,e)),r.sendUserAttributeChangeEvent(s,i,a,d,!1,this),t._Forwarders.initForwarders(r.IdentityAPI.getCurrentUser().getUserIdentities(),t._APIClient.prepareForwardingStats),t._Forwarders.callSetUserAttributeOnForwarders(s,i);}}},/**
               * Set multiple user attributes
               * @method setUserAttributes
               * @param {Object} user attribute object with keys of the attribute type, and value of the attribute value
               */setUserAttributes:function setUserAttributes(e){if(t._SessionManager.resetSessionTimer(),!t._Helpers.isObject(e))t.Logger.error("Must pass an object into setUserAttributes. You passed a "+_typeof_1(e));else if(t._Helpers.canLog())for(var s in e)e.hasOwnProperty(s)&&this.setUserAttribute(s,e[s]);},/**
               * Removes a specific user attribute
               * @method removeUserAttribute
               * @param {String} key
               */removeUserAttribute:function removeUserAttribute(s){var i,n;if(t._SessionManager.resetSessionTimer(),!t._Helpers.Validators.isValidKeyValue(s))return void t.Logger.error(Messages$7.ErrorMessages.BadKey);if(t._Store.webviewBridgeEnabled)t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.RemoveUserAttribute,JSON.stringify({key:s,value:null}));else {i=t._Persistence.getPersistence(),n=this.getAllUserAttributes();var o=t._Helpers.findKeyInObject(n,s);o&&(s=o);var a=n[s]?n[s].toString():null;delete n[s],i&&i[e]&&(i[e].ua=n,t._Persistence.savePersistence(i,e)),r.sendUserAttributeChangeEvent(s,null,a,!1,!0,this),t._Forwarders.initForwarders(r.IdentityAPI.getCurrentUser().getUserIdentities(),t._APIClient.prepareForwardingStats),t._Forwarders.applyToForwarders("removeUserAttribute",s);}},/**
               * Sets a list of user attributes
               * @method setUserAttributeList
               * @param {String} key
               * @param {Array} value an array of values
               */setUserAttributeList:function setUserAttributeList(s,n){var o,a,d,g,l;if(t._SessionManager.resetSessionTimer(),!t._Helpers.Validators.isValidKeyValue(s))return void t.Logger.error(Messages$7.ErrorMessages.BadKey);if(!Array.isArray(n))return void t.Logger.error("The value you passed in to setUserAttributeList must be an array. You passed in a "+("undefined"==typeof value?"undefined":_typeof_1(value)));var u=n.slice();if(t._Store.webviewBridgeEnabled)t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.SetUserAttributeList,JSON.stringify({key:s,value:u}));else {o=t._Persistence.getPersistence(),a=this.getAllUserAttributes();var p=t._Helpers.findKeyInObject(a,s);if(p?(g=!1,d=a[p],delete a[p]):g=!0,a[s]=u,o&&o[e]&&(o[e].ua=a,t._Persistence.savePersistence(o,e)),t._APIClient.shouldEnableBatching()){// If the new attributeList length is different previous, then there is a change event.
  // Loop through new attributes list, see if they are all in the same index as previous user attributes list
  // If there are any changes, break, and immediately send a userAttributeChangeEvent with full array as a value
  if(!d||!Array.isArray(d))l=!0;else if(n.length!==d.length)l=!0;else for(var c=0;c<n.length;c++)if(d[c]!==n[c]){l=!0;break}l&&r.sendUserAttributeChangeEvent(s,n,d,g,!1,this);}t._Forwarders.initForwarders(r.IdentityAPI.getCurrentUser().getUserIdentities(),t._APIClient.prepareForwardingStats),t._Forwarders.callSetUserAttributeOnForwarders(s,u);}},/**
               * Removes all user attributes
               * @method removeAllUserAttributes
               */removeAllUserAttributes:function removeAllUserAttributes(){var e;if(t._SessionManager.resetSessionTimer(),t._Store.webviewBridgeEnabled)t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.RemoveAllUserAttributes);else if(e=this.getAllUserAttributes(),t._Forwarders.initForwarders(r.IdentityAPI.getCurrentUser().getUserIdentities(),t._APIClient.prepareForwardingStats),e)for(var s in e)e.hasOwnProperty(s)&&t._Forwarders.applyToForwarders("removeUserAttribute",s),this.removeUserAttribute(s);},/**
               * Returns all user attribute keys that have values that are arrays
               * @method getUserAttributesLists
               * @return {Object} an object of only keys with array values. Example: { attr1: [1, 2, 3], attr2: ['a', 'b', 'c'] }
               */getUserAttributesLists:function getUserAttributesLists(){var e,t={};for(var s in e=this.getAllUserAttributes(),e)e.hasOwnProperty(s)&&Array.isArray(e[s])&&(t[s]=e[s].slice());return t},/**
               * Returns all user attributes
               * @method getAllUserAttributes
               * @return {Object} an object of all user attributes. Example: { attr1: 'value1', attr2: ['a', 'b', 'c'] }
               */getAllUserAttributes:function getAllUserAttributes(){var s={},r=t._Persistence.getAllUserAttributes(e);if(r)for(var i in r)r.hasOwnProperty(i)&&(s[i]=Array.isArray(r[i])?r[i].slice():r[i]);return s},/**
               * Returns the cart object for the current user
               * @method getCart
               * @return a cart object
               */getCart:function getCart(){return t.Logger.warning("Deprecated function Identity.getCurrentUser().getCart() will be removed in future releases"),r.mParticleUserCart(e)},/**
               * Returns the Consent State stored locally for this user.
               * @method getConsentState
               * @return a ConsentState object
               */getConsentState:function getConsentState(){return t._Persistence.getConsentState(e)},/**
               * Sets the Consent State stored locally for this user.
               * @method setConsentState
               * @param {Object} consent state
               */setConsentState:function setConsentState(s){t._Persistence.saveUserConsentStateToCookies(e,s),t._Forwarders.initForwarders(this.getUserIdentities().userIdentities,t._APIClient.prepareForwardingStats);},isLoggedIn:function isLoggedIn(){return s},getLastSeenTime:function getLastSeenTime(){return t._Persistence.getLastSeenTime(e)},getFirstSeenTime:function getFirstSeenTime(){return t._Persistence.getFirstSeenTime(e)}}},this.mParticleUserCart=function(e){return {/**
               * Adds a cart product to the user cart
               * @method add
               * @param {Object} product the product
               * @param {Boolean} [logEvent] a boolean to log adding of the cart object. If blank, no logging occurs.
               * @deprecated
               */add:function add(s,r){t.Logger.warning("Deprecated function Identity.getCurrentUser().getCart().add() will be removed in future releases");var i,n,o;if(o=Array.isArray(s)?s.slice():[s],o.forEach(function(e){e.Attributes=t._Helpers.sanitizeAttributes(e.Attributes);}),t._Store.webviewBridgeEnabled)t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.AddToCart,JSON.stringify(o));else {t._SessionManager.resetSessionTimer(),n=t._Persistence.getUserProductsFromLS(e),n=n.concat(o),!0===r&&t._Events.logProductActionEvent(Types.ProductActionType.AddToCart,o);n.length>t._Store.SDKConfig.maxProducts&&(t.Logger.verbose("The cart contains "+n.length+" items. Only "+t._Store.SDKConfig.maxProducts+" can currently be saved in cookies."),n=n.slice(-t._Store.SDKConfig.maxProducts)),i=t._Persistence.getAllUserProductsFromLS(),i[e].cp=n,t._Persistence.setCartProducts(i);}},/**
               * Removes a cart product from the current user cart
               * @method remove
               * @param {Object} product the product
               * @param {Boolean} [logEvent] a boolean to log adding of the cart object. If blank, no logging occurs.
               * @deprecated
               */remove:function remove(s,r){t.Logger.warning("Deprecated function Identity.getCurrentUser().getCart().remove() will be removed in future releases");var i,n,o=-1,a=null;if(t._Store.webviewBridgeEnabled)t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.RemoveFromCart,JSON.stringify(s));else {t._SessionManager.resetSessionTimer(),n=t._Persistence.getUserProductsFromLS(e),n&&(n.forEach(function(e,t){e.Sku===s.Sku&&(o=t,a=e);}),-1<o&&(n.splice(o,1),!0===r&&t._Events.logProductActionEvent(Types.ProductActionType.RemoveFromCart,a)));i=t._Persistence.getAllUserProductsFromLS(),i[e].cp=n,t._Persistence.setCartProducts(i);}},/**
               * Clears the user's cart
               * @method clear
               * @deprecated
               */clear:function clear(){t.Logger.warning("Deprecated function Identity.getCurrentUser().getCart().clear() will be removed in future releases");var s;t._Store.webviewBridgeEnabled?t._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.ClearCart):(t._SessionManager.resetSessionTimer(),s=t._Persistence.getAllUserProductsFromLS(),s&&s[e]&&s[e].cp&&(s[e].cp=[],s[e].cp=[],t._Persistence.setCartProducts(s)));},/**
               * Returns all cart products
               * @method getCartProducts
               * @return {Array} array of cart products
               * @deprecated
               */getCartProducts:function getCartProducts(){return t.Logger.warning("Deprecated function Identity.getCurrentUser().getCart().getCartProducts() will be removed in future releases"),t._Persistence.getCartProducts(e)}}},this.parseIdentityResponse=function(r,i,n,o,a){var d,g,l,u=t.Identity.getUser(i),p={},c=u?u.getUserIdentities().userIdentities:{},y=t._Helpers.extend({},c);t._Store.identityCallInFlight=!1;try{if(t.Logger.verbose("Parsing \""+a+"\" identity response from server"),r.responseText&&(g=JSON.parse(r.responseText),g.hasOwnProperty("is_logged_in")&&(t._Store.isLoggedIn=g.is_logged_in)),(!u||u.getMPID()&&g.mpid&&g.mpid!==u.getMPID())&&(t._Store.mpid=g.mpid,u&&t._Persistence.setLastSeenTime(i),t._Persistence.setFirstSeenTime(g.mpid)),200===r.status){if("modify"===a)p=t._Identity.IdentityRequest.combineUserIdentities(c,o.userIdentities),t._Persistence.saveUserIdentitiesToPersistence(i,p);else {var I=s.IdentityAPI.getUser(g.mpid),_=I?I.getUserIdentities().userIdentities:{},v=t._Helpers.extend({},_);//if there is any previous migration data
  if(t.Logger.verbose("Successfully parsed Identity Response"),"identify"==a&&u&&g.mpid===u.getMPID()&&t._Persistence.setFirstSeenTime(g.mpid),l=t._Store.currentSessionMPIDs.indexOf(g.mpid),t._Store.sessionId&&g.mpid&&i!==g.mpid&&0>l&&t._Store.currentSessionMPIDs.push(g.mpid),-1<l&&(t._Store.currentSessionMPIDs=t._Store.currentSessionMPIDs.slice(0,l).concat(t._Store.currentSessionMPIDs.slice(l+1,t._Store.currentSessionMPIDs.length)),t._Store.currentSessionMPIDs.push(g.mpid)),t._CookieSyncManager.attemptCookieSync(i,g.mpid),s.checkIdentitySwap(i,g.mpid,t._Store.currentSessionMPIDs),Object.keys(t._Store.migrationData).length){p=t._Store.migrationData.userIdentities||{};var m=t._Store.migrationData.userAttributes||{};t._Persistence.saveUserAttributesToPersistence(g.mpid,m);}else o&&o.userIdentities&&Object.keys(o.userIdentities).length&&(p=s.IdentityRequest.combineUserIdentities(_,o.userIdentities));t._Persistence.saveUserIdentitiesToPersistence(g.mpid,p),t._Persistence.update(),t._Persistence.findPrevCookiesBasedOnUI(o),t._Store.context=g.context||t._Store.context;}if(d=t.Identity.getCurrentUser(),o&&o.onUserAlias&&t._Helpers.Validators.isFunction(o.onUserAlias))try{t.Logger.warning("Deprecated function onUserAlias will be removed in future releases"),o.onUserAlias(u,d);}catch(s){t.Logger.error("There was an error with your onUserAlias function - "+s);}var P=t._Persistence.getPersistence();d&&(t._Persistence.storeDataInMemory(P,d.getMPID()),(!u||d.getMPID()!==u.getMPID()||u.isLoggedIn()!==d.isLoggedIn())&&t._Forwarders.initForwarders(d.getUserIdentities().userIdentities,t._APIClient.prepareForwardingStats),t._Forwarders.setForwarderUserIdentities(d.getUserIdentities().userIdentities),t._Forwarders.setForwarderOnIdentityComplete(d,a),t._Forwarders.setForwarderOnUserIdentified(d,a));var S={};for(var b in p)S[Types.IdentityType.getIdentityName(t._Helpers.parseNumber(b))]=p[b];s.sendUserIdentityChangeEvent(S,a,g.mpid,"modify"===a?y:v);}n?0===r.status?t._Helpers.invokeCallback(n,HTTPCodes.noHttpCoverage,g||null,d):t._Helpers.invokeCallback(n,r.status,g||null,d):g&&g.errors&&g.errors.length&&t.Logger.error("Received HTTP response code of "+r.status+" - "+g.errors[0].message),t._APIClient.processQueuedEvents();}catch(s){n&&t._Helpers.invokeCallback(n,r.status,g||null),t.Logger.error("Error parsing JSON response from Identity server: "+s);}},this.sendUserIdentityChangeEvent=function(e,r,i,n){var o,a;if(t._APIClient.shouldEnableBatching()&&(i||"modify"===r))for(var d in o=this.IdentityAPI.getUser(i),e)if(n[d]!==e[d]){var g=!n[d];a=s.createUserIdentityChange(d,e[d],n[d],g,o),t._APIClient.sendEventToServer(a);}},this.createUserIdentityChange=function(e,s,r,i,n){var o;return o=t._ServerModel.createEventObject({messageType:Types.MessageType.UserIdentityChange,userIdentityChanges:{New:{IdentityType:e,Identity:s,CreatedThisBatch:i},Old:{IdentityType:e,Identity:r,CreatedThisBatch:!1}},userInMemory:n}),o},this.sendUserAttributeChangeEvent=function(e,r,i,n,o,a){if(t._APIClient.shouldEnableBatching()){var d=s.createUserAttributeChange(e,r,i,n,o,a);d&&t._APIClient.sendEventToServer(d);}},this.createUserAttributeChange=function(e,s,r,i,n,o){r||(r=null);var a;return s!==r&&(a=t._ServerModel.createEventObject({messageType:Types.MessageType.UserAttributeChange,userAttributeChanges:{UserAttributeName:e,New:s,Old:r||null,Deleted:n,IsNewAttribute:i}},o)),a};}

  function Consent(a){var b=this,c="data_sale_opt_out";this.createPrivacyConsent=function(b,c,d,e,f){return "boolean"==typeof b?c&&isNaN(c)?(a.Logger.error("Timestamp must be a valid number when constructing a Consent object."),null):d&&"string"!=typeof d?(a.Logger.error("Document must be a valid string when constructing a Consent object."),null):e&&"string"!=typeof e?(a.Logger.error("Location must be a valid string when constructing a Consent object."),null):f&&"string"!=typeof f?(a.Logger.error("Hardware ID must be a valid string when constructing a Consent object."),null):{Consented:b,Timestamp:c||Date.now(),ConsentDocument:d,Location:e,HardwareId:f}:(a.Logger.error("Consented boolean is required when constructing a Consent object."),null)},this.ConsentSerialization={toMinifiedJsonObject:function toMinifiedJsonObject(a){var b={};if(a){var d=a.getGDPRConsentState();if(d)for(var e in b.gdpr={},d)if(d.hasOwnProperty(e)){var f=d[e];b.gdpr[e]={},"boolean"==typeof f.Consented&&(b.gdpr[e].c=f.Consented),"number"==typeof f.Timestamp&&(b.gdpr[e].ts=f.Timestamp),"string"==typeof f.ConsentDocument&&(b.gdpr[e].d=f.ConsentDocument),"string"==typeof f.Location&&(b.gdpr[e].l=f.Location),"string"==typeof f.HardwareId&&(b.gdpr[e].h=f.HardwareId);}var g=a.getCCPAConsentState();g&&(b.ccpa={},b.ccpa[c]={},"boolean"==typeof g.Consented&&(b.ccpa[c].c=g.Consented),"number"==typeof g.Timestamp&&(b.ccpa[c].ts=g.Timestamp),"string"==typeof g.ConsentDocument&&(b.ccpa[c].d=g.ConsentDocument),"string"==typeof g.Location&&(b.ccpa[c].l=g.Location),"string"==typeof g.HardwareId&&(b.ccpa[c].h=g.HardwareId));}return b},fromMinifiedJsonObject:function fromMinifiedJsonObject(a){var d=b.createConsentState();if(a.gdpr)for(var e in a.gdpr)if(a.gdpr.hasOwnProperty(e)){var f=b.createPrivacyConsent(a.gdpr[e].c,a.gdpr[e].ts,a.gdpr[e].d,a.gdpr[e].l,a.gdpr[e].h);d.addGDPRConsentState(e,f);}if(a.ccpa&&a.ccpa.hasOwnProperty(c)){var g=b.createPrivacyConsent(a.ccpa[c].c,a.ccpa[c].ts,a.ccpa[c].d,a.ccpa[c].l,a.ccpa[c].h);d.setCCPAConsentState(g);}return d}},this.createConsentState=function(d){function e(a){if("string"!=typeof a)return null;var b=a.trim();return b.length?b.toLowerCase():null}/**
           * Invoke these methods on a consent state object.
           * <p>
           * Usage: var consent = mParticle.Consent.createConsentState()
           * <br>
           * consent.setGDPRCoonsentState()
           *
           * @class Consent
           */ /**
           * Add a GDPR Consent State to the consent state object
           *
           * @method addGDPRConsentState
           * @param purpose [String] Data processing purpose that describes the type of processing done on the data subject’s data
           * @param gdprConsent [Object] A GDPR consent object created via mParticle.Consent.createGDPRConsent(...)
           */function f(c,d){var f=e(c);if(!f)return a.Logger.error("Purpose must be a string."),this;if(!a._Helpers.isObject(d))return a.Logger.error("Invoked with a bad or empty consent object."),this;var g=b.createPrivacyConsent(d.Consented,d.Timestamp,d.ConsentDocument,d.Location,d.HardwareId);return g&&(l[f]=g),this}function g(b){if(!b)l={};else if(a._Helpers.isObject(b))for(var c in l={},b)b.hasOwnProperty(c)&&f(c,b[c]);return this}/**
           * Remove a GDPR Consent State to the consent state object
           *
           * @method removeGDPRConsentState
           * @param purpose [String] Data processing purpose that describes the type of processing done on the data subject’s data
           */function h(a){var b=e(a);return b?(delete l[b],this):this}/**
           * Gets the GDPR Consent State
           *
           * @method getGDPRConsentState
           * @return {Object} A GDPR Consent State
           */function i(){return a._Helpers.extend({},l)}/**
           * Sets a CCPA Consent state (has a single purpose of 'data_sale_opt_out')
           *
           * @method setCCPAConsentState
           * @param {Object} ccpaConsent CCPA Consent State
           */function j(d){if(!a._Helpers.isObject(d))return a.Logger.error("Invoked with a bad or empty CCPA consent object."),this;var e=b.createPrivacyConsent(d.Consented,d.Timestamp,d.ConsentDocument,d.Location,d.HardwareId);return e&&(m[c]=e),this}/**
           * Gets the CCPA Consent State
           *
           * @method getCCPAConsentStatensent
           * @return {Object} A CCPA Consent State
           */ /**
           * Removes CCPA from the consent state object
           *
           * @method removeCCPAConsentState
           */function k(){return delete m[c],this}var l={},m={};return d&&(g(d.getGDPRConsentState()),j(d.getCCPAConsentState())),{setGDPRConsentState:g,addGDPRConsentState:f,setCCPAConsentState:j,getCCPAConsentState:function(){return m[c]},getGDPRConsentState:i,removeGDPRConsentState:h,removeCCPAState:function(){return a.Logger.warning("removeCCPAState is deprecated and will be removed in a future release; use removeCCPAConsentState instead"),k()},removeCCPAConsentState:k}};}

  function ownKeys$1(a, b) { var c = Object.keys(a); if (Object.getOwnPropertySymbols) {
      var d = Object.getOwnPropertySymbols(a);
      b && (d = d.filter(function (b) { return Object.getOwnPropertyDescriptor(a, b).enumerable; })), c.push.apply(c, d);
  } return c; }
  function _objectSpread$1(a) { for (var b, c = 1; c < arguments.length; c++)
      b = null == arguments[c] ? {} : arguments[c], c % 2 ? ownKeys$1(Object(b), !0).forEach(function (c) { defineProperty(a, c, b[c]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(b)) : ownKeys$1(Object(b)).forEach(function (c) { Object.defineProperty(a, c, Object.getOwnPropertyDescriptor(b, c)); }); return a; }
  var DataPlanMatchType = { ScreenView: "screen_view", CustomEvent: "custom_event", Commerce: "commerce", UserAttributes: "user_attributes", UserIdentities: "user_identities", ProductAction: "product_action", PromotionAction: "promotion_action", ProductImpression: "product_impression" }, KitBlocker = /*#__PURE__*/ function () {
      function a(b, c) {
          var d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = this; // if data plan is not requested, the data plan is {document: null}
          if (classCallCheck(this, a), defineProperty(this, "dataPlanMatchLookups", {}), defineProperty(this, "blockEvents", !1), defineProperty(this, "blockEventAttributes", !1), defineProperty(this, "blockUserAttributes", !1), defineProperty(this, "blockUserIdentities", !1), defineProperty(this, "kitBlockingEnabled", !1), defineProperty(this, "mpInstance", void 0), b && !b.document)
              return void (this.kitBlockingEnabled = !1);
          this.kitBlockingEnabled = !0, this.mpInstance = c, this.blockEvents = null === b || void 0 === b || null === (d = b.document) || void 0 === d || null === (e = d.dtpn) || void 0 === e || null === (f = e.blok) || void 0 === f ? void 0 : f.ev, this.blockEventAttributes = null === b || void 0 === b || null === (g = b.document) || void 0 === g || null === (h = g.dtpn) || void 0 === h || null === (i = h.blok) || void 0 === i ? void 0 : i.ea, this.blockUserAttributes = null === b || void 0 === b || null === (j = b.document) || void 0 === j || null === (k = j.dtpn) || void 0 === k || null === (l = k.blok) || void 0 === l ? void 0 : l.ua, this.blockUserIdentities = null === b || void 0 === b || null === (m = b.document) || void 0 === m || null === (n = m.dtpn) || void 0 === n || null === (o = n.blok) || void 0 === o ? void 0 : o.id;
          var t = null === b || void 0 === b || null === (p = b.document) || void 0 === p || null === (q = p.dtpn) || void 0 === q || null === (r = q.vers) || void 0 === r ? void 0 : r.version_document, u = null === t || void 0 === t ? void 0 : t.data_points;
          if (t)
              try {
                  0 < (null === u || void 0 === u ? void 0 : u.length) && u.forEach(function (a) { return s.addToMatchLookups(a); });
              }
              catch (a) {
                  this.mpInstance.Logger.error("There was an issue with the data plan: " + a);
              }
      }
      return createClass(a, [{ key: "addToMatchLookups", value: function addToMatchLookups(a) {
                  var b, c, d;
                  if (!a.match || !a.validator)
                      return void this.mpInstance.Logger.warning("Data Plan Point is not valid' + ".concat(a)); // match keys for non product custom attribute related data points
                  var e = this.generateMatchKey(a.match), f = this.getPlannedProperties(a.match.type, a.validator);
                  this.dataPlanMatchLookups[e] = f, ((null === a || void 0 === a || null === (b = a.match) || void 0 === b ? void 0 : b.type) === DataPlanMatchType.ProductImpression || (null === a || void 0 === a || null === (c = a.match) || void 0 === c ? void 0 : c.type) === DataPlanMatchType.ProductAction || (null === a || void 0 === a || null === (d = a.match) || void 0 === d ? void 0 : d.type) === DataPlanMatchType.PromotionAction) && (e = this.generateProductAttributeMatchKey(a.match), f = this.getProductProperties(a.match.type, a.validator), this.dataPlanMatchLookups[e] = f);
              } }, { key: "generateMatchKey", value: function generateMatchKey(a) { var b = a.criteria || ""; switch (a.type) {
                  case DataPlanMatchType.CustomEvent:
                      var c = b;
                      return [DataPlanMatchType.CustomEvent, c.custom_event_type, c.event_name].join(":");
                  case DataPlanMatchType.ScreenView: return [DataPlanMatchType.ScreenView, "", b.screen_name].join(":");
                  case DataPlanMatchType.ProductAction: return [a.type, b.action].join(":");
                  case DataPlanMatchType.PromotionAction: return [a.type, b.action].join(":");
                  case DataPlanMatchType.ProductImpression: return [a.type, b.action].join(":");
                  case DataPlanMatchType.UserIdentities:
                  case DataPlanMatchType.UserAttributes: return [a.type].join(":");
                  default: return null;
              } } }, { key: "generateProductAttributeMatchKey", value: function generateProductAttributeMatchKey(a) { var b = a.criteria || ""; switch (a.type) {
                  case DataPlanMatchType.ProductAction: return [a.type, b.action, "ProductAttributes"].join(":");
                  case DataPlanMatchType.PromotionAction: return [a.type, b.action, "ProductAttributes"].join(":");
                  case DataPlanMatchType.ProductImpression: return [a.type, b.action, "ProductAttributes"].join(":");
                  default: return null;
              } } }, { key: "getPlannedProperties", value: function getPlannedProperties(a, b) { var c, d, e, f, g, h, i; switch (a) {
                  case DataPlanMatchType.CustomEvent:
                  case DataPlanMatchType.ScreenView:
                  case DataPlanMatchType.ProductAction:
                  case DataPlanMatchType.PromotionAction:
                  case DataPlanMatchType.ProductImpression:
                      if (h = null === b || void 0 === b || null === (c = b.definition) || void 0 === c || null === (d = c.properties) || void 0 === d || null === (e = d.data) || void 0 === e || null === (f = e.properties) || void 0 === f ? void 0 : f.custom_attributes, h) {
                          if (!0 === h.additionalProperties || void 0 === h.additionalProperties)
                              return !0;
                          for (var j, k = {}, l = 0, m = Object.keys(h.properties); l < m.length; l++)
                              j = m[l], k[j] = !0;
                          return k;
                      }
                      var n, o, p;
                      return !1 !== (null === b || void 0 === b || null === (n = b.definition) || void 0 === n || null === (o = n.properties) || void 0 === o || null === (p = o.data) || void 0 === p ? void 0 : p.additionalProperties) || {};
                  case DataPlanMatchType.UserAttributes:
                  case DataPlanMatchType.UserIdentities:
                      if (i = null === b || void 0 === b || null === (g = b.definition) || void 0 === g ? void 0 : g.additionalProperties, !0 === i || void 0 === i)
                          return !0;
                      for (var q, r = {}, s = b.definition.properties, t = 0, u = Object.keys(s); t < u.length; t++)
                          q = u[t], r[q] = !0;
                      return r;
                  default: return null;
              } } }, { key: "getProductProperties", value: function getProductProperties(a, b) {
                  var c, d, e, f, g, h, i, j, k, l;
                  switch (a) {
                      case DataPlanMatchType.ProductAction:
                      case DataPlanMatchType.PromotionAction:
                      case DataPlanMatchType.ProductImpression: //product item attributes
                          if (l = null === b || void 0 === b || null === (c = b.definition) || void 0 === c || null === (d = c.properties) || void 0 === d || null === (e = d.data) || void 0 === e || null === (f = e.properties) || void 0 === f || null === (g = f.product_action) || void 0 === g || null === (h = g.properties) || void 0 === h || null === (i = h.products) || void 0 === i || null === (j = i.items) || void 0 === j || null === (k = j.properties) || void 0 === k ? void 0 : k.custom_attributes, l) {
                              if (!0 === l.additionalProperties || void 0 === l.additionalProperties)
                                  return !0;
                              for (var m = {}, n = 0, o = Object.keys(null === (p = l) || void 0 === p ? void 0 : p.properties); n < o.length; n++) {
                                  var p, q = o[n];
                                  m[q] = !0;
                              }
                              return m;
                          }
                          return !0;
                      default: return null;
                  }
              } }, { key: "getMatchKey", value: function getMatchKey(a) { switch (a.event_type) {
                  case dist_14.screenView:
                      var h = a;
                      return h.data ? ["screen_view", "", h.data.screen_name].join(":") : null;
                  case dist_14.commerceEvent:
                      var b = a, c = [];
                      if (b && b.data) {
                          var d = b.data, e = d.product_action, f = d.product_impressions, g = d.promotion_action;
                          e ? (c.push(DataPlanMatchType.ProductAction), c.push(e.action)) : g ? (c.push(DataPlanMatchType.PromotionAction), c.push(g.action)) : f && c.push(DataPlanMatchType.ProductImpression);
                      }
                      return c.join(":");
                  case dist_14.customEvent:
                      var i = a;
                      return i.data ? ["custom_event", i.data.custom_event_type, i.data.event_name].join(":") : null;
                  default: return null;
              } } }, { key: "getProductAttributeMatchKey", value: function getProductAttributeMatchKey(a) { switch (a.event_type) {
                  case dist_14.commerceEvent:
                      var b = [], c = a.data, d = c.product_action, e = c.product_impressions, f = c.promotion_action;
                      return d ? (b.push(DataPlanMatchType.ProductAction), b.push(d.action), b.push("ProductAttributes")) : f ? (b.push(DataPlanMatchType.PromotionAction), b.push(f.action), b.push("ProductAttributes")) : e && (b.push(DataPlanMatchType.ProductImpression), b.push("ProductAttributes")), b.join(":");
                  default: return null;
              } } }, { key: "createBlockedEvent", value: function createBlockedEvent(a) {
                  try {
                      return a && (a = this.transformEventAndEventAttributes(a)), a && a.EventDataType === Types.MessageType.Commerce && (a = this.transformProductAttributes(a)), a && (a = this.transformUserAttributes(a), a = this.transformUserIdentities(a)), a;
                  }
                  catch (b) {
                      return a;
                  }
              } }, { key: "transformEventAndEventAttributes", value: function transformEventAndEventAttributes(a) {
                  var b = _objectSpread$1({}, a), c = convertEvent(b), d = this.getMatchKey(c), e = this.dataPlanMatchLookups[d];
                  if (this.blockEvents && !e) /*
                          If the event is not planned, it doesn't exist in dataPlanMatchLookups
                          and should be blocked (return null to not send anything to forwarders)
                      */
                      return null;
                  if (this.blockEventAttributes) { /*
                      matchedEvent is set to `true` if additionalProperties is `true`
                      otherwise, delete attributes that exist on event.EventAttributes
                      that aren't on
                  */
                      if (!0 === e)
                          return b;
                      if (e) {
                          for (var f, g = 0, h = Object.keys(b.EventAttributes); g < h.length; g++)
                              f = h[g], e[f] || delete b.EventAttributes[f];
                          return b;
                      }
                      return b;
                  }
                  return b;
              } }, { key: "transformProductAttributes", value: function transformProductAttributes(a) {
                  var b = _objectSpread$1({}, a), c = convertEvent(b), d = this.getProductAttributeMatchKey(c), e = this.dataPlanMatchLookups[d];
                  if (this.blockEvents && !e) /*
                      If the event is not planned, it doesn't exist in dataPlanMatchLookups
                      and should be blocked (return null to not send anything to forwarders)
                  */
                      return null;
                  if (this.blockEventAttributes) { /*
                      matchedEvent is set to `true` if additionalProperties is `true`
                      otherwise, delete attributes that exist on event.EventAttributes
                      that aren't on
                  */
                      if (!0 === e)
                          return b;
                      if (e) {
                          var f, g;
                          return null === (f = b.ProductAction) || void 0 === f || null === (g = f.ProductList) || void 0 === g ? void 0 : g.forEach(function (a) { for (var b, c = 0, d = Object.keys(a.Attributes); c < d.length; c++)
                              b = d[c], e[b] || delete a.Attributes[b]; }), b;
                      }
                      return b;
                  }
                  return b;
              } }, { key: "transformUserAttributes", value: function transformUserAttributes(a) {
                  var b = _objectSpread$1({}, a);
                  if (this.blockUserAttributes) { /*
                      If the user attribute is not found in the matchedAttributes
                      then remove it from event.UserAttributes as it is blocked
                  */
                      var f = this.dataPlanMatchLookups.user_attributes;
                      if (this.mpInstance._Helpers.isObject(f))
                          for (var c, d = 0, e = Object.keys(b.UserAttributes); d < e.length; d++)
                              c = e[d], f[c] || delete b.UserAttributes[c];
                  }
                  return b;
              } }, { key: "isAttributeKeyBlocked", value: function isAttributeKeyBlocked(a) { /* used when an attribute is added to the user */ if (!this.blockUserAttributes)
                  return !1; if (this.blockUserAttributes) {
                  var b = this.dataPlanMatchLookups.user_attributes;
                  if (!0 === b)
                      return !1;
                  if (!b[a])
                      return !0;
              } return !1; } }, { key: "isIdentityBlocked", value: function isIdentityBlocked(a) { /* used when an attribute is added to the user */ if (!this.blockUserIdentities)
                  return !1; if (this.blockUserIdentities) {
                  var b = this.dataPlanMatchLookups.user_identities;
                  if (!0 === b)
                      return !1;
                  if (!b[a])
                      return !0;
              }
              else
                  return !1; return !1; } }, { key: "transformUserIdentities", value: function transformUserIdentities(a) { var b = this, c = _objectSpread$1({}, a); if (this.blockUserIdentities) {
                  var e = this.dataPlanMatchLookups.user_identities;
                  if (this.mpInstance._Helpers.isObject(e)) {
                      var d;
                      (null === c || void 0 === c || null === (d = c.UserIdentities) || void 0 === d ? void 0 : d.length) && c.UserIdentities.forEach(function (a, d) { var f = Types.IdentityType.getIdentityName(b.mpInstance._Helpers.parseNumber(a.Type)); e[f] || c.UserIdentities.splice(d, 1); });
                  }
              } return c; } }]), a;
  }(); /*
  inspiration from https://github.com/mParticle/data-planning-node/blob/master/src/data_planning/data_plan_event_validator.ts
  but modified to only include commerce events, custom events, screen views, and removes validation

  The purpose of the KitBlocker class is to parse a data plan and determine what events, event/user/product attributes, and user identities should be blocked from downstream forwarders.

  KitBlocker is instantiated with a data plan on mParticle initialization. KitBlocker.kitBlockingEnabled is false if no data plan is passed.
  It parses the data plan by creating a `dataPlanMatchLookups` object in the following manner:
  1. For all events and user attributes/identities, it generates a `matchKey` in the shape of `typeOfEvent:eventType:nameOfEvent`
  a. The matchKeys' value will return `true` if additionalProperties for the custom attributes/identities is `true`, otherwise it will return an object of planned attribute/identities
  2. For commerce events, after step 1 and 1a, a second `matchKey` is included that appends `Products`. This is used to determine productAttributes blocked

  When an event is logged in mParticle, it is sent to our server and then calls `KitBlocker.createBlockedEvent` before passing the event to each forwarder.
  If the event is blocked, it will not send to the forwarder. If the event is not blocked, event/user/product attributes and user identities will be removed from the returned event if blocked.
  */

  function ConfigAPIClient(){this.getSDKConfiguration=function(a,b,c,d){var e;try{var f=function(){4===g.readyState&&(200===g.status?(b=d._Helpers.extend({},b,JSON.parse(g.responseText)),c(a,b,d),d.Logger.verbose("Successfully received configuration from server")):(c(a,b,d),d.Logger.verbose("Issue with receiving configuration from server, received HTTP Code of "+g.status)));},g=d._Helpers.createXHR(f);e="https://"+d._Store.SDKConfig.configUrl+a+"/config?env=",e+=b.isDevelopmentMode?"1":"0";var h=b.dataPlan;h&&(h.planId&&(e=e+"&plan_id="+h.planId||""),h.planVersion&&(e=e+"&plan_version="+h.planVersion||"")),g&&(g.open("get",e),g.send(null));}catch(f){c(a,b,d),d.Logger.error("Error getting forwarder configuration from mParticle servers.");}};}

  var HTTPCodes$1=Constants.HTTPCodes,Messages$8=Constants.Messages;function IdentityAPIClient(a){this.sendAliasRequest=function(b,c){var d,e=function(){if(4===d.readyState){//only parse error messages from failing requests
  if(a.Logger.verbose("Received "+d.statusText+" from server"),200!==d.status&&202!==d.status&&d.responseText){var b=JSON.parse(d.responseText);if(b.hasOwnProperty("message")){var e=b.message;return void a._Helpers.invokeAliasCallback(c,d.status,e)}}a._Helpers.invokeAliasCallback(c,d.status);}};if(a.Logger.verbose(Messages$8.InformationMessages.SendAliasHttp),d=a._Helpers.createXHR(e),d)try{d.open("post",a._Helpers.createServiceUrl(a._Store.SDKConfig.aliasUrl,a._Store.devToken)+"/Alias"),d.send(JSON.stringify(b));}catch(b){a._Helpers.invokeAliasCallback(c,HTTPCodes$1.noHttpCoverage,b),a.Logger.error("Error sending alias request to mParticle servers. "+b);}},this.sendIdentityRequest=function(b,c,d,e,f,g){var h,i,j=function(){4===h.readyState&&(a.Logger.verbose("Received "+h.statusText+" from server"),f(h,i,d,e,c));};if(a.Logger.verbose(Messages$8.InformationMessages.SendIdentityBegin),!b)return void a.Logger.error(Messages$8.ErrorMessages.APIRequestEmpty);if(a.Logger.verbose(Messages$8.InformationMessages.SendIdentityHttp),h=a._Helpers.createXHR(j),h)try{a._Store.identityCallInFlight?a._Helpers.invokeCallback(d,HTTPCodes$1.activeIdentityRequest,"There is currently an Identity request processing. Please wait for this to return before requesting again"):(i=g||null,"modify"===c?h.open("post",a._Helpers.createServiceUrl(a._Store.SDKConfig.identityUrl)+g+"/"+c):h.open("post",a._Helpers.createServiceUrl(a._Store.SDKConfig.identityUrl)+c),h.setRequestHeader("Content-Type","application/json"),h.setRequestHeader("x-mp-key",a._Store.devToken),a._Store.identityCallInFlight=!0,h.send(JSON.stringify(b)));}catch(b){a._Store.identityCallInFlight=!1,a._Helpers.invokeCallback(d,HTTPCodes$1.noHttpCoverage,b),a.Logger.error("Error sending identity request to servers with status code "+h.status+" - "+b);}};}

  var Messages$9=Constants.Messages,HTTPCodes$2=Constants.HTTPCodes;/**
   * <p>All of the following methods can be called on the primary mParticle class. In version 2.10.0, we introduced <a href="https://docs.mparticle.com/developers/sdk/web/multiple-instances/">multiple instances</a>. If you are using multiple instances (self hosted environments only), you should call these methods on each instance.</p>
   * <p>In current versions of mParticle, if your site has one instance, that instance name is 'default_instance'. Any methods called on mParticle on a site with one instance will be mapped to the `default_instance`.</p>
   * <p>This is for simplicity and backwards compatibility. For example, calling mParticle.logPageView() automatically maps to mParticle.getInstance('default_instance').logPageView().</p>
   * <p>If you have multiple instances, instances must first be initialized and then a method can be called on that instance. For example:</p>
   * <code>
   *  mParticle.init('apiKey', config, 'another_instance');
   *  mParticle.getInstance('another_instance').logPageView();
   * </code>
   *
   * @class mParticle & mParticleInstance
   */function mParticleInstance(a){var b=this;// These classes are for internal use only. Not documented for public consumption
  // required for forwarders once they reference the mparticle instance
  /**
       * Resets the SDK to an uninitialized state and removes cookies/localStorage. You MUST call mParticle.init(apiKey, window.mParticle.config)
       * before any other mParticle methods or the SDK will not function as intended.
       * @method setLogLevel
       * @param {String} logLevel verbose, warning, or none. By default, `warning` is chosen.
       */ /**
       * Resets the SDK to an uninitialized state and removes cookies/localStorage. You MUST call mParticle.init(apiKey, window.mParticle.config)
       * before any other mParticle methods or the SDK will not function as intended.
       * @method reset
       */ /**
       * A callback method that is invoked after mParticle is initialized.
       * @method ready
       * @param {Function} function A function to be called after mParticle is initialized
       */ /**
       * Returns the mParticle SDK version number
       * @method getVersion
       * @return {String} mParticle SDK version number
       */ /**
       * Sets the app version
       * @method setAppVersion
       * @param {String} version version number
       */ /**
       * Gets the app name
       * @method getAppName
       * @return {String} App name
       */ /**
       * Sets the app name
       * @method setAppName
       * @param {String} name App Name
       */ /**
       * Gets the app version
       * @method getAppVersion
       * @return {String} App version
       */ /**
       * Stops tracking the location of the user
       * @method stopTrackingLocation
       */ /**
       * Starts tracking the location of the user
       * @method startTrackingLocation
       * @param {Function} [callback] A callback function that is called when the location is either allowed or rejected by the user. A position object of schema {coords: {latitude: number, longitude: number}} is passed to the callback
       */ /**
       * Sets the position of the user
       * @method setPosition
       * @param {Number} lattitude lattitude digit
       * @param {Number} longitude longitude digit
       */ /**
       * Starts a new session
       * @method startNewSession
       */ /**
       * Ends the current session
       * @method endSession
       */ /**
       * Logs a Base Event to mParticle's servers
       * @param {Object} event Base Event Object
       */ /**
       * Logs an event to mParticle's servers
       * @method logEvent
       * @param {String} eventName The name of the event
       * @param {Number} [eventType] The eventType as seen [here](http://docs.mparticle.com/developers/sdk/web/event-tracking#event-type)
       * @param {Object} [eventInfo] Attributes for the event
       * @param {Object} [customFlags] Additional customFlags
       */ /**
       * Used to log custom errors
       *
       * @method logError
       * @param {String or Object} error The name of the error (string), or an object formed as follows {name: 'exampleName', message: 'exampleMessage', stack: 'exampleStack'}
       * @param {Object} [attrs] Custom attrs to be passed along with the error event; values must be string, number, or boolean
       */ /**
       * Logs `click` events
       * @method logLink
       * @param {String} selector The selector to add a 'click' event to (ex. #purchase-event)
       * @param {String} [eventName] The name of the event
       * @param {Number} [eventType] The eventType as seen [here](http://docs.mparticle.com/developers/sdk/javascript/event-tracking#event-type)
       * @param {Object} [eventInfo] Attributes for the event
       */ /**
       * Logs `submit` events
       * @method logForm
       * @param {String} selector The selector to add the event handler to (ex. #search-event)
       * @param {String} [eventName] The name of the event
       * @param {Number} [eventType] The eventType as seen [here](http://docs.mparticle.com/developers/sdk/javascript/event-tracking#event-type)
       * @param {Object} [eventInfo] Attributes for the event
       */ /**
       * Logs a page view
       * @method logPageView
       * @param {String} eventName The name of the event. Defaults to 'PageView'.
       * @param {Object} [attrs] Attributes for the event
       * @param {Object} [customFlags] Custom flags for the event
       */ /**
       * Forces an upload of the batch
       * @method upload
       */ /**
       * Invoke these methods on the mParticle.Consent object.
       * Example: mParticle.Consent.createConsentState()
       *
       * @class mParticle.Consent
       */ /**
       * Invoke these methods on the mParticle.eCommerce object.
       * Example: mParticle.eCommerce.createImpresion(...)
       * @class mParticle.eCommerce
       */ /**
       * Sets a session attribute
       * @method setSessionAttribute
       * @param {String} key key for session attribute
       * @param {String or Number} value value for session attribute
       */ /**
       * Set opt out of logging
       * @method setOptOut
       * @param {Boolean} isOptingOut boolean to opt out or not. When set to true, opt out of logging.
       */ /**
       * Set or remove the integration attributes for a given integration ID.
       * Integration attributes are keys and values specific to a given integration. For example,
       * many integrations have their own internal user/device ID. mParticle will store integration attributes
       * for a given device, and will be able to use these values for server-to-server communication to services.
       * This is often useful when used in combination with a server-to-server feed, allowing the feed to be enriched
       * with the necessary integration attributes to be properly forwarded to the given integration.
       * @method setIntegrationAttribute
       * @param {Number} integrationId mParticle integration ID
       * @param {Object} attrs a map of attributes that will replace any current attributes. The keys are predefined by mParticle.
       * Please consult with the mParticle docs or your solutions consultant for the correct value. You may
       * also pass a null or empty map here to remove all of the attributes.
       */ /**
       * Get integration attributes for a given integration ID.
       * @method getIntegrationAttributes
       * @param {Number} integrationId mParticle integration ID
       * @return {Object} an object map of the integrationId's attributes
       */ // Used by our forwarders
  this._instanceName=a,this._NativeSdkHelpers=new NativeSdkHelpers(this),this._Migrations=new Migrations(this),this._SessionManager=new SessionManager(this),this._Persistence=new _Persistence(this),this._Helpers=new Helpers(this),this._Events=new Events(this),this._CookieSyncManager=new cookieSyncManager(this),this._ServerModel=new ServerModel(this),this._Ecommerce=new Ecommerce(this),this._ForwardingStatsUploader=new forwardingStatsUploader(this),this._Consent=new Consent(this),this._IdentityAPIClient=new IdentityAPIClient(this),this._preInit={readyQueue:[],integrationDelays:{},forwarderConstructors:[]},this.IdentityType=Types.IdentityType,this.EventType=Types.EventType,this.CommerceEventType=Types.CommerceEventType,this.PromotionType=Types.PromotionActionType,this.ProductActionType=Types.ProductActionType,this._Identity=new Identity(this),this.Identity=this._Identity.IdentityAPI,this.generateHash=this._Helpers.generateHash,this.getDeviceId=this._Persistence.getDeviceId,"undefined"!=typeof window&&window.mParticle&&window.mParticle.config&&window.mParticle.config.hasOwnProperty("rq")&&(this._preInit.readyQueue=window.mParticle.config.rq),this.init=function(a,b){// config code - Fetch config when requestConfig = true, otherwise, proceed with SDKInitialization
  // Since fetching the configuration is asynchronous, we must pass completeSDKInitialization
  // to it for it to be run after fetched
  return b||console.warn("You did not pass a config object to init(). mParticle will not initialize properly"),runPreConfigFetchInitialization(this,a,b),b?void(!b.hasOwnProperty("requestConfig")||b.requestConfig?new ConfigAPIClient().getSDKConfiguration(a,b,completeSDKInitialization,this):completeSDKInitialization(a,b,this)):void console.error("No config available on the window, please pass a config object to mParticle.init()")},this.setLogLevel=function(a){b.Logger.setLogLevel(a);},this.reset=function(a){a._Persistence.resetPersistence(),a._Store&&delete a._Store;},this._resetForTests=function(a,b,c){c._Store&&delete c._Store,c._Store=new Store(a,c),c._Store.isLocalStorageAvailable=c._Persistence.determineLocalStorageAvailability(window.localStorage),c._Events.stopTracking(),b||c._Persistence.resetPersistence(),c._Persistence.forwardingStatsBatches.uploadsTable={},c._Persistence.forwardingStatsBatches.forwardingStatsEventQueue=[],c._preInit={readyQueue:[],pixelConfigurations:[],integrationDelays:{},forwarderConstructors:[],isDevelopmentMode:!1};},this.ready=function(a){b._Store.isInitialized&&"function"==typeof a?a():b._preInit.readyQueue.push(a);},this.getVersion=function(){return Constants.sdkVersion},this.setAppVersion=function(a){b._Store.SDKConfig.appVersion=a,b._Persistence.update();},this.getAppName=function(){return b._Store.SDKConfig.appName},this.setAppName=function(a){b._Store.SDKConfig.appName=a;},this.getAppVersion=function(){return b._Store.SDKConfig.appVersion},this.stopTrackingLocation=function(){b._SessionManager.resetSessionTimer(),b._Events.stopTracking();},this.startTrackingLocation=function(a){b._Helpers.Validators.isFunction(a)||b.Logger.warning("Warning: Location tracking is triggered, but not including a callback into the `startTrackingLocation` may result in events logged too quickly and not being associated with a location."),b._SessionManager.resetSessionTimer(),b._Events.startTracking(a);},this.setPosition=function(a,c){b._SessionManager.resetSessionTimer(),"number"==typeof a&&"number"==typeof c?b._Store.currentPosition={lat:a,lng:c}:b.Logger.error("Position latitude and/or longitude must both be of type number");},this.startNewSession=function(){b._SessionManager.startNewSession();},this.endSession=function(){// Sends true as an over ride vs when endSession is called from the setInterval
  b._SessionManager.endSession(!0);},this.logBaseEvent=function(a){return b._Store.isInitialized?(b._SessionManager.resetSessionTimer(),"string"!=typeof a.name)?void b.Logger.error(Messages$9.ErrorMessages.EventNameInvalidType):(a.eventType||(a.eventType=Types.EventType.Unknown),b._Helpers.canLog()?void b._Events.logEvent(a):void b.Logger.error(Messages$9.ErrorMessages.LoggingDisabled)):void b.ready(function(){b.logBaseEvent(a);})},this.logEvent=function(a,c,d,e){return b._Store.isInitialized?(b._SessionManager.resetSessionTimer(),"string"!=typeof a)?void b.Logger.error(Messages$9.ErrorMessages.EventNameInvalidType):(c||(c=Types.EventType.Unknown),b._Helpers.isEventType(c)?b._Helpers.canLog()?void b._Events.logEvent({messageType:Types.MessageType.PageEvent,name:a,data:d,eventType:c,customFlags:e}):void b.Logger.error(Messages$9.ErrorMessages.LoggingDisabled):void b.Logger.error("Invalid event type: "+c+", must be one of: \n"+JSON.stringify(Types.EventType))):void b.ready(function(){b.logEvent(a,c,d,e);})},this.logError=function(a,c){if(!b._Store.isInitialized)return void b.ready(function(){b.logError(a,c);});if(b._SessionManager.resetSessionTimer(),!!a){"string"==typeof a&&(a={message:a});var d={m:a.message?a.message:a,s:"Error",t:a.stack};if(c){var e=b._Helpers.sanitizeAttributes(c);for(var f in e)d[f]=e[f];}b._Events.logEvent({messageType:Types.MessageType.CrashReport,name:a.name?a.name:"Error",data:d,eventType:Types.EventType.Other});}},this.logLink=function(a,c,d,e){b._Events.addEventHandler("click",a,c,e,d);},this.logForm=function(a,c,d,e){b._Events.addEventHandler("submit",a,c,e,d);},this.logPageView=function(a,c,d){if(!b._Store.isInitialized)return void b.ready(function(){b.logPageView(a,c,d);});if(b._SessionManager.resetSessionTimer(),b._Helpers.canLog()){if(b._Helpers.Validators.isStringOrNumber(a)||(a="PageView"),!c)c={hostname:window.location.hostname,title:window.document.title};else if(!b._Helpers.isObject(c))return void b.Logger.error("The attributes argument must be an object. A "+_typeof_1(c)+" was entered. Please correct and retry.");if(d&&!b._Helpers.isObject(d))return void b.Logger.error("The customFlags argument must be an object. A "+_typeof_1(d)+" was entered. Please correct and retry.")}b._Events.logEvent({messageType:Types.MessageType.PageView,name:a,data:c,eventType:Types.EventType.Unknown,customFlags:d});},this.upload=function(){b._Helpers.canLog()&&(b._Store.webviewBridgeEnabled?b._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.Upload):b._APIClient.uploader.prepareAndUpload(!1,!1));},this.Consent={/**
           * Creates a CCPA Opt Out Consent State.
           *
           * @method createCCPAConsent
           * @param {Boolean} optOut true represents a "data sale opt-out", false represents the user declining a "data sale opt-out"
           * @param {Number} timestamp Unix time (likely to be Date.now())
           * @param {String} consentDocument document version or experience that the user may have consented to
           * @param {String} location location where the user gave consent
           * @param {String} hardwareId hardware ID for the device or browser used to give consent. This property exists only to provide additional context and is not used to identify users
           * @return {Object} CCPA Consent State
           */createCCPAConsent:b._Consent.createPrivacyConsent,/**
           * Creates a GDPR Consent State.
           *
           * @method createGDPRConsent
           * @param {Boolean} consent true represents a "data sale opt-out", false represents the user declining a "data sale opt-out"
           * @param {Number} timestamp Unix time (likely to be Date.now())
           * @param {String} consentDocument document version or experience that the user may have consented to
           * @param {String} location location where the user gave consent
           * @param {String} hardwareId hardware ID for the device or browser used to give consent. This property exists only to provide additional context and is not used to identify users
           * @return {Object} GDPR Consent State
           */createGDPRConsent:b._Consent.createPrivacyConsent,/**
           * Creates a Consent State Object, which can then be used to set CCPA states, add multiple GDPR states, as well as get and remove these privacy states.
           *
           * @method createConsentState
           * @return {Object} ConsentState object
           */createConsentState:b._Consent.createConsentState},this.eCommerce={/**
           * Invoke these methods on the mParticle.eCommerce.Cart object.
           * Example: mParticle.eCommerce.Cart.add(...)
           * @class mParticle.eCommerce.Cart
           * @deprecated
           */Cart:{/**
               * Adds a product to the cart
               * @method add
               * @param {Object} product The product you want to add to the cart
               * @param {Boolean} [logEventBoolean] Option to log the event to mParticle's servers. If blank, no logging occurs.
               * @deprecated
               */add:function add(a,c){b.Logger.warning("Deprecated function eCommerce.Cart.add() will be removed in future releases");var d,e=b.Identity.getCurrentUser();e&&(d=e.getMPID()),b._Identity.mParticleUserCart(d).add(a,c);},/**
               * Removes a product from the cart
               * @method remove
               * @param {Object} product The product you want to add to the cart
               * @param {Boolean} [logEventBoolean] Option to log the event to mParticle's servers. If blank, no logging occurs.
               * @deprecated
               */remove:function remove(a,c){b.Logger.warning("Deprecated function eCommerce.Cart.remove() will be removed in future releases");var d,e=b.Identity.getCurrentUser();e&&(d=e.getMPID()),b._Identity.mParticleUserCart(d).remove(a,c);},/**
               * Clears the cart
               * @method clear
               * @deprecated
               */clear:function clear(){b.Logger.warning("Deprecated function eCommerce.Cart.clear() will be removed in future releases");var a,c=b.Identity.getCurrentUser();c&&(a=c.getMPID()),b._Identity.mParticleUserCart(a).clear();}},/**
           * Sets the currency code
           * @for mParticle.eCommerce
           * @method setCurrencyCode
           * @param {String} code The currency code
           */setCurrencyCode:function setCurrencyCode(a){return b._Store.isInitialized?"string"==typeof a?void(b._SessionManager.resetSessionTimer(),b._Store.currencyCode=a):void b.Logger.error("Code must be a string"):void b.ready(function(){b.setCurrencyCode(a);})},/**
           * Creates a product
           * @for mParticle.eCommerce
           * @method createProduct
           * @param {String} name product name
           * @param {String} sku product sku
           * @param {Number} price product price
           * @param {Number} [quantity] product quantity. If blank, defaults to 1.
           * @param {String} [variant] product variant
           * @param {String} [category] product category
           * @param {String} [brand] product brand
           * @param {Number} [position] product position
           * @param {String} [coupon] product coupon
           * @param {Object} [attributes] product attributes
           */createProduct:function createProduct(a,c,d,e,f,g,h,i,j,k){return b._Ecommerce.createProduct(a,c,d,e,f,g,h,i,j,k)},/**
           * Creates a promotion
           * @for mParticle.eCommerce
           * @method createPromotion
           * @param {String} id a unique promotion id
           * @param {String} [creative] promotion creative
           * @param {String} [name] promotion name
           * @param {Number} [position] promotion position
           */createPromotion:function createPromotion(a,c,d,e){return b._Ecommerce.createPromotion(a,c,d,e)},/**
           * Creates a product impression
           * @for mParticle.eCommerce
           * @method createImpression
           * @param {String} name impression name
           * @param {Object} product the product for which an impression is being created
           */createImpression:function createImpression(a,c){return b._Ecommerce.createImpression(a,c)},/**
           * Creates a transaction attributes object to be used with a checkout
           * @for mParticle.eCommerce
           * @method createTransactionAttributes
           * @param {String or Number} id a unique transaction id
           * @param {String} [affiliation] affilliation
           * @param {String} [couponCode] the coupon code for which you are creating transaction attributes
           * @param {Number} [revenue] total revenue for the product being purchased
           * @param {String} [shipping] the shipping method
           * @param {Number} [tax] the tax amount
           */createTransactionAttributes:function createTransactionAttributes(a,c,d,e,f,g){return b._Ecommerce.createTransactionAttributes(a,c,d,e,f,g)},/**
           * Logs a checkout action
           * @for mParticle.eCommerce
           * @method logCheckout
           * @param {Number} step checkout step number
           * @param {String} option
           * @param {Object} attrs
           * @param {Object} [customFlags] Custom flags for the event
           * @deprecated
           */logCheckout:function logCheckout(a,c,d,e){return b.Logger.warning("mParticle.logCheckout is deprecated, please use mParticle.logProductAction instead"),b._Store.isInitialized?void(b._SessionManager.resetSessionTimer(),b._Events.logCheckoutEvent(a,c,d,e)):void b.ready(function(){b.eCommerce.logCheckout(a,c,d,e);})},/**
           * Logs a product action
           * @for mParticle.eCommerce
           * @method logProductAction
           * @param {Number} productActionType product action type as found [here](https://github.com/mParticle/mparticle-sdk-javascript/blob/master-v2/src/types.js#L206-L218)
           * @param {Object} product the product for which you are creating the product action
           * @param {Object} [attrs] attributes related to the product action
           * @param {Object} [customFlags] Custom flags for the event
           * @param {Object} [transactionAttributes] Transaction Attributes for the event
           */logProductAction:function logProductAction(a,c,d,e,f){return b._Store.isInitialized?void(b._SessionManager.resetSessionTimer(),b._Events.logProductActionEvent(a,c,d,e,f)):void b.ready(function(){b.eCommerce.logProductAction(a,c,d,e,f);})},/**
           * Logs a product purchase
           * @for mParticle.eCommerce
           * @method logPurchase
           * @param {Object} transactionAttributes transactionAttributes object
           * @param {Object} product the product being purchased
           * @param {Boolean} [clearCart] boolean to clear the cart after logging or not. Defaults to false
           * @param {Object} [attrs] other attributes related to the product purchase
           * @param {Object} [customFlags] Custom flags for the event
           * @deprecated
           */logPurchase:function logPurchase(a,c,d,e,f){return b.Logger.warning("mParticle.logPurchase is deprecated, please use mParticle.logProductAction instead"),b._Store.isInitialized?a&&c?void(b._SessionManager.resetSessionTimer(),b._Events.logPurchaseEvent(a,c,e,f)):void b.Logger.error(Messages$9.ErrorMessages.BadLogPurchase):void b.ready(function(){b.eCommerce.logPurchase(a,c,d,e,f);})},/**
           * Logs a product promotion
           * @for mParticle.eCommerce
           * @method logPromotion
           * @param {Number} type the promotion type as found [here](https://github.com/mParticle/mparticle-sdk-javascript/blob/master-v2/src/types.js#L275-L279)
           * @param {Object} promotion promotion object
           * @param {Object} [attrs] boolean to clear the cart after logging or not
           * @param {Object} [customFlags] Custom flags for the event
           */logPromotion:function logPromotion(a,c,d,e){return b._Store.isInitialized?void(b._SessionManager.resetSessionTimer(),b._Events.logPromotionEvent(a,c,d,e)):void b.ready(function(){b.eCommerce.logPromotion(a,c,d,e);})},/**
           * Logs a product impression
           * @for mParticle.eCommerce
           * @method logImpression
           * @param {Object} impression product impression object
           * @param {Object} attrs attributes related to the impression log
           * @param {Object} [customFlags] Custom flags for the event
           */logImpression:function logImpression(a,c,d){return b._Store.isInitialized?void(b._SessionManager.resetSessionTimer(),b._Events.logImpressionEvent(a,c,d)):void b.ready(function(){b.eCommerce.logImpression(a,c,d);})},/**
           * Logs a refund
           * @for mParticle.eCommerce
           * @method logRefund
           * @param {Object} transactionAttributes transaction attributes related to the refund
           * @param {Object} product product being refunded
           * @param {Boolean} [clearCart] boolean to clear the cart after refund is logged. Defaults to false.
           * @param {Object} [attrs] attributes related to the refund
           * @param {Object} [customFlags] Custom flags for the event
           * @deprecated
           */logRefund:function logRefund(a,c,d,e,f){return b.Logger.warning("mParticle.logRefund is deprecated, please use mParticle.logProductAction instead"),b._Store.isInitialized?void(b._SessionManager.resetSessionTimer(),b._Events.logRefundEvent(a,c,e,f)):void b.ready(function(){b.eCommerce.logRefund(a,c,d,e,f);})},expandCommerceEvent:function expandCommerceEvent(a){return b._Ecommerce.expandCommerceEvent(a)}},this.setSessionAttribute=function(a,c){if(!b._Store.isInitialized)return void b.ready(function(){b.setSessionAttribute(a,c);});// Logs to cookie
  // And logs to in-memory object
  // Example: mParticle.setSessionAttribute('location', '33431');
  if(b._Helpers.canLog()){if(!b._Helpers.Validators.isValidAttributeValue(c))return void b.Logger.error(Messages$9.ErrorMessages.BadAttribute);if(!b._Helpers.Validators.isValidKeyValue(a))return void b.Logger.error(Messages$9.ErrorMessages.BadKey);if(b._Store.webviewBridgeEnabled)b._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.SetSessionAttribute,JSON.stringify({key:a,value:c}));else {var d=b._Helpers.findKeyInObject(b._Store.sessionAttributes,a);d&&(a=d),b._Store.sessionAttributes[a]=c,b._Persistence.update(),b._Forwarders.applyToForwarders("setSessionAttribute",[a,c]);}}},this.setOptOut=function(a){return b._Store.isInitialized?void(b._SessionManager.resetSessionTimer(),b._Store.isEnabled=!a,b._Events.logOptOut(),b._Persistence.update(),b._Store.activeForwarders.length&&b._Store.activeForwarders.forEach(function(c){if(c.setOptOut){var d=c.setOptOut(a);d&&b.Logger.verbose(d);}})):void b.ready(function(){b.setOptOut(a);})},this.setIntegrationAttribute=function(a,c){if(!b._Store.isInitialized)return void b.ready(function(){b.setIntegrationAttribute(a,c);});if("number"!=typeof a)return void b.Logger.error("integrationId must be a number");if(null===c)b._Store.integrationAttributes[a]={};else {if(!b._Helpers.isObject(c))return void b.Logger.error("Attrs must be an object with keys and values. You entered a "+_typeof_1(c));if(0===Object.keys(c).length)b._Store.integrationAttributes[a]={};else for(var d in c)if("string"!=typeof d){b.Logger.error("Keys must be strings, you entered a "+_typeof_1(d));continue}else if("string"==typeof c[d])b._Helpers.isObject(b._Store.integrationAttributes[a])?b._Store.integrationAttributes[a][d]=c[d]:(b._Store.integrationAttributes[a]={},b._Store.integrationAttributes[a][d]=c[d]);else {b.Logger.error("Values for integration attributes must be strings. You entered a "+_typeof_1(c[d]));continue}}b._Persistence.update();},this.getIntegrationAttributes=function(a){return b._Store.integrationAttributes[a]?b._Store.integrationAttributes[a]:{}},this.addForwarder=function(a){b._preInit.forwarderConstructors.push(a);},this.configurePixel=function(a){b._Forwarders.configurePixel(a);},this._getActiveForwarders=function(){return b._Store.activeForwarders},this._getIntegrationDelays=function(){return b._preInit.integrationDelays},this._setIntegrationDelay=function(a,c){b._preInit.integrationDelays[a]=c;};}// Some (server) config settings need to be returned before they are set on SDKConfig in a self hosted environment
  function completeSDKInitialization(a,b,c){var d=createKitBlocker(b,c);if(c._APIClient=new APIClient(c,d),c._Forwarders=new Forwarders(c,d),b.flags&&(b.flags.hasOwnProperty(Constants.FeatureFlags.EventsV3)&&(c._Store.SDKConfig.flags[Constants.FeatureFlags.EventsV3]=b.flags[Constants.FeatureFlags.EventsV3]),b.flags.hasOwnProperty(Constants.FeatureFlags.EventBatchingIntervalMillis)&&(c._Store.SDKConfig.flags[Constants.FeatureFlags.EventBatchingIntervalMillis]=b.flags[Constants.FeatureFlags.EventBatchingIntervalMillis])),c._Store.storageName=c._Helpers.createMainStorageName(b.workspaceToken),c._Store.prodStorageName=c._Helpers.createProductStorageName(b.workspaceToken),b.hasOwnProperty("workspaceToken")?c._Store.SDKConfig.workspaceToken=b.workspaceToken:c.Logger.warning("You should have a workspaceToken on your config object for security purposes."),b.hasOwnProperty("requiredWebviewBridgeName")?c._Store.SDKConfig.requiredWebviewBridgeName=b.requiredWebviewBridgeName:b.hasOwnProperty("workspaceToken")&&(c._Store.SDKConfig.requiredWebviewBridgeName=b.workspaceToken),c._Store.webviewBridgeEnabled=c._NativeSdkHelpers.isWebviewEnabled(c._Store.SDKConfig.requiredWebviewBridgeName,c._Store.SDKConfig.minWebviewBridgeVersion),c._Store.configurationLoaded=!0,c._Store.webviewBridgeEnabled||(c._Migrations.migrate(),c._Persistence.initializeStorage()),c._Store.webviewBridgeEnabled)c._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.SetSessionAttribute,JSON.stringify({key:"$src_env",value:"webview"})),a&&c._NativeSdkHelpers.sendToNative(Constants.NativeSdkPaths.SetSessionAttribute,JSON.stringify({key:"$src_key",value:a}));else {var e;// If no initialIdentityRequest is passed in, we set the user identities to what is currently in cookies for the identify request
  if(c._Helpers.isObject(c._Store.SDKConfig.identifyRequest)&&c._Helpers.isObject(c._Store.SDKConfig.identifyRequest.userIdentities)&&0===Object.keys(c._Store.SDKConfig.identifyRequest.userIdentities).length||!c._Store.SDKConfig.identifyRequest){var f={};if(e=c.Identity.getCurrentUser(),e){var g=e.getUserIdentities().userIdentities||{};for(var h in g)g.hasOwnProperty(h)&&(f[h]=g[h]);}c._Store.SDKConfig.identifyRequest={userIdentities:f};}// If migrating from pre-IDSync to IDSync, a sessionID will exist and an identify request will not have been fired, so we need this check
  c._Store.migratingToIDSyncCookies&&(c.Identity.identify(c._Store.SDKConfig.identifyRequest,c._Store.SDKConfig.identityCallback),c._Store.migratingToIDSyncCookies=!1),e=c.Identity.getCurrentUser(),c._Helpers.getFeatureFlag(Constants.FeatureFlags.ReportBatching)&&c._ForwardingStatsUploader.startForwardingStatsTimer(),c._Forwarders.processForwarders(b,c._APIClient.prepareForwardingStats),!c._Store.identifyCalled&&c._Store.SDKConfig.identityCallback&&e&&e.getMPID()&&c._Store.SDKConfig.identityCallback({httpCode:HTTPCodes$2.activeSession,getUser:function getUser(){return c._Identity.mParticleUser(e.getMPID())},getPreviousUser:function getPreviousUser(){var a=c.Identity.getUsers(),b=a.shift();return b&&e&&b.getMPID()===e.getMPID()&&(b=a.shift()),b||null},body:{mpid:e.getMPID(),is_logged_in:c._Store.isLoggedIn,matched_identities:e.getUserIdentities().userIdentities,context:null,is_ephemeral:!1}}),c._SessionManager.initialize(),c._Events.logAST();}c._Store.isInitialized=!0,c._preInit.readyQueue&&c._preInit.readyQueue.length&&(c._preInit.readyQueue.forEach(function(a){c._Helpers.Validators.isFunction(a)?a():Array.isArray(a)&&processPreloadedItem(a,c);}),c._preInit.readyQueue=[]),c._Store.isFirstRun&&(c._Store.isFirstRun=!1);}function createKitBlocker(a,b){var c,d,e,f;/*  There are three ways a data plan object for blocking can be passed to the SDK:
              1. Manually via config.dataPlanOptions (this takes priority)
              If not passed in manually, we user the server provided via either
              2. Snippet via /mparticle.js endpoint (config.dataPlan.document)
              3. Self hosting via /config endpoint (config.dataPlanResult)
      */return a.dataPlanOptions&&(b.Logger.verbose("Customer provided data plan found"),f=a.dataPlanOptions,d={document:{dtpn:{vers:f.dataPlanVersion,blok:{ev:f.blockEvents,ea:f.blockEventAttributes,ua:f.blockUserAttributes,id:f.blockUserIdentities}}}}),d||(a.dataPlan&&a.dataPlan.document?a.dataPlan.document.error_message?e=a.dataPlan.document.error_message:(b.Logger.verbose("Data plan found from mParticle.js"),d=a.dataPlan):a.dataPlanResult&&(a.dataPlanResult.error_message?e=a.dataPlanResult.error_message:(b.Logger.verbose("Data plan found from /config"),d={document:a.dataPlanResult}))),e&&b.Logger.error(e),d&&(c=new KitBlocker(d,b)),c}function runPreConfigFetchInitialization(a,b,c){a.Logger=new Logger(c),a._Store=new Store(c,a),window.mParticle.Store=a._Store,a._Store.devToken=b||null,a.Logger.verbose(Messages$9.InformationMessages.StartingInitialization);//check to see if localStorage is available for migrating purposes
  try{a._Store.isLocalStorageAvailable=a._Persistence.determineLocalStorageAvailability(window.localStorage);}catch(b){a.Logger.warning("localStorage is not available, using cookies if available"),a._Store.isLocalStorageAvailable=!1;}}function processPreloadedItem(a,b){var c=a,d=c.splice(0,1)[0];// if the first argument is a method on the base mParticle object, run it
  if(mParticle[c[0]])mParticle[d].apply(this,c);else {var e=d.split(".");try{for(var f,g=mParticle,h=0;h<e.length;h++)f=e[h],g=g[f];g.apply(this,c);}catch(a){b.Logger.verbose("Unable to compute proper mParticle function "+a);}}}

  var _BatchValidator = /*#__PURE__*/ function () {
      function a() { classCallCheck(this, a); }
      return createClass(a, [{ key: "getMPInstance", value: function getMPInstance() {
                  return {
                      _Helpers: { sanitizeAttributes: window.mParticle.getInstance()._Helpers.sanitizeAttributes, generateUniqueId: function generateUniqueId() { return "mockId"; }, extend: window.mParticle.getInstance()._Helpers.extend }, _Store: { sessionId: "mockSessionId", SDKConfig: {} }, Identity: { getCurrentUser: function getCurrentUser() { return null; } }, getAppVersion: function getAppVersion() { return null; }, getAppName: function getAppName() { return null; }
                  };
              } }, { key: "returnBatch", value: function returnBatch(a) { var b = this.getMPInstance(), c = new ServerModel(b).createEventObject(a), d = convertEvents("0", [c], b); return d; } }]), a;
  }();

  Array.prototype.forEach||(Array.prototype.forEach=Polyfill.forEach),Array.prototype.map||(Array.prototype.map=Polyfill.map),Array.prototype.filter||(Array.prototype.filter=Polyfill.filter),Array.isArray||(Array.prototype.isArray=Polyfill.isArray);function mParticle$1(){var a=this;// Only leaving this here in case any clients are trying to access mParticle.Store, to prevent from throwing
  /**
       * Initializes the mParticle instance. If no instanceName is provided, an instance name of `default_instance` will be used.
       * <p>
       * If you'd like to initiate multiple mParticle instances, first review our <a href="https://docs.mparticle.com/developers/sdk/web/multiple-instances/">doc site</a>, and ensure you pass a unique instance name as the third argument as shown below.
       * @method init
       * @param {String} apiKey your mParticle assigned API key
       * @param {Object} [config] an options object for additional configuration
       * @param {String} [instanceName] If you are self hosting the JS SDK and working with multiple instances, you would pass an instanceName to `init`. This instance will be selected when invoking other methods. See the above link to the doc site for more info and examples.
       */this.Store={},this._instances={},this.IdentityType=Types.IdentityType,this.EventType=Types.EventType,this.CommerceEventType=Types.CommerceEventType,this.PromotionType=Types.PromotionActionType,this.ProductActionType=Types.ProductActionType,"undefined"!=typeof window&&(this.isIOS=!!(window.mParticle&&window.mParticle.isIOS)&&window.mParticle.isIOS,this.config=window.mParticle&&window.mParticle.config?window.mParticle.config:{}),this.init=function(b,c,d){!c&&window.mParticle&&window.mParticle.config&&(console.warn("You did not pass a config object to mParticle.init(). Attempting to use the window.mParticle.config if it exists. Please note that in a future release, this may not work and mParticle will not initialize properly"),c=window.mParticle?window.mParticle.config:{}),d=(d&&0!==d.length?d:Constants.DefaultInstance).toLowerCase();var e=a._instances[d];e===void 0&&(e=new mParticleInstance(b,c,d),a._instances[d]=e),e.init(b,c,d);},this.getInstance=function(b){var c;return b?(c=a._instances[b.toLowerCase()],c?c:(console.log("You tried to initialize an instance named "+b+". This instance does not exist. Check your instance name or initialize a new instance with this name before calling it."),null)):(b=Constants.DefaultInstance,c=a._instances[b],c||(c=new mParticleInstance(b),a._instances[Constants.DefaultInstance]=c),c)},this.getDeviceId=function(){return a.getInstance().getDeviceId()},this.startNewSession=function(){a.getInstance().startNewSession();},this.endSession=function(){a.getInstance().endSession();},this.setLogLevel=function(b){a.getInstance().setLogLevel(b);},this.ready=function(b){a.getInstance().ready(b);},this.setAppVersion=function(b){a.getInstance().setAppVersion(b);},this.getAppName=function(){return a.getInstance().getAppName()},this.setAppName=function(b){a.getInstance().setAppName(b);},this.getAppVersion=function(){return a.getInstance().getAppVersion()},this.stopTrackingLocation=function(){a.getInstance().stopTrackingLocation();},this.startTrackingLocation=function(b){a.getInstance().startTrackingLocation(b);},this.setPosition=function(b,c){a.getInstance().setPosition(b,c);},this.startNewSession=function(){a.getInstance().startNewSession();},this.endSession=function(){a.getInstance().endSession();},this.logBaseEvent=function(b){a.getInstance().logBaseEvent(b);},this.logEvent=function(b,c,d,e){a.getInstance().logEvent(b,c,d,e);},this.logError=function(b,c){a.getInstance().logError(b,c);},this.logLink=function(b,c,d,e){a.getInstance().logLink(b,c,d,e);},this.logForm=function(b,c,d,e){a.getInstance().logForm(b,c,d,e);},this.logPageView=function(b,c,d){a.getInstance().logPageView(b,c,d);},this.upload=function(){a.getInstance().upload();},this.eCommerce={Cart:{add:function add(b,c){a.getInstance().eCommerce.Cart.add(b,c);},remove:function remove(b,c){a.getInstance().eCommerce.Cart.remove(b,c);},clear:function clear(){a.getInstance().eCommerce.Cart.clear();}},setCurrencyCode:function setCurrencyCode(b){a.getInstance().eCommerce.setCurrencyCode(b);},createProduct:function createProduct(b,c,d,e,f,g,h,i,j,k){return a.getInstance().eCommerce.createProduct(b,c,d,e,f,g,h,i,j,k)},createPromotion:function createPromotion(b,c,d,e){return a.getInstance().eCommerce.createPromotion(b,c,d,e)},createImpression:function createImpression(b,c){return a.getInstance().eCommerce.createImpression(b,c)},createTransactionAttributes:function createTransactionAttributes(b,c,d,e,f,g){return a.getInstance().eCommerce.createTransactionAttributes(b,c,d,e,f,g)},logCheckout:function logCheckout(b,c,d,e){a.getInstance().eCommerce.logCheckout(b,c,d,e);},logProductAction:function logProductAction(b,c,d,e,f){a.getInstance().eCommerce.logProductAction(b,c,d,e,f);},logPurchase:function logPurchase(b,c,d,e,f){a.getInstance().eCommerce.logPurchase(b,c,d,e,f);},logPromotion:function logPromotion(b,c,d,e){a.getInstance().eCommerce.logPromotion(b,c,d,e);},logImpression:function logImpression(b,c,d){a.getInstance().eCommerce.logImpression(b,c,d);},logRefund:function logRefund(b,c,d,e,f){a.getInstance().eCommerce.logRefund(b,c,d,e,f);},expandCommerceEvent:function expandCommerceEvent(b){return a.getInstance().eCommerce.expandCommerceEvent(b)}},this.setSessionAttribute=function(b,c){a.getInstance().setSessionAttribute(b,c);},this.setOptOut=function(b){a.getInstance().setOptOut(b);},this.setIntegrationAttribute=function(b,c){a.getInstance().setIntegrationAttribute(b,c);},this.getIntegrationAttributes=function(b){return a.getInstance().getIntegrationAttributes(b)},this.Identity={HTTPCodes:a.getInstance().Identity.HTTPCodes,aliasUsers:function aliasUsers(b,c){a.getInstance().Identity.aliasUsers(b,c);},createAliasRequest:function createAliasRequest(b,c){return a.getInstance().Identity.createAliasRequest(b,c)},getCurrentUser:function getCurrentUser(){return a.getInstance().Identity.getCurrentUser()},getUser:function getUser(b){return a.getInstance().Identity.getUser(b)},getUsers:function getUsers(){return a.getInstance().Identity.getUsers()},identify:function identify(b,c){a.getInstance().Identity.identify(b,c);},login:function login(b,c){a.getInstance().Identity.login(b,c);},logout:function logout(b,c){a.getInstance().Identity.logout(b,c);},modify:function modify(b,c){a.getInstance().Identity.modify(b,c);}},this.sessionManager={getSession:function getSession(){return a.getInstance()._SessionManager.getSession()}},this.Consent={createConsentState:function createConsentState(){return a.getInstance().Consent.createConsentState()},createGDPRConsent:function createGDPRConsent(b,c,d,e,f){return a.getInstance().Consent.createGDPRConsent(b,c,d,e,f)},createCCPAConsent:function createCCPAConsent(b,c,d,e,f){return a.getInstance().Consent.createGDPRConsent(b,c,d,e,f)}},this.reset=function(){a.getInstance().reset(a.getInstance());},this._resetForTests=function(b,c){"boolean"==typeof c?a.getInstance()._resetForTests(b,c,a.getInstance()):a.getInstance()._resetForTests(b,!1,a.getInstance());},this.configurePixel=function(b){a.getInstance().configurePixel(b);},this._setIntegrationDelay=function(b,c){a.getInstance()._setIntegrationDelay(b,c);},this._getIntegrationDelays=function(){return a.getInstance()._getIntegrationDelays()},this.getVersion=function(){return a.getInstance().getVersion()},this.generateHash=function(b){return a.getInstance().generateHash(b)},this.addForwarder=function(b){a.getInstance().addForwarder(b);},this._getActiveForwarders=function(){return a.getInstance()._getActiveForwarders()};}var mparticleInstance=new mParticle$1;"undefined"!=typeof window&&(window.mParticle=mparticleInstance,window.mParticle._BatchValidator=new _BatchValidator);

  module.exports = mparticleInstance;
  });

  var mParticle$1 = /*@__PURE__*/getDefaultExportFromCjs(mparticle_common);

  var lib = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypedEmitter = lightning.EventEmitter;
  });

  const platformEvents = new lib.TypedEmitter();
  class BasePlatform {
      async init() {
          console.log('init base platform')
          return;
      }
      shutdown() {
          Log.info('Shutdown event fallback');
      }
      errorMetricsHandler(message, visible, code, args = {}) {
          Log.info('errorMetricsHandler event fallback', {
              message,
              visible,
              code,
              args,
          });
      }
      dismissLoadingScreen() {
          Log.info('Dismiss loading screen event fallback');
      }
      showToaster(messageIdentifier) {
          Log.info('Showing Toaster fallback, with message: ', messageIdentifier);
      }
      async getHDMIConnectedStatus() {
          return true;
      }
      async getCloseCaptioningEnabled() {
          return false;
      }
      get deviceType() {
          return 'browser';
      }
      get screenHeight() {
          return window.innerHeight;
      }
      get screenWidth() {
          return window.innerWidth;
      }
      get hdmiConnectionRefreshInterval() {
          return 30000; // milliseconds
      }
      appActionMetricsHandler(action, args = {}) {
          Log.info('appActionMetricsHandler event fallback', {
              action,
              args,
          });
      }
      get keyMapping() {
          return {
              80: 'MediaPlayPause',
              70: 'MediaFastForward',
              82: 'MediaRewind',
          };
      }
      async _checkCCStatus() {
          const ccEnabled = await this.getCloseCaptioningEnabled();
          if (ccEnabled !== this._ccEnabled) {
              this._ccEnabled = ccEnabled;
              platformEvents.emit('closedCaptionsStatusChanged', ccEnabled);
          }
      }
      registerClosedCaptionsStatusListener(cb) {
          platformEvents.on('closedCaptionsStatusChanged', cb);
          Registry.clearInterval(this._ccInterval);
          this._ccInterval = Registry.setInterval(this._checkCCStatus.bind(this), 10000);
      }
      deregisterClosedCaptionsStatusListener(cb) {
          platformEvents.off('closedCaptionsStatusChanged', cb);
          Registry.clearInterval(this._ccInterval);
      }
  }

  class X1 extends BasePlatform {
      async _isBadgerActive() {
          return new Promise(resolve => {
              if (window.$badger && window.$badger.active()) {
                  resolve();
              }
              else {
                  document.addEventListener('onMoneyBadgerReady', () => {
                      resolve();
                  });
              }
          });
      }
      _setStaticDeviceCapabilities(deviceCapabilities) {
          const screenDimensions = deviceCapabilities.nativeDimensions;
          this._screenWidth = screenDimensions[0];
          this._screenHeight = screenDimensions[1];
      }
      async init() {
          if (!window.$badger) {
              const X1JavascriptAPI = document.createElement('script');
              X1JavascriptAPI.setAttribute('src', 'https://cdn.thor.comcast.com/sdk/money-badger.min.js');
              document.head.appendChild(X1JavascriptAPI);
          }
          await this._isBadgerActive();
          window.$badger
              .deviceCapabilities()
              .success(deviceCaps => {
              this._setStaticDeviceCapabilities(deviceCaps);
              return;
          })
              .failure(() => {
              throw new BadgerAccessError();
          });
      }
      async getHDMIConnectedStatus() {
          return new Promise((resolve, reject) => {
              window.$badger
                  .deviceCapabilities()
                  .success(deviceCaps => {
                  resolve(deviceCaps.hdcp.connected);
              })
                  .failure(() => {
                  reject(false);
                  throw new BadgerAccessError();
              });
          });
      }
      async getCloseCaptioningEnabled() {
          return new Promise((resolve, reject) => {
              window.$badger
                  .userPreferences()
                  .closedCaptioning()
                  .success(ccSettings => {
                  resolve(ccSettings.enabled);
              })
                  .failure(() => {
                  reject(false);
              });
          });
      }
      shutdown() {
          window.$badger.shutdown();
      }
      errorMetricsHandler(message, visible, code, args = {}) {
          window.$badger.errorMetricsHandler(message, visible, code, args);
      }
      dismissLoadingScreen() {
          window.$badger.dismissLoadingScreen();
      }
      showToaster(messageIdentifier) {
          window.$badger.showToaster(messageIdentifier);
      }
      get keyMapping() {
          return {
              179: 'MediaPlayPause',
              228: 'MediaFastForward',
              227: 'MediaRewind',
          };
      }
      get deviceType() {
          return 'X1';
      }
      appActionMetricsHandler(action, args = {}) {
          window.$badger.appActionMetricsHandler(action, args);
      }
  }

  class PAL {
      // Currently only used for browser fallbacks
      // Once additional platforms added will be extended with build time defined Platform files
      static getPlatform() {
          if (PAL.platform !== undefined) {
              return PAL.platform;
          }
          const userAgent = navigator.userAgent;
          if (userAgent && userAgent.search(/WPE/) > -1) {
              PAL.platform = new X1();
          }
          else {
              PAL.platform = new BasePlatform();
          }
          return PAL.platform;
      }
  }
  var Platform = PAL.getPlatform();

  class Analytics {
      init() {
          this.initMParticle();
          this.initErrorHandler();
      }
      initMParticle() {
          const mParticleConfig = {
              isDevelopmentMode: Settings.get('app', 'debug'),
              //logLevel: 'verbose',
              appName: 'NBC News X1',
              appVersion: Settings.get('app', 'version'),
          };
          mParticle$1.init('us1-0d3f7d9056927d47bb2cac6a11dee1c5', mParticleConfig);
      }
      initErrorHandler() {
          window.onerror = function (message, source, lineno, colno, error) {
              const errorMessage = typeof message === 'string' ? message : message.message;
              sharedInstance.error('Unhandled Exception', {
                  message: errorMessage,
                  location: `${source}: (${lineno}, ${colno})`,
                  error: JSON.stringify(error),
              });
          };
          window.addEventListener('error', function (event) {
              sharedInstance.error('Unhandled Exception', {
                  message: event.message,
                  location: `${event.filename}: (${event.lineno}, ${event.colno})`,
                  error: event.error ? JSON.stringify(event.error.stack) : '',
              });
          });
      }
      error(error, optional = {}) {
          const errorType = error instanceof Error ? error.name : error;
          const errorMetadata = {
              ...(error instanceof Error ? formatErrorMetadata(error) : {}),
              ...optional,
          };
          mParticle$1.logEvent('Error', mParticle$1.EventType.Other, {
              type: errorType,
              ...errorMetadata,
          });
          const errorMetricsParams = {
              visible: true,
              code: 'unhandled_exception',
              ...errorMetadata,
          };
          Platform.errorMetricsHandler(errorType, errorMetricsParams.visible, errorMetricsParams.code);
      }
      appLaunch() {
          mParticle$1.logEvent('App Launch', mParticle$1.EventType.Navigation);
      }
      contentLoaded(id, url, etag = '') {
          mParticle$1.logEvent('Content Loaded', mParticle$1.EventType.Other, {
              id: id,
              url: url,
              etag: etag,
          });
      }
  }
  function formatErrorMetadata(error) {
      let location = '';
      if (error.stack) {
          try {
              const matched = error.stack.match(/\/([\/\w-_\.]+\.js):(\d*):(\d*)/);
              if (matched) {
                  const [, filename, line, column] = matched;
                  location = `${filename}: (${line}, ${column})`;
              }
          }
          catch (error) {
              // Could not get file info from error
          }
      }
      return {
          message: error.message,
          location: location,
          error: error.stack,
      };
  }
  const sharedInstance = new Analytics();

  class Config {
      constructor(env) {
          this._configUrl = this.configUrl(env);
          this._ready = false;
          return new Proxy(this, {
              get(target, prop) {
                  if (prop in target) {
                      return target[prop];
                  }
                  if (target._ready && target._config) {
                      return target._config[prop];
                  }
                  else {
                      throw new ConfigNotReadyError();
                  }
              },
          });
      }
      async fetch() {
          const result = await fetch(this._configUrl, {
              method: 'GET',
              headers: {
                  Accept: 'application/json',
              },
              mode: 'cors',
          });
          if (result.ok) {
              console.log('config loaded')
              const root = await result.json();
              console.log('config', root)
              // TD: check agains schema for validity
              this._config = root;
              this._ready = true;
              return;
          }
          else {
              Log.info(result.statusText);
              sharedInstance.error('ServerError', {
                  id: 'config',
                  url: result.url,
                  code: result.status,
                  description: result.statusText,
              });
              throw new FetchError(result.statusText, result.status, result.url);
          }
      }
      configUrl(env) {
          const pid = Settings.get('app', 'provisioning');
          const version = Settings.get('app', 'version');
          return `https://deviceservices.nbcnews.com/config/ott/${pid}/${env}/${version}`;
      }
  }

  class Data {
      constructor(config) {
          this.current = null;
          this._lastModified = null;
          this._config = config;
      }
      async fetchBrandData(params) {
          const path = this._config.brands[params.for];
          const url = this._config.urls.apiBase + path;
          const result = await fetch(url, {
              method: 'GET',
              headers: {
                  Accept: 'application/json',
              },
              mode: 'cors',
          });
          if (result.ok) {
              const root = await result.json();
              this.current = root;
              this._lastModified = result.headers.get('last-modified');
              sharedInstance.contentLoaded('brand', result.url);
              return root;
          }
          else {
              throw new FetchError(result.statusText, result.status, result.url);
          }
      }
      async fetchShowFromCard(cardId) {
          const show = await this.fetchResource(cardId);
          return show;
      }
      async fetchPlaylistFromCard(cardId) {
          const playlist = await this.fetchResource(cardId);
          return playlist;
      }
      async fetchVideoFromId(videoId) {
          const video = await this.fetchResource(videoId);
          return video;
      }
      async fetchResource(resourceId) {
          const url = this._config.urls.apiBase + resourceId;
          const result = await fetch(url, {
              method: 'GET',
              headers: {
                  Accept: 'application/json',
              },
              mode: 'cors',
          });
          if (result.ok) {
              const json = await result.json();
              return json;
          }
          else {
              throw new FetchError(result.statusText, result.status, result.url);
          }
      }
      async fetchSearchQuery(query) {
          const url = this._config.urls.apiBase + 'ott/search?q=' + query;
          const result = await fetch(url, {
              method: 'GET',
              headers: {
                  Accept: 'application/json',
              },
              mode: 'cors',
          });
          if (result.ok) {
              const json = await result.json();
              return json.videos;
          }
          else {
              return [];
          }
      }
  }

  var BrandName;
  (function (BrandName) {
      BrandName["nbcnews"] = "nbcnews";
      BrandName["msnbc"] = "msnbc";
      BrandName["today"] = "today";
  })(BrandName || (BrandName = {}));

  var Events = new lib.TypedEmitter();

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Colors
   *
   * Contains global color style information to easily maintain consistency throughout components.
   */

  /**
   * Combines rgb hex string and alpha into argb hexadecimal number
   * @param {string} hex - 6 alphanumeric characters between 0-f
   * @param {number} [alpha] - number between 0-100 (0 is invisible, 100 is opaque)
   */
  function getHexColor(hex, alpha = 100) {
    if (!hex) {
      return 0x00;
    }

    let hexAlpha = Math.round((alpha / 100) * 255).toString(16);
    let str = `0x${hexAlpha}${hex}`;
    return parseInt(Number(str), 10);
  }

  /**
   * Pair color values with color names in the "Neutral" palette
   */
  const COLORS_NEUTRAL = {
    dark1: '000000',
    dark2: '080808',
    dark3: '101010',
    light1: 'FFFFFF',
    light2: 'F5F5F5',
    light3: 'E8E8E8'
  };

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  /**
   * Returns a styles object for use by components
   * @param {Object|function} styles - Object or callback that takes theme as an argument, ultimately the returned value
   * @param {Object} theme - theme to be provided to styles
   */
  var createStyles = (styles, theme) => {
    return typeof styles === 'function' ? styles(theme) : styles;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var lng = window.lng;

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Helpers for lng.Tools.getRoundRect
   */
  const RoundRect = {
    /**
     * Returns a value that will render as the given width (w)
     * when passed to lng.Tools.getRoundRect
     * @param {number} w - px value for expected width
     * @param {*} options
     * @param {number} options.padding - px value for both left and right padding
     * @param {number} options.paddingLeft - px value for left padding, overrides options.padding
     * @param {number} options.paddingRight - px value for right padding, overrides options.padding
     * @param {number} options.strokeWidth - px value for stroke width
     */
    getWidth(w, options = {}) {
      const { padding, paddingLeft, paddingRight, strokeWidth } = {
        padding: 0,
        paddingLeft: 0,
        paddingRight: 0,
        strokeWidth: 0,
        ...options
      };

      if (!w) return 0;

      return (
        w - (paddingLeft || padding) - (paddingRight || padding) - strokeWidth
      );
    },
    /**
     * Returns a value that will render as the given height (h)
     * when passed to lng.Tools.getRoundRect
     * @param {number} h - px value for expected width
     * @param {*} options
     * @param {number} options.padding - px value for both bottom and top padding
     * @param {number} options.paddingBottom - px value for bottom padding, overrides options.padding
     * @param {number} options.paddingTop - px value for top padding, overrides options.padding
     * @param {number} options.strokeWidth - px value for stroke width
     */
    getHeight(h, options = {}) {
      const { padding, paddingBottom, paddingTop, strokeWidth } = {
        padding: 0,
        paddingBottom: 0,
        paddingTop: 0,
        strokeWidth: 0,
        ...options
      };

      if (!h) return 0;

      return (
        h - (paddingBottom || padding) - (paddingTop || padding) - strokeWidth
      );
    }
  };

  /**
   * Merges two objects together and returns the duplicate.
   *
   * @param {Object} target - object to be cloned
   * @param {Object} [object] - secondary object to merge into clone
   */
  function clone(target, object) {
    const _clone = { ...target };
    if (!object || target === object) return _clone;

    for (let key in object) {
      const value = object[key];
      if (target.hasOwnProperty(key)) {
        _clone[key] = getMergeValue(key, target, object);
      } else {
        _clone[key] = value;
      }
    }

    return _clone;
  }

  function getMergeValue(key, target, object) {
    const targetVal = target[key];
    const objectVal = object[key];
    const targetValType = typeof targetVal;
    const objectValType = typeof objectVal;

    if (
      targetValType !== objectValType ||
      objectValType === 'function' ||
      Array.isArray(objectVal)
    ) {
      return objectVal;
    }

    if (objectVal && objectValType === 'object') {
      return clone(targetVal, objectVal);
    }

    return objectVal;
  }

  /**
   * Returns the rendered width of a given text texture
   * @param {Object} text - text texture properties
   * @param {string} text.text - text value
   * @param {string} text.fontStyle - css font-style property
   * @param {(string|number)} text.fontWeight - css font-weight property
   * @param {string} [fontSize=0] - css font-size property (in px)
   * @param {string} [text.fontFamily=sans-serif] - css font-weight property
   * @param {string} text.fontFace - alias for fontFamily
   *
   * @returns {number} text width
   * */
  function measureTextWidth(text = {}) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const {
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily = text.fontFace || 'sans-serif'
    } = text;
    const fontCss = [
      fontStyle,
      fontWeight,
      fontSize ? `${fontSize}px` : '0',
      `'${fontFamily}'`
    ]
      .filter(Boolean)
      .join(' ');
    ctx.font = fontCss;
    const textMetrics = ctx.measureText(text.text || '');

    return Math.round(textMetrics.width);
  }

  /**
   * Returns first argument that is a number. Useful for finding ARGB numbers. Does not convert strings to numbers
   * @param {...*} number - maybe a number
   **/
  function getFirstNumber(...numbers) {
    return numbers.find(Number.isFinite);
  }

  /**
   * Naively looks for dimensional prop (i.e. w, h, x, y, etc.), first searching for
   * a transition target value then defaulting to the current set value
   * @param {string} prop - property key
   * @param {lng.Component} component - Lightning component to operate against
   */
  function getDimension(prop, component) {
    if (!component) return 0;
    const transition = component.transition(prop);
    if (transition.isRunning()) return transition.targetValue;
    return component[prop];
  }

  const getX = getDimension.bind(null, 'x');
  const getY = getDimension.bind(null, 'y');
  const getW = component =>
    getDimension('w', component) || component.renderWidth;
  const getH = component =>
    getDimension('h', component) || component.renderHeight;

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const gradientColor = COLORS_NEUTRAL.light2;
  ({
    duration: 0.6,
    actions: [
      {
        p: 'colorUl',
        v: {
          0: getHexColor(gradientColor, 72),
          1: getHexColor(gradientColor, 56)
        }
      },
      {
        p: 'colorUr',
        v: {
          0: getHexColor(gradientColor, 24),
          1: getHexColor(gradientColor, 16)
        }
      },
      {
        p: 'colorBr',
        v: { 0: 0x00, 1: getHexColor(gradientColor, 0) }
      },
      {
        p: 'colorBl',
        v: {
          0: getHexColor(gradientColor, 24),
          1: getHexColor(gradientColor, 16)
        }
      }
    ]
  });

  /**
  * Copyright 2020 Comcast Cable Communications Management, LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  * SPDX-License-Identifier: Apache-2.0
  */

  function withStyles(Base, styles, theme) {
    const _theme = theme || Base.theme;
    const _styles = Base.styles ? clone(Base.styles, createStyles(styles, _theme)) : createStyles(styles, _theme);

    return class extends Base {
      static get name() { return Base.name }
      static get styles() { return _styles };
      get styles() { return _styles }
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  class Icon extends lng.Component {
    static _template() {
      return {
        color: 0xffffffff,
        w: 0,
        h: 0
      };
    }

    get icon() {
      return this._icon;
    }

    set icon(icon) {
      this._icon = icon;
      this._update();
    }

    _init() {
      this._update();
    }

    _update() {
      const { icon, w, h } = this;
      const template = getIconTemplate(icon, w, h);
      this.patch(template);
    }
  }

  const [isSvgTag, isSvgURI, isImageURI] = [
    /^<svg.*<\/svg\>$/,
    /\.svg$/,
    /\.(a?png|bmp|gif|ico|cur|jpe?g|pjp(eg)?|jfif|tiff?|webp)$/
  ].map(regex => RegExp.prototype.test.bind(regex));

  function getIconTemplate(icon, w, h) {
    const template = { w, h };

    switch (true) {
      case isSvgTag(icon):
        template.texture = lng.Tools.getSvgTexture(
          `data:image/svg+xml,${encodeURIComponent(icon)}`,
          w,
          h
        );
        break;
      case isSvgURI(icon):
        template.texture = lng.Tools.getSvgTexture(icon, w, h);
        break;
      case isImageURI(icon):
        template.src = icon;
        break;
    }
    return template;
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const styles = {
    w: 150,
    h: 40,
    radius: 0,
    background: { color: 0xff1f1f1f },
    icon: { color: 0xffffffff },
    text: {
      fontSize: 20,
      color: 0xffffffff
    },
    padding: 50,
    stroke: {
      color: 0x00,
      weight: 2
    },
    focused: {
      background: { color: 0xffffffff },
      text: { color: 0xff1f1f1f },
      icon: { color: 0xff1f1f1f }
    }
  };

  class Button extends lng.Component {
    static _template() {
      return {
        w: this.styles.w,
        h: this.styles.h,
        radius: this.styles.radius,
        strokeColor: this.styles.stroke.color,
        strokeWeight: this.styles.stroke.weight,
        Content: {
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2,
          flex: {
            direction: 'row',
            alignContent: 'center',
            alignItems: 'center'
          },
          Icon: {
            type: Icon
          },
          // TODO: Wonky lineHeight / fontsize from Lightning
          // Move title down 2 pixels to _visually_ center it
          // inside the button
          Title: { y: 2 }
        },
        Stroke: {
          zIndex: -1,
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2
        }
      };
    }

    _construct() {
      this._focused = false;
      this._whenEnabled = new Promise(
        resolve => (this._enable = resolve),
        console.error
      );
      this._strokeWeight = 2;
      this._strokeColor = 0x00;
    }

    _init() {
      this._update();
    }

    _focus() {
      if (this._smooth === undefined) this._smooth = true;
      this._focused = true;
      this._update();
    }

    _unfocus() {
      this._focused = false;
      this._update();
    }

    _updateColor() {
      const color = this._focused
        ? getFirstNumber(
            this.focusedBackground,
            this.styles.focused.background.color
          )
        : getFirstNumber(this.background, this.styles.background.color);
      if (this._smooth) {
        this.smooth = { color };
      } else {
        this.color = color;
      }
    }

    _updateTitle() {
      if (this.title) {
        this._Title.text = {
          ...this.styles.text,
          fontColor: this.styles.text.color,
          fontSize: this.fontSize || this.styles.text.fontSize,
          fontFamily:
            this.styles.text.fontFace ||
            this.styles.text.fontFamily ||
            this.stage._options.defaultFontFace,
          text: this.title
        };

        const color = this._focused
          ? getFirstNumber(this.focusedTextColor, this.styles.focused.text.color)
          : getFirstNumber(this.textColor, this.styles.text.color);
        if (this._smooth) {
          this._Title.smooth = { color };
        } else {
          this._Title.color = color;
        }
      } else {
        this._Title.texture = false;
      }
    }

    _updateIcon() {
      if (this.icon) {
        const { color, size, spacing, src } = this.icon;
        this._Icon.patch({
          w: size,
          h: size,
          icon: src,
          flexItem: { marginRight: this.title ? spacing : 0 }
        });

        const iconColor = this._focused
          ? getFirstNumber(this.focusedIconColor, this.styles.focused.icon.color)
          : getFirstNumber(color, this.styles.icon.color);
        if (this._smooth) {
          this._Icon.smooth = { color: iconColor };
        } else {
          this._Icon.color = iconColor;
        }
      } else {
        this._Icon.patch({
          w: 0,
          h: 0,
          texture: false,
          flexItem: false
        });
      }
    }

    _updateStroke() {
      if (this.stroke && !this._focused) {
        const radius = this.radius || this.styles.radius;

        this.texture = lng.Tools.getRoundRect(
          RoundRect.getWidth(this.w),
          RoundRect.getHeight(this.h),
          radius,
          0x00,
          true,
          0xffffffff
        );

        this._Stroke.color = this.strokeColor;
        this._Stroke.texture = lng.Tools.getRoundRect(
          RoundRect.getWidth(this.w),
          RoundRect.getHeight(this.h),
          radius,
          this.strokeWeight,
          0xffffffff,
          true,
          this.background
        );
      } else {
        const radius = this.radius || this.styles.radius;
        this.texture = lng.Tools.getRoundRect(
          RoundRect.getWidth(this.w),
          RoundRect.getHeight(this.h),
          radius
        );
        this._Stroke.texture = false;
      }
    }

    _updateWidth() {
      if (!this.fixed) {
        const iconSize = this._icon ? this._icon.size + this._icon.spacing : 0;
        const padding = getFirstNumber(this.padding, this.styles.padding, 10);
        const w =
          measureTextWidth(this._Title.text || {}) + padding * 2 + iconSize;

        if (w && w !== this.w) {
          this.w = w > this.styles.w ? w : this.styles.w;
          this.fireAncestors('$itemChanged');
          this.signal('buttonWidthChanged', { w: this.w });
        }
      }
    }

    _update() {
      this._whenEnabled.then(() => {
        this._updateColor();
        this._updateTitle();
        this._updateIcon();
        this._updateStroke();
        this._updateWidth();
      });
    }

    _handleEnter() {
      if (typeof this.onEnter === 'function') {
        this.onEnter(this);
      }
    }

    get radius() {
      return this._radius;
    }

    set radius(radius) {
      if (this._radius !== radius) {
        this._radius = radius;
        this._update();
      }
    }

    get title() {
      return this._title;
    }

    set title(title) {
      if (this._title !== title) {
        this._title = title;
        this._update();
      }
    }

    get icon() {
      return this._icon;
    }

    set icon({ src, size = 20, spacing = 5, color = 0xffffffff }) {
      if (src) {
        this._icon = { src, size, spacing, color };
      } else {
        this._icon = null;
      }
      this._update();
    }

    get strokeWeight() {
      return this._strokeWeight;
    }

    set strokeWeight(strokeWeight) {
      if (this._strokeWeight !== strokeWeight) {
        this._strokeWeight = strokeWeight;
        this._update();
      }
    }

    get strokeColor() {
      return this._strokeColor;
    }

    set strokeColor(strokeColor) {
      if (this._strokeColor !== strokeColor) {
        this._strokeColor = strokeColor;
        this._update();
      }
    }

    get stroke() {
      return this._stroke;
    }

    set stroke(stroke) {
      if (this._stroke !== stroke) {
        this._stroke = stroke;
        this._update();
      }
    }

    get w() {
      return this._w;
    }

    set w(w) {
      if (this._w !== w) {
        this._w = w;
        this._update();
      }
    }

    set label(label) {
      this._label = label;
    }

    get label() {
      return this._label || this._title;
    }

    get announce() {
      // TODO - Localization?
      // Do we need a locale file with
      // component translations?
      return this.label + ', Button';
    }

    get _Content() {
      return this.tag('Content');
    }

    get _Title() {
      return this.tag('Content.Title');
    }
    get _Icon() {
      return this.tag('Content.Icon');
    }
    get _Stroke() {
      return this.tag('Stroke');
    }
  }

  withStyles(Button, styles);

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  class FocusManager extends lng.Component {
    constructor(stage) {
      super(stage);
      this.patch({ Items: {} });
      this._direction = this.direction || 'row';
    }

    _construct() {
      this._selectedIndex = 0;
    }

    get direction() {
      return this._direction;
    }

    set direction(direction) {
      this._direction = direction;
      let state = {
        none: 'None',
        column: 'Column',
        row: 'Row'
      }[direction];

      if (state) {
        this._setState(state);
      }
    }

    get Items() {
      return this.tag('Items');
    }

    get items() {
      return this.Items.children;
    }

    set items(items) {
      this.Items.childList.clear();
      this._selectedIndex = 0;
      this.appendItems(items);
    }

    appendItems(items = []) {
      this.Items.childList.a(items);
      this._refocus();
    }

    get selected() {
      return this.Items.children[this.selectedIndex];
    }

    get selectedIndex() {
      return this._selectedIndex;
    }

    set selectedIndex(index) {
      const prevSelected = this.selected;
      if (index !== this._selectedIndex) {
        this._selectedIndex = index;
      }
      // Have items update (change height or width) before we render
      this._refocus();
      if (this.selected) {
        this.render(this.selected, prevSelected);
        this.signal('selectedChange', this.selected, prevSelected);
      }
    }

    // Override
    render() {}

    selectPrevious() {
      if (this.selectedIndex > 0) {
        let prevIndex = this.selectedIndex - 1;
        let previous = this.items[prevIndex];
        while (prevIndex && previous.skipFocus) {
          this._selectedIndex = prevIndex;
          this.render(previous, this.items[prevIndex + 1]);
          prevIndex -= 1;
          previous = this.items[prevIndex];
        }
        this.selectedIndex = prevIndex;
        return true;
      } else if (this.wrapSelected) {
        this.selectedIndex = this.Items.children.length - 1;
        return true;
      }
      return false;
    }

    selectNext() {
      if (this.selectedIndex < this.Items.children.length - 1) {
        let nextIndex = this.selectedIndex + 1;
        let next = this.items[nextIndex];
        while (nextIndex < this.items.length - 1 && next.skipFocus) {
          this._selectedIndex = nextIndex;
          this.render(next, this.items[nextIndex - 1]);
          nextIndex += 1;
          next = this.items[nextIndex];
        }
        this.selectedIndex = nextIndex;
        return true;
      } else if (this.wrapSelected) {
        this.selectedIndex = 0;
        return true;
      }
      return false;
    }

    _getFocused() {
      let { selected } = this;
      // Make sure we're focused on a component
      if (selected) {
        if (selected.focusRef) {
          return selected.tag(selected.focusRef);
        } else if (selected.cparent) {
          return selected;
        }
      }
      return this;
    }

    static _states() {
      return [
        class None extends this {},
        class Row extends this {
          _handleLeft() {
            return this.selectPrevious();
          }

          _handleRight() {
            return this.selectNext();
          }
        },

        class Column extends this {
          _handleUp() {
            return this.selectPrevious();
          }

          _handleDown() {
            return this.selectNext();
          }
        }
      ];
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  class Column extends FocusManager {
    static _template() {
      return {
        direction: 'column',
        itemTransition: {
          duration: 0.4,
          timingFunction: 'cubic-bezier(0.20, 1.00, 0.30, 1.00)'
        }
      };
    }

    _construct() {
      super._construct();
      this._smooth = false;
      this._itemSpacing = 0;
      this._scrollIndex = 0;
      this._whenEnabled = new Promise(resolve => (this._firstEnable = resolve));
      this._h = this.stage.h;
    }

    _init() {
      this._updateLayout();
    }

    _focus() {
      this.items.forEach(item => (item.parentFocus = true));
    }

    _unfocus() {
      this.items.forEach(item => (item.parentFocus = false));
    }

    selectNext() {
      this._smooth = true;
      return super.selectNext();
    }

    selectPrevious() {
      this._smooth = true;
      return super.selectPrevious();
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollUp() {
      return (
        this._itemsY < 0 &&
        (this._lastScrollIndex
          ? this.selectedIndex < this._lastScrollIndex
          : this.selectedIndex >= this._scrollIndex)
      );
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollDown() {
      const lastChild = this.Items.childList.last;
      return (
        this.selectedIndex > this._scrollIndex &&
        // end of Items container < end of last item
        Math.abs(this._itemsY - this.h) <
          lastChild.y + this.Items.childList.last.h
      );
    }

    render(next, prev) {
      if (this.plinko && prev && (prev.currentItem || prev.selected)) {
        next.selectedIndex = this._getIndexOfItemNear(next, prev);
      }

      this._whenEnabled.then(() => {
        const scrollOffset = (this.Items.children[this._scrollIndex] || { y: 0 })
          .y;
        const lastChild = this.Items.childList.last;
        const shouldScroll =
          lastChild && (this.shouldScrollUp() || this.shouldScrollDown());

        if (shouldScroll) {
          const scrollItem =
            this.selectedIndex > this._lastScrollIndex
              ? this.Items.children[this._lastScrollIndex - this._scrollIndex]
              : this.selected;
          if (this._smooth) {
            this.Items.smooth = {
              y: [
                -scrollItem.transition('y').targetValue +
                  (scrollItem === this.selected ? scrollOffset : 0),
                this.itemTransition
              ]
            };
          } else {
            this.Items.patch({
              y: -scrollItem.y + (scrollItem === this.selected ? scrollOffset : 0)
            });
          }
        }

        this.onScreenEffect(
          this.Items.children.filter((child, index) => {
            const y = getY(child);
            const { h } = child;
            const withinLowerBounds = y + h + this._itemsY > 0;
            const withinUpperBounds = y + this._itemsY < this.h;

            return withinLowerBounds && withinUpperBounds;
          })
        );
      });
    }

    _updateLayout() {
      this._whenEnabled.then(() => {
        let nextY = 0;
        let nextW = 0;
        // layout items in row
        for (let i = 0; i < this.Items.children.length; i++) {
          const child = this.Items.children[i];
          nextW = Math.max(nextW, getW(child));
          if (this._smooth) {
            child.smooth = { y: [nextY, this.itemTransition] };
          } else {
            child.patch({ y: nextY });
          }
          nextY += this.itemSpacing + child.h;
        }
        this.patch({ w: nextW });

        const lastChild = this.Items.childList.last;
        const endOfLastChild = lastChild ? getY(lastChild) + lastChild.h : 0;
        const scrollOffset = (this.Items.children[this._scrollIndex] || { y: 0 })
          .y;

        // determine when to stop scrolling down
        if (endOfLastChild > this.h) {
          for (let i = this.Items.children.length - 1; i >= 0; i--) {
            const child = this.Items.children[i];
            const childY = getY(child);
            if (childY + this.h - scrollOffset > endOfLastChild) {
              this._lastScrollIndex = i;
            } else {
              break;
            }
          }
        }
        this.render(this.selected, null);
      });
    }

    // finds the index of the item with the closest middle to the previously selected item
    _getIndexOfItemNear(selected, prev) {
      // edge case
      if (selected.items.length < 2) return 0;

      let prevItem = prev.selected || prev.currentItem;
      let prevOffset = prev.transition('x').targetValue || 0;
      let [itemX] = prevItem.core.getAbsoluteCoords(-prevOffset, 0);
      let prevMiddle = itemX + prevItem.w / 2;

      // set the first item to be closest
      let closest = selected.items[0];
      let closestMiddle = closest.core.getAbsoluteCoords(0, 0)[0] + closest.w / 2;

      // start at the 2nd item
      for (let i = 1; i < selected.items.length; i++) {
        const item = selected.items[i];
        const middle = item.core.getAbsoluteCoords(0, 0)[0] + item.w / 2;

        if (
          Math.abs(middle - prevMiddle) < Math.abs(closestMiddle - prevMiddle)
        ) {
          // current item is the closest
          closest = item;
          closestMiddle = middle;
        } else {
          // previous index is the closest, return it
          return i - 1;
        }
      }
      // last index is the closest
      return selected.items.length - 1;
    }

    get itemSpacing() {
      return this._itemSpacing;
    }

    set itemSpacing(itemSpacing) {
      if (itemSpacing !== this._itemSpacing) {
        this._itemSpacing = itemSpacing;
        this._updateLayout();
      }
    }

    get scrollIndex() {
      return this._scrollIndex;
    }

    set scrollIndex(scrollIndex) {
      if (scrollIndex !== this._scrollIndex) {
        this._scrollIndex = scrollIndex;
        this._updateLayout();
      }
    }

    get _itemsY() {
      return getY(this.Items);
    }

    appendItems(items = []) {
      let itemWidth = this.renderWidth;

      items.forEach(item => {
        item.parentFocus = this.hasFocus();
        item = this.Items.childList.a(item);
        item.w = getW(item) || itemWidth;
      });
      this.stage.update();
      this._updateLayout();
    }

    scrollTo(index, duration = this.itemTransition.duration * 100) {
      if (duration === 0) this.selectedIndex = index;

      for (let i = 0; i !== Math.abs(this.selectedIndex - index); i++) {
        setTimeout(() => {
          this.selectedIndex > index ? this.selectPrevious() : this.selectNext();
        }, duration * i);
      }
      this.Items.transition('y').on('finish', () => (this._smooth = false));
    }

    $itemChanged() {
      this._updateLayout();
    }

    $removeItem(item) {
      if (item) {
        let wasSelected = item === this.selected;
        this.Items.childList.remove(item);
        this._updateLayout();

        if (wasSelected || this.selectedIndex >= this.items.length) {
          // eslint-disable-next-line no-self-assign
          this.selectedIndex = this._selectedIndex;
        }

        if (!this.items.length) {
          this.fireAncestors('$columnEmpty');
        }
      }
    }

    $columnChanged() {
      this._updateLayout();
    }

    // can be overridden
    onScreenEffect() {}
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  class FadeShader extends lng.shaders.WebGLDefaultShader {
    constructor(context) {
      super(context);
      this._margin = { left: 0, right: 0 };
    }

    set positionLeft(v) {
      this._positionLeft = v;
    }

    set positionRight(v) {
      this._positionRight = v;
    }

    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;

      if (this._positionLeft === 0) {
        this._positionLeft = 0.001;
      }
      if (this._positionRight === 0) {
        this._positionRight = 0.001;
      }

      const renderPrecision = this.ctx.stage.getRenderPrecision();
      this._setUniform(
        'margin',
        [
          this._positionLeft * renderPrecision,
          this._positionRight * renderPrecision
        ],
        this.gl.uniform1fv
      );
      this._setUniform(
        'resolution',
        new Float32Array([
          owner._w * renderPrecision,
          owner._h * renderPrecision
        ]),
        this.gl.uniform2fv
      );
    }
  }

  FadeShader.fragmentShaderSource = `
  #ifdef GL_ES
  precision lowp float;
  #endif

  #define PI 3.14159265359

  varying vec2 vTextureCoord;
  varying vec4 vColor;

  uniform sampler2D uSampler;
  uniform vec2 resolution;
  uniform float margin[2];

  void main() {
      vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
      vec2 halfRes = 0.5 * resolution.xy;
      vec2 point = vTextureCoord.xy * resolution;


      vec2 pos1 = vec2(point.x, point.y);
      vec2 pos2 = pos1;
      pos2.x += margin[0];

      vec2 d = pos2 - pos1;
      float t = dot(pos1, d) / dot(d, d);
      t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));

      vec2 pos3 = vec2(vTextureCoord.x * resolution.x, vTextureCoord.y);
      pos3.x -= resolution.x - margin[1];
      vec2 pos4 = vec2(vTextureCoord.x + margin[1], vTextureCoord.y);

      vec2 d2 = pos4 - pos3;
      float t2 = dot(pos3, d2) / dot(d2, d2);
      t2 = smoothstep(0.0, 1.0, clamp(t2, 0.0, 1.0));

      color = mix(vec4(0.0), color, t);
      color = mix(color, vec4(0.0), t2);

      gl_FragColor = color;
  }
`;

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  class MarqueeText extends lng.Component {
    static _template() {
      return {
        TextClipper: {
          boundsMargin: [], // overwrite boundsMargin so text won't de-render if moved offscreen
          TextBox: {
            Text: {},
            TextLoopTexture: {}
          }
        }
      };
    }

    get title() {
      return ((this._Text && this._Text.text) || {}).text;
    }

    set title(text) {
      this.patch({
        TextClipper: {
          w: this.finalW + 14,
          h: text.lineHeight + 10,
          TextBox: {
            Text: {
              rtt: true,
              text: { ...text }
            },
            TextLoopTexture: {}
          }
        }
      });
      this._Text.on('txLoaded', () => {
        if (this.autoStart) {
          this.startScrolling();
        }
      });
      this._Text.loadTexture();
      this._updateShader(this.finalW);
      this._scrolling && this.startScrolling();
    }

    set color(color) {
      this.tag('TextBox.Text').smooth = { color };
    }

    startScrolling(finalW = this.finalW) {
      if (this._textRenderedW === 0) {
        this._Text.on('txLoaded', () => {
          this.startScrolling();
        });
      }

      if (this._textRenderedW > finalW - this._fadeW) {
        this._scrolling = true;
        this._TextLoopTexture.x = this._textRenderedW + this._offset;
        this._TextLoopTexture.texture = this._Text.getTexture();
        this._updateShader(finalW);
        this._updateAnimation();
        this._scrollAnimation.start();
      } else {
        // in case the metadata width gets larger on focus and the text goes from being clipped to not
        this._TextClipper.shader = null;
        if (this._Text.text && this._Text.text.textAlign === 'center') {
          this._centerText(finalW);
        }
        this._scrolling = false;
      }
    }

    stopScrolling(finalW = this.finalW) {
      this._scrolling = false;
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this._TextLoopTexture.texture = null;
      }
      this._updateShader(finalW);
    }

    _updateShader(finalW) {
      this.stage.update();
      this._Text.loadTexture();
      this._TextClipper.patch({
        w: finalW > 0 ? finalW + this._fadeW / 2 : 0,
        shader: { type: FadeShader, positionLeft: 0, positionRight: this._fadeW },
        rtt: true
      });
    }

    _updateAnimation() {
      this._scrollAnimation && this._scrollAnimation.stopNow();
      this._scrollAnimation = this.animation({
        duration: this._textRenderedW / 50,
        delay: isNaN(this.delay) ? 1.5 : this.delay,
        repeat: isNaN(this.repeat) ? -1 : this.repeat,
        actions: [
          {
            t: 'TextBox',
            p: 'x',
            v: {
              sm: 0,
              0: { v: 0 },
              0.5: { v: -(this._textRenderedW + this._offset) }
            }
          },
          {
            t: 'TextClipper',
            p: 'shader.positionLeft',
            v: {
              sm: 0,
              0: { v: 0 },
              0.1: { v: this._fadeW },
              0.4: { v: this._fadeW },
              0.5: { v: 0 }
            }
          }
        ]
      });
    }

    _centerText(finalW) {
      this._TextBox.x = ((finalW || this.finalW) - this._textRenderedW) / 2;
    }

    get _TextClipper() {
      return this.tag('TextClipper');
    }
    get _TextBox() {
      return this.tag('TextBox');
    }
    get _Text() {
      return this.tag('Text');
    }
    get _TextLoopTexture() {
      return this.tag('TextLoopTexture');
    }
    get _offset() {
      return 32;
    }
    get _fadeW() {
      return 30;
    }
    get _textRenderedW() {
      return this._Text.renderWidth;
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Row extends FocusManager {
    static _template() {
      return {
        direction: 'row',
        itemTransition: {
          duration: 0.4,
          timingFunction: 'cubic-bezier(0.20, 1.00, 0.30, 1.00)'
        }
      };
    }

    _construct() {
      super._construct();
      this._smooth = false;
      this._itemSpacing = 0;
      this._scrollIndex = 0;
      this._whenEnabled = new Promise(resolve => (this._firstEnable = resolve));
      this._w = this.stage.w;
    }

    _init() {
      this._updateLayout();
    }

    _focus() {
      this.items.forEach(item => (item.parentFocus = true));
    }

    _unfocus() {
      this.items.forEach(item => (item.parentFocus = false));
    }

    selectNext() {
      this._smooth = true;
      return super.selectNext();
    }

    selectPrevious() {
      this._smooth = true;
      return super.selectPrevious();
    }

    // TODO: can be documented in API when lastScrollIndex is made public

    shouldScrollLeft() {
      return (
        this._itemsX < 0 &&
        (this._lastScrollIndex
          ? this.selectedIndex < this._lastScrollIndex
          : this.selectedIndex >= this._scrollIndex)
      );
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollRight() {
      const lastChild = this.Items.childList.last;
      return (
        this.selectedIndex > this._scrollIndex &&
        // end of Items container < end of last item
        Math.abs(this._itemsX - this.w) <
          lastChild.x + this.Items.childList.last.w
      );
    }

    render() {
      this._whenEnabled.then(() => {
        const scrollOffset = (this.Items.children[this._scrollIndex] || { x: 0 })
          .x;
        const lastChild = this.Items.childList.last;
        const shouldScroll =
          lastChild && (this.shouldScrollLeft() || this.shouldScrollRight());

        if (shouldScroll) {
          const scrollItem =
            this.selectedIndex > this._lastScrollIndex
              ? this.Items.children[this._lastScrollIndex - this._scrollIndex]
              : this.selected;
          if (this._smooth) {
            this.Items.smooth = {
              x: [
                -scrollItem.transition('x').targetValue +
                  (scrollItem === this.selected ? scrollOffset : 0),
                this.itemTransition
              ]
            };
          } else {
            this.Items.patch({
              x: -scrollItem.x + (scrollItem === this.selected ? scrollOffset : 0)
            });
          }
        }

        this.onScreenEffect(
          this.Items.children.filter((child, idx) => {
            const x = getX(child);
            const { w } = child;
            const withinLowerBounds = x + w + this._itemsX > 0;
            const withinUpperBounds = x + this._itemsX < this.w;
            return withinLowerBounds && withinUpperBounds;
          })
        );
      });
    }

    _updateLayout() {
      let nextX = 0;
      let nextH = 0;
      // layout items in row
      for (let i = 0; i < this.Items.children.length; i++) {
        const child = this.Items.children[i];
        nextH = Math.max(nextH, getH(child));
        if (this._smooth) {
          child.smooth = { x: [nextX, this.itemTransition] };
        } else {
          child.patch({ x: nextX });
        }
        nextX += this.itemSpacing + child.w;
      }
      this.patch({ h: nextH });

      const lastChild = this.Items.childList.last;
      const endOfLastChild = lastChild ? getX(lastChild) + lastChild.w : 0;
      const scrollOffset = (this.Items.children[this._scrollIndex] || { x: 0 }).x;

      // determine when to stop scrolling right
      if (endOfLastChild > this.w) {
        for (let i = this.Items.children.length - 1; i >= 0; i--) {
          const child = this.Items.children[i];
          const childX = getX(child);
          if (childX + this.w - scrollOffset > endOfLastChild) {
            this._lastScrollIndex = i;
          } else {
            break;
          }
        }
      }
      this.render(this.selected, null);
    }

    get itemSpacing() {
      return this._itemSpacing;
    }

    set itemSpacing(itemSpacing) {
      if (itemSpacing !== this._itemSpacing) {
        this._itemSpacing = itemSpacing;
        this._updateLayout();
      }
    }

    get scrollIndex() {
      return this._scrollIndex;
    }

    set scrollIndex(scrollIndex) {
      if (scrollIndex !== this._scrollIndex) {
        this._scrollIndex = scrollIndex;
        this._updateLayout();
      }
    }

    get _itemsX() {
      return getX(this.Items);
    }

    appendItems(items = []) {
      let itemHeight = this.renderHeight;

      items.forEach(item => {
        item.parentFocus = this.hasFocus();
        item = this.Items.childList.a(item);
        item.h = item.h || itemHeight;
      });
      this.stage.update();
      this._updateLayout();
    }

    $itemChanged() {
      this._updateLayout();
    }

    // can be overridden
    onScreenEffect() {}
  }

  class CellSelectedPayload {
      constructor(row, cell) {
          this.row = row;
          this.cell = cell;
      }
  }

  const IMG_REGEX = /(.+)(\/i\/)(.+\.)(.+)$/;
  const REPLACE_PATTERN = '$1/j/$3{w};{h};7;80;5.$4';
  function NBCDAimsUrl(baseUrl, width, heigth) {
      if (IMG_REGEX.test(baseUrl)) {
          return baseUrl
              .replace(IMG_REGEX, REPLACE_PATTERN)
              .replace('{w}', `${width}`)
              .replace('{h}', `${heigth}`);
      }
      else {
          return baseUrl;
      }
  }
  function clamp(value, min, max) {
      return Math.max(min, Math.min(value, max));
  }
  function clamp01(value) {
      return clamp(value, 0, 1);
  }
  function formatPublishedDate(value) {
      const date = new Date(value);
      const minutesAgo = (Date.now() - date.getTime()) / (1000 * 60);
      const hoursAgo = minutesAgo / 60;
      let text = '';
      if (minutesAgo < 60) {
          text = `${Math.floor(minutesAgo)}m ago`;
      }
      else if (hoursAgo < 24) {
          text = `${Math.floor(hoursAgo)}h ago`;
      }
      else {
          text = date.toLocaleString('en-us', { month: 'short' });
          text += ' ';
          text += date.getDate();
      }
      return text;
  }
  function formatDuration(value) {
      const time = value.split(':').map((val) => parseInt(val));
      const timeUnit = time[0] > 0 ? 'hr' : time[1] > 0 ? 'min' : 'sec';
      return `${value.replace(/^0(?:0:0?)?/, '')} ${timeUnit}`;
  }
  function getElementRenderWidth(element) {
      const e = element;
      if (e.loadTexture) {
          e.loadTexture();
      }
      return e.renderWidth || 0;
  }

  class Store {
      constructor() {
          this.flags = {
              playingDeeplinkedVideo: false,
          };
          this.qs = {};
      }
      get contentGrid() {
          if (this._contentGrid)
              return this._contentGrid;
          throw new StoreDataError();
      }
      set contentGrid(value) {
          this._contentGrid = value;
      }
      get selectedGrid() {
          return this._selectedGrid || this.contentGrid;
      }
      set selectedGrid(value) {
          this._selectedGrid = value;
      }
      get selectedChannel() {
          return this._getCurrentChannelInGrid(this.selectedGrid);
      }
      get selectedVideo() {
          return this._getCurrentVideoInGrid(this.selectedGrid);
      }
      get nextSelectedGrid() {
          return this._getNextGridState(this.selectedGrid);
      }
      get nextVideo() {
          if (this.flags.playingDeeplinkedVideo)
              return this.firstContentVideo;
          return this._getCurrentVideoInGrid(this.nextSelectedGrid);
      }
      get firstContentVideo() {
          const firstChannel = this.contentPlaylistChannels[0];
          return firstChannel ? firstChannel.videos[0] : null;
      }
      get contentPlaylistChannels() {
          return this.contentGrid.channels
              .filter(channel => 'videos' in channel)
              .map(channel => channel);
      }
      get isReady() {
          return this._contentGrid != undefined;
      }
      selectNextVideoOrChannel() {
          this.selectedGrid = this.nextSelectedGrid;
      }
      _getCurrentChannelInGrid(grid) {
          return grid.channels[grid.position.y];
      }
      _getCurrentVideoInGrid(grid) {
          const channel = this._getCurrentChannelInGrid(grid);
          const { x: index } = grid.position;
          if ('videos' in channel) {
              return channel.videos[index] || null;
          }
          return null;
      }
      _getNextGridState(grid) {
          const { channels } = grid;
          const { x, y } = grid.position;
          for (let i = y; i < channels.length; i++) {
              const channel = channels[i];
              if ('videos' in channel) {
                  const isCurrentChannel = i === y;
                  const nextVideoIndex = isCurrentChannel ? x + 1 : 0;
                  if (nextVideoIndex < channel.videos.length) {
                      return {
                          channels: channels,
                          position: {
                              x: nextVideoIndex,
                              y: i,
                          },
                      };
                  }
              }
          }
          return {
              channels: this.contentGrid.channels,
              position: {
                  x: 0,
                  y: 0,
              },
          };
      }
  }
  var Store$1 = new Store();

  class BaseRow extends lightning.Component {
      static _template() {
          const width = 1920;
          const xOffset = 22;
          const leftMargin = 108;
          const counterRightMargin = 281;
          const text = {
              text: {
                  fontFace: 'FoundersGroteskCondensed-Semibold',
                  fontSize: 46,
                  textColor: 0xffffffff,
                  cutSy: 16,
              },
          };
          return {
              x: leftMargin,
              w: width - leftMargin,
              clipping: true,
              Header: {
                  x: xOffset,
                  h: BaseRow.headerHeight,
                  Title: {
                      ...text,
                  },
                  Counter: {
                      ...text,
                      x: width - counterRightMargin,
                      mountX: 1,
                  },
              },
              Row: {
                  x: xOffset,
                  type: Row,
                  itemSpacing: 40,
                  wrapSelected: true,
                  signals: {
                      selectedChange: '_selectedChangeHandler',
                  },
              },
          };
      }
      //
      // callbacks
      _init() {
          this._focused = false;
          Events.on('$app.videoSelected', this.$videoSelected.bind(this));
      }
      _detach() {
          Events.off('$app.videoSelected', this.$videoSelected);
      }
      _focus() {
          this._focused = true;
      }
      _unfocus() {
          this._focused = false;
      }
      _getFocused() {
          return this.row;
      }
      _active() {
          this._updateNowPlayingIcon();
      }
      //
      // helpers
      _selectedChangeHandler() {
          this._updateCounterText();
      }
      _updateCounterText() {
          this.header.patch({
              Counter: {
                  text: `${this.selectedIndex + 1} of ${this.row.items.length}`,
              },
          });
      }
      _cellSelected() {
          Events.emit('$app.cellSelected', new CellSelectedPayload(this, this.row.selected));
      }
      _updateHeight() {
          const padding = 10;
          if (this.header.visible) {
              this.row.y = BaseRow.headerHeight + BaseRow.headerMargin;
              this.h = this.row.h + BaseRow.headerHeight + BaseRow.headerMargin + padding;
          }
          else {
              this.row.y = 10;
              this.h = this.row.h + padding * 2;
          }
      }
      _updateNowPlayingIcon() {
          if (Store$1.isReady) {
              // In case we come from a deeplink, store won't be ready yet
              this.row.items.forEach((item) => {
                  item.nowPlaying = false;
              });
              if (Store$1.selectedChannel.id === this.data.id) {
                  const selectedItem = this.row.items[Store$1.selectedGrid.position.x];
                  selectedItem.nowPlaying = true;
              }
          }
      }
      //
      // properties
      set _focused(value) {
          const textColor = value ? 0xffffffff : 0xff898989;
          this.header.patch({
              Title: { text: { textColor: textColor } },
              Counter: { text: { textColor: textColor } },
          });
      }
      set data(value) {
          this._data = value;
          this.title.patch({ text: value.title.toUpperCase() });
          this.row.items = this._getCells();
          this._updateHeight();
          this._updateCounterText();
      }
      get data() {
          if (this._data) {
              return this._data;
          }
          else {
              throw new RowDataError();
          }
      }
      set titleVisible(value) {
          this.header.patch({ visible: value });
          this._updateHeight();
      }
      get header() {
          return this.tag('Header');
      }
      get title() {
          return this.tag('Title');
      }
      get titleText() {
          return this.title.text ? this.title.text.text : '';
      }
      set titleText(value) {
          this.title.patch({ text: value });
      }
      get row() {
          return this.tag('Row');
      }
      get selectedIndex() {
          return this.row.selectedIndex;
      }
      set selectedIndex(value) {
          this.row.selectedIndex = clamp(value, 0, this.row.items.length - 1);
      }
      //
      // Input
      _handleEnter() {
          this._cellSelected();
      }
      async $videoSelected() {
          this._updateNowPlayingIcon();
      }
  }
  BaseRow.headerHeight = 46;
  BaseRow.headerMargin = 23;

  class NowPlayingIndicator extends lightning.Component {
      static _template() {
          const bar = {
              y: 30,
              mountY: 1,
              w: 6,
              h: 22,
              rect: true,
          };
          return {
              Background: {
                  w: 55,
                  h: 39,
                  color: 0xb0000000,
                  rect: true,
//                  shader: {
//                      type: lightning.shaders.RoundedRectangle,
//                      radius: 10,
//                  },
              },
              Bar1: {
                  ...bar,
                  x: 10,
              },
              Bar2: {
                  ...bar,
                  x: 20,
              },
              Bar3: {
                  ...bar,
                  x: 30,
              },
              Bar4: {
                  ...bar,
                  x: 40,
              },
          };
      }
      _init() {
          const action = {
              p: 'h',
              v: { 0: 22, 0.5: 0, 1: 22 },
          };
          this._animB1 = this.tag('Bar1').animation({
              duration: 1,
              repeat: -1,
              actions: [action],
          });
          this._animB2 = this.tag('Bar2').animation({
              duration: 0.6,
              delay: 0.1,
              repeat: -1,
              actions: [action],
          });
          this._animB3 = this.tag('Bar3').animation({
              duration: 1.2,
              delay: 0.3,
              repeat: -1,
              actions: [action],
          });
          this._animB4 = this.tag('Bar4').animation({
              duration: 0.6,
              delay: 0.6,
              repeat: -1,
              actions: [action],
          });
      }
      _active() {
          this._animB1 && this._animB1.start();
          this._animB2 && this._animB2.start();
          this._animB3 && this._animB3.start();
          this._animB4 && this._animB4.start();
      }
      _inactive() {
          this._animB1 && this._animB1.finish();
          this._animB2 && this._animB2.finish();
          this._animB3 && this._animB3.finish();
          this._animB4 && this._animB4.finish();
      }
  }
  NowPlayingIndicator.width = 55;
  NowPlayingIndicator.height = 39;

  class BaseCell extends lightning.Component {
      constructor() {
          super(...arguments);
          this._nowPlaying = false;
      }
      static _getBaseTemplate(w, h) {
          const shadowSize = 25;
          const shadowBlur = 20;
          return {
              w,
              h,
              Shadow: {
                  x: w / 2,
                  y: h / 2,
                  mount: 0.5,
                  color: 0x66000000,
                  texture: lightning.Tools.getShadowRect(w + shadowSize * 3, h + shadowSize * 2, 10, shadowBlur),
              },
              Image: {
                  w,
                  h,
//                  shader: {
//                      type: lightning.shaders.RoundedRectangle,
//                      radius: 10,
//                      stroke: 3,
//                  },
                  NowPlayingIndicator: {
                      type: NowPlayingIndicator,
                      alpha: 0,
                      x: w - NowPlayingIndicator.width - 12,
                      y: 12,
                  },
              },
          };
      }
      //
      // callbacks
      _init() {
          this._focused = false;
      }
      _focus() {
          this._focused = true;
      }
      _unfocus() {
          this._focused = false;
      }
      _getFocused() {
          return this;
      }
      //
      // properties
      set _focused(value) {
          this.patch({
              Shadow: {
                  smooth: { alpha: value },
              },
              Image: {
                  smooth: {
                      scale: value ? 1.1 : 1,
                  },
                  shader: {
                      strokeColor: value ? 0xffffffff : 0xff393939,
                  },
              },
          });
      }
      get image() {
          return this.tag('Image');
      }
      set data(value) {
          this._data = value;
          this._render();
      }
      get data() {
          if (this._data) {
              return this._data;
          }
          else {
              throw new CellDataError();
          }
      }
      set nowPlaying(value) {
          if (value !== this._nowPlaying) {
              this._nowPlaying = value;
              this.tag('NowPlayingIndicator').setSmooth('alpha', value ? 1 : 0);
          }
      }
      get nowPlaying() {
          return this._nowPlaying;
      }
  }

  class LiveCell extends BaseCell {
      static _template() {
          return {
              ...LiveCell._getBaseTemplate(LiveCell.width, LiveCell.height),
          };
      }
      _render() {
          if ('tease' in this.data) {
              this.image.src = NBCDAimsUrl(this.data.tease, LiveCell.width, LiveCell.height);
          }
      }
  }
  LiveCell.width = 386;
  LiveCell.height = 140;

  class LiveRow extends BaseRow {
      _getCells() {
          return this.data.videos.map((vid) => ({
              type: LiveCell,
              data: vid,
          }));
      }
      _init() {
          super._init();
          this.tag('Header.Counter').patch({ alpha: 0 });
      }
  }

  class PagesCell extends BaseCell {
      static _template() {
          return {
              ...PagesCell._getBaseTemplate(PagesCell.width, PagesCell.height),
          };
      }
      _render() {
          if ('image' in this.data) {
              this.image.src = NBCDAimsUrl(this.data.image, PagesCell.width, PagesCell.height);
          }
      }
  }
  PagesCell.width = 386;
  PagesCell.height = 140;

  class PagesRow extends BaseRow {
      _getCells() {
          return this.data.cards.map((card) => ({
              type: PagesCell,
              data: card,
          }));
      }
  }

  class PlaylistCell extends BaseCell {
      static _template() {
          const dateDurationFontSize = 22;
          const xPosition = 10;
          return {
              ...PlaylistCell._getBaseTemplate(PlaylistCell.width, PlaylistCell.thumbnailHeight),
              h: PlaylistCell.height,
              Date: {
                  x: xPosition,
                  y: PlaylistCell.dateDurationYposition,
                  text: {
                      text: '',
                      fontSize: dateDurationFontSize,
                      textColor: PlaylistCell.colors.unfocus,
                      fontFace: 'FoundersGroteskMono-Semibold',
                  },
              },
              Duration: {
                  x: PlaylistCell.width - xPosition,
                  y: PlaylistCell.dateDurationYposition,
                  mountX: 1,
                  text: {
                      text: '',
                      fontSize: dateDurationFontSize,
                      textAlign: 'right',
                      textColor: PlaylistCell.colors.unfocus,
                      fontFace: 'FoundersGroteskMono-Semibold',
                  },
              },
              Title: {
                  x: xPosition,
                  y: PlaylistCell.titleYposition,
                  text: {
                      text: '',
                      fontSize: 30,
                      wordWrap: true,
                      wordWrapWidth: PlaylistCell.width,
                      maxLines: 2,
                      maxLinesSuffix: '...',
                      textColor: PlaylistCell.colors.unfocus,
                      fontFace: 'FoundersGroteskCondensed-Bold',
                  },
              },
          };
      }
      _render() {
          if ('tease' in this.data) {
              this.patch({
                  Image: {
                      src: NBCDAimsUrl(this.data.tease, PlaylistCell.width, PlaylistCell.thumbnailHeight),
                  },
                  Date: {
                      text: { text: formatPublishedDate(this.data.published) },
                  },
                  Duration: {
                      text: { text: formatDuration(this.data.duration) },
                  },
                  Title: {
                      text: { text: this.data.headline },
                  },
              });
          }
      }
      set _focused(value) {
          super._focused = value;
          const focusYOffset = 8;
          this.patch({
              Title: {
                  text: {
                      textColor: value ? PlaylistCell.colors.focus : PlaylistCell.colors.unfocus,
                  },
                  y: value ? PlaylistCell.titleYposition + focusYOffset : PlaylistCell.titleYposition,
              },
              Duration: {
                  text: {
                      textColor: value ? PlaylistCell.colors.dateTime : PlaylistCell.colors.unfocus,
                  },
                  y: value
                      ? PlaylistCell.dateDurationYposition + focusYOffset
                      : PlaylistCell.dateDurationYposition,
              },
              Date: {
                  text: {
                      textColor: value ? PlaylistCell.colors.dateTime : PlaylistCell.colors.unfocus,
                  },
                  y: value
                      ? PlaylistCell.dateDurationYposition + focusYOffset
                      : PlaylistCell.dateDurationYposition,
              },
          });
      }
  }
  PlaylistCell.width = 386;
  PlaylistCell.height = 322;
  PlaylistCell.thumbnailHeight = 217;
  PlaylistCell.titleYposition = 257;
  PlaylistCell.dateDurationYposition = 232;
  PlaylistCell.colors = {
      focus: 0xffffffff,
      unfocus: 0xff636363,
      dateTime: 0xffb0b0b0,
  };

  class PlaylistRow extends BaseRow {
      _getCells() {
          return this.data.videos.map((vid) => ({
              type: PlaylistCell,
              data: vid,
          }));
      }
  }

  class PlaylistsCell extends BaseCell {
      static _template() {
          return {
              ...PlaylistsCell._getBaseTemplate(PlaylistsCell.width, PlaylistsCell.height),
              Title: {
                  w: PlaylistsCell.width,
                  y: PlaylistsCell.height / 2,
                  mountY: 0.5,
                  text: {
                      text: '',
                      fontFace: 'FoundersGroteskCondensed-Semibold',
                      fontSize: 40,
                      textColor: 0xffffffff,
                      textAlign: 'center',
                  },
              },
          };
      }
      _render() {
          if ('title' in this.data) {
              this.patch({
                  Title: { text: { text: this.data.title.toUpperCase() } },
                  Image: {
                      src: NBCDAimsUrl(this.data.image, PlaylistsCell.width, PlaylistsCell.height),
                  },
              });
          }
      }
  }
  PlaylistsCell.width = 386;
  PlaylistsCell.height = 140;

  class PlaylistsRow extends BaseRow {
      _getCells() {
          return this.data.cards.map((card) => ({
              type: PlaylistsCell,
              data: card,
          }));
      }
  }

  class VideosCell extends BaseCell {
      static _template() {
          return {
              ...VideosCell._getBaseTemplate(VideosCell.width, VideosCell.height),
          };
      }
      _render() {
          if ('tease' in this.data) {
              this.image.src = NBCDAimsUrl(this.data.tease, VideosCell.width, VideosCell.height);
          }
      }
      set _focused(value) {
          this.image.patch({
              smooth: {
                  scale: value ? 1.053 : 1,
              },
              shader: {
                  strokeColor: value ? 0xffffffff : 0xff393939,
              },
          });
      }
  }
  VideosCell.width = 812;
  VideosCell.height = 311;

  class VideosRow extends BaseRow {
      _getCells() {
          return this.data.videos.map((vid) => ({
              type: VideosCell,
              data: vid,
          }));
      }
  }

  function CreateRow(channel, titleVisible = true) {
      const data = { data: channel, titleVisible: titleVisible };
      switch (channel.type) {
          case 'pages':
              return { type: PagesRow, ...data };
          case 'playlist':
              return { type: PlaylistRow, ...data };
          case 'playlists':
              return { type: PlaylistsRow, ...data };
          case 'videos':
              return { type: VideosRow, ...data };
          case 'playmakerLive':
              return { type: LiveRow, ...data };
          default:
              return null;
      }
  }

  class RouterPage extends lightning.Component {
      constructor() {
          super(...arguments);
          /* eslint-disable @typescript-eslint/no-explicit-any*/
          this.widgets = {}; // Direct access to the widgets, so hard to type
      }
      _onDataProvided() {
          // this.data is now populated
          return;
      }
  }

  class BasePage extends RouterPage {
      get data() {
          if (this._data) {
              return this._data;
          }
          else {
              throw new PageDataError();
          }
      }
      set data(value) {
          this._data = value;
      }
  }

  class SplitPage extends BasePage {
      constructor() {
          super(...arguments);
          this.animDuration = { duration: 0.3 };
          this._contentSettings = {
              enabled: true,
              yOffsetByState: {
                  landingFocused: 950,
                  contentFocused: 0,
                  allHidden: 1100,
              },
          };
      }
      static _template() {
          const w = 1920;
          const h = 1080;
          return {
              w,
              h,
              // TODO Make this work with class properties only
              _contentSettings: {
                  enabled: null,
                  yOffsetByState: {
                      landingFocused: null,
                      contentFocused: null,
                      allHidden: null,
                  },
              },
              Containers: {
                  LandingContainer: {
                      w,
                      h,
                      LandingComponent: {},
                  },
                  ContentBackground: {
                      w,
                      h,
                      alpha: 0,
                      rect: true,
                      color: 0xed000000,
                  },
                  ContentContainer: {
                      w,
                      h,
                      clipping: true,
                      ContentComponent: {},
                  },
              },
          };
      }
      static _states() {
          return [
              class LandingFocused extends this {
                  $enter() {
                      this.landingContainer.setSmooth('alpha', 1, this.animDuration);
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.landingFocused, this.animDuration);
                  }
                  $exit() {
                      this.landingContainer.setSmooth('alpha', 0, this.animDuration);
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.allHidden, this.animDuration);
                  }
                  _getFocused() {
                      return this.landingComponent;
                  }
                  _handleDown() {
                      if (this._contentSettings.enabled) {
                          this._setState('ContentFocused');
                          return true;
                      }
                      return false;
                  }
              },
              class ContentFocused extends this {
                  $enter() {
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.contentFocused, this.animDuration);
                      this.contentBackground.setSmooth('alpha', 1, this.animDuration);
                  }
                  $exit() {
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.allHidden, this.animDuration);
                      this.contentBackground.setSmooth('alpha', 0, this.animDuration);
                  }
                  _getFocused() {
                      return this.contentComponent;
                  }
                  _handleUp() {
                      this._setState('LandingFocused');
                  }
                  _handleBack() {
                      this._setState('LandingFocused');
                  }
              },
              class AllHidden extends this {
                  $enter() {
                      this.tag('Containers').setSmooth('alpha', 0, this.animDuration);
                  }
                  $exit() {
                      this.tag('Containers').setSmooth('alpha', 1, this.animDuration);
                  }
                  _handleBack() {
                      this._setState('LandingFocused');
                  }
              },
          ];
      }
      //
      // component's events
      _init() {
          this._setState('LandingFocused');
      }
      //
      // properties
      get landingContainer() {
          return this.tag('LandingContainer');
      }
      get contentContainer() {
          return this.tag('ContentContainer');
      }
      get contentBackground() {
          return this.tag('ContentBackground');
      }
      get landingComponent() {
          return this.tag('LandingComponent');
      }
      set landingComponent(value) {
          this.landingContainer.patch({ LandingComponent: undefined });
          this.landingContainer.patch({ LandingComponent: value });
      }
      get contentComponent() {
          return this.tag('ContentComponent');
      }
      set contentComponent(value) {
          this.contentContainer.patch({ ContentComponent: undefined });
          this.contentContainer.patch({
              ContentComponent: value,
              y: this._contentSettings.yOffsetByState.landingFocused,
          });
      }
  }

  class CardPageTop extends lightning.Component {
      static _template() {
          return {
              Title: {
                  x: 127,
                  y: 92,
                  text: {
                      fontFace: 'FoundersGroteskCondensed-Semibold',
                      fontSize: 88,
                      cutSy: 32,
                  },
              },
              Subtitle: {
                  x: 127,
                  y: 170,
                  text: {
                      fontFace: 'FoundersGroteskCondensed-Light',
                      fontSize: 44,
                      cutSy: 16,
                  },
              },
              BackButton: {
                  x: 127,
                  y: 380,
                  src: Utils.asset('images/back_button.png'),
              },
              Item: {},
          };
      }
      static _states() {
          return [
              class BackButton extends this {
                  $enter() {
                      this.backButton.setSmooth('scale', 1.2);
                  }
                  $exit() {
                      this.backButton.setSmooth('scale', 1);
                  }
                  _getFocused() {
                      return this;
                  }
                  _handleEnter() {
                      Router.step(-1);
                  }
                  _handleDown() {
                      this._setState('Item');
                  }
              },
              class Item extends this {
                  _handleUp() {
                      this._setState('BackButton');
                  }
                  _getFocused() {
                      return this.item;
                  }
              },
          ];
      }
      //
      // callbacks
      _enable() {
          this._setState('Item');
      }
      //
      // properties
      get backButton() {
          return this.tag('BackButton');
      }
      set title(value) {
          this.patch({
              Title: { text: { text: value.toUpperCase() } },
          });
      }
      set subtitle(value) {
          this.patch({
              Subtitle: { text: { text: value || '' } },
          });
      }
      get item() {
          return this.tag('Item');
      }
      set item(value) {
          this.patch({ Item: undefined });
          this.patch({ Item: value });
          this.item.y = 1080 - this.item.h - 150;
      }
  }

  class CardPage extends SplitPage {
      static _template() {
          return {
              Background: {
                  w: 1920,
                  h: 1080,
                  rect: true,
                  color: 0xffffffff,
              },
              Fade: {
                  TopLeftCorner: {
                      w: 1920 / 2,
                      h: 1080 / 2,
                      rect: true,
                      color: 0x00000000,
                      colorUl: 0x7c000000,
                  },
                  Bottom: {
                      w: 1920,
                      h: 1080,
                      rect: true,
                      color: 0x00000000,
                      colorBottom: 0xed000000,
                  },
              },
              ...super._template(),
              landingComponent: {
                  type: CardPageTop,
              },
              contentComponent: {
                  y: 20,
                  itemSpacing: 69,
                  type: Column,
              },
          };
      }
      //
      // callbacks
      _init() {
          Events.on('$app.cellSelected', this.$cellSelected.bind(this));
      }
      _onDataProvided() {
          this._render();
      }
      _getFocused() {
          return this;
      }
      //
      // helpers
      _render() {
          const rows = this.data.rows.map((row) => CreateRow(row));
          this.cardPageTop.patch({
              title: this.data.title,
              subtitle: this.data.subtitle,
              item: rows[0],
          });
          this._contentSettings.enabled = rows.length > 1;
          this.column.patch({
              items: rows.length > 1 ? rows.slice(1) : undefined,
          });
          const storeHasPosition = Store$1.isReady && this.data.cardId == Store$1.selectedGrid.id;
          const position = storeHasPosition ? Store$1.selectedGrid.position : { x: 0, y: 0 };
          this._focusCell(position);
          if (this.data.backgroundUrl) {
              this.tag('Background').src = this.data.backgroundUrl;
          }
      }
      _focusCell({ x, y }) {
          if (y === 0) {
              this.cardPageTop.item.selectedIndex = x;
              this._setState('LandingFocused');
          }
          else {
              y = clamp(y - 1, 0, this.column.items.length - 1);
              this.column.selectedIndex = y;
              this.column.selected.row.selectedIndex = x;
              this._setState('ContentFocused');
          }
      }
      //
      // events
      async $cellSelected(payload) {
          if (this.active) {
              Log.info('CardPage $cellSelected >', payload);
              const videoIndex = payload.row.selectedIndex;
              Store$1.selectedGrid = {
                  id: this.data.cardId,
                  channels: this.data.rows,
                  position: {
                      x: videoIndex,
                      y: this.channelIndex,
                  },
              };
              this._backToHome({
                  navigateBack: true,
                  hiddenOnLoad: true,
              });
          }
      }
      _handleBack() {
          this._backToHome({
              contentFocusedOnLoad: true,
          });
          VideoPlayer.play();
      }
      _backToHome(params) {
          const path = 'brand/' + (this.data.activeBrand || BrandName.nbcnews);
          Router.navigate(path, {
              ...params,
              skipAutoPlay: true,
              focusOnLastItem: true,
          });
      }
      //
      // properties
      get column() {
          return this.contentComponent;
      }
      get channelIndex() {
          return this._getState() == 'LandingFocused' ? 0 : this.column.selectedIndex + 1;
      }
      get cardPageTop() {
          return this.landingComponent;
      }
  }

  class Timer {
      constructor(component, delay, callback) {
          this.component = component;
          this.delay = delay;
          this.callback = callback;
      }
      start() {
          if (!this.component.active) {
              return;
          }
          this.stop();
          this.timer = Registry.setTimeout(this.callback, this.delay * 1000);
      }
      stop() {
          if (this.timer) {
              Registry.clearTimeout(this.timer);
          }
      }
  }

  class NowPlayingTray extends lightning.Component {
      constructor() {
          super(...arguments);
          this._autohideTimer = new Timer(this, 20, () => {
              if (this.hasFocus()) {
                  this.signal('autohide');
              }
          });
      }
      static _template() {
          const w = 1920;
          const h = 1080;
          return {
              x: 0,
              y: h,
              w,
              h,
              Gradient: {
                  w: (w) => w,
                  h: (h) => h,
                  rect: true,
                  colorTop: 0x00000000,
                  colorBottom: 0xff000000,
              },
              Item: {},
          };
      }
      _init() {
          Events.on('$app.cellSelected', this.$cellSelected.bind(this));
      }
      _firstEnable() {
          this._updateCurrentItem();
      }
      _getFocused() {
          return this.item;
      }
      _focus() {
          this.yPosition = 0;
          this._autohideTimer.start();
          this._updateCurrentItem();
      }
      _unfocus() {
          this.yPosition = this.h;
          this._autohideTimer.stop();
      }
      _captureKey() {
          this.signal('screenKey');
          this._autohideTimer.start();
          return false;
      }
      async $cellSelected(payload) {
          if (this.hasFocus()) {
              const selectedVideoIndex = payload.row.selectedIndex;
              Store$1.selectedGrid.position.x = selectedVideoIndex;
          }
      }
      _updateCurrentItem() {
          const selectedChannel = Store$1.selectedChannel;
          if (this._selectedChannel != selectedChannel) {
              this._selectedChannel = selectedChannel;
              this.patch({ Item: undefined });
              this.patch({ Item: CreateRow(this._selectedChannel) });
              this.item.titleText = 'NOW PLAYING: ' + this.item.titleText;
          }
          const padding = 20;
          const h = this.item.h + padding * 2;
          const y = this.h - h;
          const selectedVideoIndex = Store$1.selectedGrid.position.x;
          this.item.patch({
              y: y,
              selectedIndex: selectedVideoIndex,
          });
      }
      set yPosition(value) {
          const animationDuration = 0.5;
          this.setSmooth('y', value, { duration: animationDuration });
      }
      get item() {
          return this.tag('Item');
      }
  }

  const BAR = {
      w: 1920 / 2,
      h: 15,
      x: 1920 / 4,
      y: 750,
      backgroundColor: 0xff636363,
      color: 0xffff503c,
  };
  class Loading extends lightning.Component {
      constructor() {
          super(...arguments);
          this._progress = 0;
      }
      static _template() {
          return {
              alpha: 0,
              forceZIndexContext: true,
              zIndex: -10,
              Background: {
                  w: 1920,
                  h: 1080,
                  rect: true,
                  color: 0xffffffff,
              },
              Image: {
                  w: 1920,
                  h: 1080,
              },
              Gradient: {
                  w: 1920,
                  h: 1080,
                  rect: true,
                  colorTop: 0x00000000,
                  colorBottom: 0xff000000,
              },
              ProgressBar: {
                  x: BAR.x,
                  y: BAR.y,
                  Background: {
                      texture: lightning.Tools.getRoundRect(BAR.w, BAR.h, 5, 0, 0, true, BAR.backgroundColor),
                  },
                  Progress: {
                      w: 0,
                      texture: lightning.Tools.getRoundRect(BAR.w, BAR.h, 5, 0, 0, true, BAR.color),
                  },
              },
              TimeStamps: {
                  x: 1920 / 4,
                  y: 790,
                  Date: {
                      text: {
                          text: '',
                          fontSize: 20,
                      },
                  },
                  Duration: {
                      x: 1920 / 2,
                      mountX: 1,
                      text: {
                          text: '',
                          fontSize: 20,
                          textAlign: 'right',
                      },
                  },
              },
              Title: {
                  x: 1920 / 4,
                  y: 830,
                  text: {
                      text: '',
                      wordWrapWidth: 1920 / 2,
                      fontSize: 35,
                  },
              },
              Arrow: {
                  x: 1920 / 2,
                  y: 1080,
                  mountX: 0.5,
                  src: Utils.asset('images/player/down_arrow.png'),
              },
          };
      }
      set item(video) {
          this.patch({
              Image: { src: NBCDAimsUrl(video.tease, 1920, 1080) },
              TimeStamps: {
                  // TODO: Reformat these strings to put them up to spec with figma
                  Date: { text: { text: video.published.toString().substring(0, 10) } },
                  Duration: { text: { text: video.duration } },
              },
              Title: { text: { text: video.headline } },
              Arrow: { y: 1080 },
              ProgressBar: {
                  Progress: {
                      w: Math.floor(BAR.w * 0.1),
                  },
              },
          });
          this.tag('Arrow').setSmooth('y', 1000, { delay: 1, duration: 1 });
      }
      set progress(progress) {
          if (progress > this._progress) {
              this._progress = progress;
              this.tag('ProgressBar')
                  .tag('Progress')
                  .patch({
                  w: Math.floor(BAR.w * this._progress * 0.01),
              });
          }
      }
  }

  class LoadingIndicator extends lightning.Component {
      constructor() {
          super(...arguments);
          this._feathersSweepAnimation = {
              items: ['F1', 'F2', 'F3', 'F4', 'F5', 'F6'],
              delay: 0.4,
              duration: 0.8,
              fadeDuration: 0.2,
              startValue: 0.5,
              endValue: 1,
          };
      }
      static _template() {
          return {
              Feathers: {
                  w: 225.32,
                  h: 134.58,
                  mount: 0.5,
                  F1: {
                      x: 0,
                      y: 86.58,
                      w: 99,
                      h: 48,
                      pivot: 0.5,
                      alpha: 0.5,
                      src: Utils.asset('images/loading-indicator/Feather1.png'),
                  },
                  F2: {
                      x: 17.23,
                      y: 32.26,
                      w: 80,
                      h: 92,
                      pivot: 0.5,
                      alpha: 0.5,
                      src: Utils.asset('images/loading-indicator/Feather2.png'),
                  },
                  F3: {
                      x: 62.13,
                      y: 0,
                      w: 48,
                      h: 108,
                      pivotX: 18,
                      pivotY: 18,
                      alpha: 0.5,
                      src: Utils.asset('images/loading-indicator/Feather3.png'),
                  },
                  F4: {
                      x: 115.91,
                      y: 0,
                      w: 48,
                      h: 108,
                      pivotX: 18,
                      pivotY: 18,
                      alpha: 0.5,
                      src: Utils.asset('images/loading-indicator/Feather4.png'),
                  },
                  F5: {
                      x: 128.43,
                      y: 32.54,
                      w: 80,
                      h: 92,
                      pivot: 0.5,
                      alpha: 0.5,
                      src: Utils.asset('images/loading-indicator/Feather5.png'),
                  },
                  F6: {
                      x: 126.32,
                      y: 86.58,
                      w: 99,
                      h: 48,
                      pivot: 0.5,
                      alpha: 0.5,
                      src: Utils.asset('images/loading-indicator/Feather6.png'),
                  },
              },
          };
      }
      _init() {
          this._rotateAnim = this.tag('Feathers').animation({
              duration: 0.5,
              actions: [
                  {
                      t: 'F1',
                      p: 'rotation',
                      v: { 0: -0.8, 0.9: { v: 0.05, sm: 0.8 }, 1: { v: 0, sm: 1 } },
                      rv: 0,
                  },
                  {
                      t: 'F2',
                      p: 'rotation',
                      v: { 0: -0.4, 0.9: { v: 0.02, sm: 0.8 }, 1: { v: 0, sm: 1 } },
                      rv: 0,
                  },
                  {
                      t: 'F5',
                      p: 'rotation',
                      v: { 0: 0.4, 0.9: { v: -0.02, sm: 0.8 }, 1: { v: 0, sm: 1 } },
                      rv: 0,
                  },
                  {
                      t: 'F6',
                      p: 'rotation',
                      v: { 0: 0.8, 0.9: { v: -0.05, sm: 0.8 }, 1: { v: 0, sm: 1 } },
                      rv: 0,
                  },
              ],
          });
          const { startValue, endValue } = this._feathersSweepAnimation;
          this._sweepOnAnim = this.tag('Feathers').animation(this.getSweepAnimation(startValue, endValue));
          this._sweepOffAnim = this.tag('Feathers').animation(this.getSweepAnimation(endValue, startValue));
          if (this._rotateAnim.on) {
              this._rotateAnim.on('finish', () => {
                  this._sweepOnAnim && this._sweepOnAnim.start();
              });
          }
          if (this._sweepOnAnim.on) {
              this._sweepOnAnim.on('finish', () => {
                  this._sweepOffAnim && this._sweepOffAnim.start();
              });
          }
          if (this._sweepOffAnim.on) {
              this._sweepOffAnim.on('finish', () => {
                  this._sweepOnAnim && this._sweepOnAnim.start();
              });
          }
      }
      static _states() {
          return [
              class Run extends this {
                  $enter() {
                      this.start();
                  }
                  $exit() {
                      this.clear();
                  }
              },
              class Stop extends this {
                  $enter() {
                      this.stop();
                  }
                  $exit() {
                      this.clear();
                  }
              },
          ];
      }
      _active() {
          this._setState('Run');
      }
      _inactive() {
          this._setState('Stop');
      }
      start() {
          this.clear();
          this._rotateAnim && this._rotateAnim.start();
      }
      stop() {
          this._rotateAnim && this._rotateAnim.pause();
          this._sweepOnAnim && this._sweepOnAnim.pause();
          this._sweepOffAnim && this._sweepOffAnim.pause();
      }
      clear() {
          this.stop();
          const initialValues = { alpha: 0.5, rotation: 0 };
          this.patch({
              Feathers: {
                  F1: initialValues,
                  F2: initialValues,
                  F3: initialValues,
                  F4: initialValues,
                  F5: initialValues,
                  F6: initialValues,
              },
          });
      }
      getSweepAnimation(startValue, endValue) {
          const { items, delay, duration, fadeDuration } = this._feathersSweepAnimation;
          const step = duration / items.length;
          const startTimes = [1, 2, 3, 4, 5, 6].map(n => n * step);
          const endTimes = startTimes.map(n => n + fadeDuration);
          return {
              delay: delay,
              duration: duration,
              actions: items.map((item, i) => {
                  return {
                      t: item,
                      p: 'alpha',
                      v: {
                          0: startValue,
                          [startTimes[i]]: startValue,
                          [endTimes[i]]: endValue,
                          1: endValue,
                      },
                  };
              }),
          };
      }
  }

  class Buffering extends lightning.Component {
      static _template() {
          return {
              Background: {
                  src: Utils.asset('images/background.png'),
              },
              LoadingIndicator: {
                  x: 1920 / 2,
                  y: 1080 / 2,
                  type: LoadingIndicator,
              },
              Arrow: {
                  x: 1920 / 2,
                  y: 1080,
                  mountX: 0.5,
                  src: Utils.asset('images/player/down_arrow.png'),
              },
          };
      }
      _enable() {
          this.tag('Arrow').setSmooth('y', 1000, { delay: 1, duration: 1 });
      }
  }

  class Bumper extends lightning.Component {
      static _template() {
          return {
              BottomLayer: {
                  x: Bumper.width,
                  w: Bumper.width,
                  h: Bumper.height,
                  rect: true,
                  color: 0xffffffff,
              },
              MiddleLayer: {
                  x: Bumper.width,
                  w: Bumper.width,
                  h: Bumper.height,
                  rect: true,
                  color: 0xff3061ff,
              },
              TopLayer: {
                  x: Bumper.width,
                  w: Bumper.width,
                  h: Bumper.height,
                  rect: true,
                  color: 0xff102039,
              },
              VideoTitle: {
                  x: Bumper.width,
                  w: Bumper.width,
                  h: Bumper.height,
                  UpNext: {
                      x: 60,
                      y: 331,
                      text: {
                          text: 'UP NEXT',
                          fontFace: 'FoundersGroteskCondensed-Regular',
                          fontSize: 53,
                          cutSy: 19,
                      },
                      Underline: {
                          y: 60,
                          w: 72,
                          h: 16,
                          rect: true,
                      },
                  },
                  Title: {
                      x: 92,
                      y: 466,
                      text: {
                          text: '',
                          fontFace: 'FoundersGroteskCondensed-Bold',
                          wordWrapWidth: 400,
                          fontSize: 50,
                          cutSy: 18,
                      },
                  },
              },
          };
      }
      //
      // components event's
      _init() {
          const xFirstStop = Bumper.width - 568;
          const xSecondStop = -1800;
          this._transition = this.animation({
              duration: 6,
              stopMethod: 'immediate',
              actions: [
                  {
                      t: 'TopLayer',
                      p: 'x',
                      v: {
                          sm: 0,
                          0: Bumper.width,
                          0.1: xFirstStop,
                          0.4: xFirstStop,
                          0.6: 0,
                          0.7: 0,
                          0.9: xSecondStop,
                          1: -Bumper.width,
                      },
                  },
                  {
                      t: 'MiddleLayer',
                      p: 'x',
                      v: {
                          sm: 0,
                          0: Bumper.width,
                          0.6: Bumper.width,
                          0.7: 0,
                          0.925: xSecondStop,
                          1: -Bumper.width,
                      },
                  },
                  {
                      t: 'BottomLayer',
                      p: 'x',
                      v: {
                          sm: 0,
                          0: Bumper.width,
                          0.6: Bumper.width,
                          0.7: 0,
                          0.95: xSecondStop,
                          1: -Bumper.width,
                      },
                  },
                  {
                      t: 'VideoTitle',
                      p: 'x',
                      v: {
                          sm: 0,
                          0: Bumper.width,
                          0.1: xFirstStop,
                          0.7: xFirstStop,
                          0.9: -520,
                          1: -640,
                      },
                  },
                  {
                      t: 'VideoTitle',
                      p: 'alpha',
                      v: { sm: 0, 0: 1, 0.8: 1, 0.9: 0 },
                  },
              ],
          });
      }
      set item(video) {
          if (this._transition && !this._transition.isPlaying()) {
              const titleTag = this.tag('VideoTitle').tag('Title').text;
              if (titleTag) {
                  titleTag.text = video.headline;
              }
              this._transition.start();
          }
      }
  }
  Bumper.width = 1920;
  Bumper.height = 1080;

  const SECONDS_TO_FIRE_BUMPER = 4;
  const BAR_WIDTH = 1250;
  const BAR$1 = {
      w: BAR_WIDTH,
      h: 50,
      x: (1920 - BAR_WIDTH) / 2,
      y: 855,
      backgroundColor: 0xff162d61,
      color: 0xff995896,
  };
  class PlayerControls extends lightning.Component {
      constructor() {
          super(...arguments);
          this._focusAnimDuration = 0.5;
          this._hideTimer = new Timer(this, 5, () => this._setState('Hidden'));
          this._seekValue = 0;
          this._bumperFired = false;
      }
      static _template() {
          return {
              Controls: {
                  x: 0,
                  y: 1080,
                  Background: {
                      x: 0,
                      y: 810,
                      w: 1920,
                      h: 270,
                      rect: true,
                      color: 0xff102039,
                  },
                  ProgressBar: {
                      x: BAR$1.x,
                      y: BAR$1.y,
                      Background: {
                          texture: lightning.Tools.getRoundRect(BAR$1.w, BAR$1.h, 5, 0, 0, true, BAR$1.backgroundColor),
                      },
                      Progress: {
                          w: BAR$1.w,
                          texture: lightning.Tools.getRoundRect(BAR$1.w, BAR$1.h, 5, 0, 0, true, BAR$1.color),
                      },
                  },
                  Time: {
                      y: BAR$1.y + 10,
                      Current: {
                          x: BAR$1.x - 20,
                          mountX: 1,
                          text: {
                              fontFace: 'Regular',
                              fontSize: 30,
                              textColor: 0xbbffffff,
                              textAlign: 'right',
                              text: '20s',
                          },
                      },
                      Remaining: {
                          x: 1920 - BAR$1.x + 20,
                          text: {
                              fontFace: 'Regular',
                              fontSize: 30,
                              textColor: 0xbbffffff,
                              text: '60s',
                          },
                      },
                  },
                  StatusIcon: {
                      x: 1920 / 2,
                      y: 970,
                      src: Utils.asset('images/player/pause.png'),
                  },
              },
              Loading: {
                  type: Loading,
                  alpha: 0,
              },
              Buffering: {
                  type: Buffering,
                  alpha: 0,
              },
              Bumper: {
                  type: Bumper,
              },
          };
      }
      static _states() {
          return [
              class Playing extends this {
                  $enter() {
                      this.signal('playerState', 'Playing');
                      if (this._hideTimer) {
                          this._hideTimer.start();
                      }
                      this._setStateIcon('Pause');
                      VideoPlayer.play();
                  }
                  _handleMediaPlayPause() {
                      this._handleEnter();
                  }
                  _handleEnter() {
                      this._setState('Paused');
                  }
                  _handleMediaFastForward() {
                      this._onFF();
                  }
                  _handleRight() {
                      this._onFF();
                  }
                  _handleMediaRewind() {
                      this._onRW();
                  }
                  _handleLeft() {
                      this._onRW();
                  }
                  _handleBack() {
                      this._setState('Hidden');
                  }
              },
              class Paused extends this {
                  $enter() {
                      this.signal('playerState', 'Paused');
                      if (this._hideTimer) {
                          this._hideTimer.stop();
                      }
                      this._setStateIcon('Play');
                      VideoPlayer.pause();
                  }
                  _handleMediaPlayPause() {
                      this._handleEnter();
                  }
                  _handleEnter() {
                      this._setState('Playing');
                  }
                  _handleMediaFastForward() {
                      this._onFF();
                  }
                  _handleRight() {
                      this._onFF();
                  }
                  _handleMediaRewind() {
                      this._onRW();
                  }
                  _handleLeft() {
                      this._onRW();
                  }
                  _handleBack() {
                      this._setState('Hidden');
                  }
              },
              class Seeking extends this {
                  $enter() {
                      this.signal('playerState', 'Seeking');
                      if (this._hideTimer) {
                          this._hideTimer.stop();
                      }
                      VideoPlayer.pause();
                      this._seekValue = VideoPlayer.currentTime;
                  }
                  _handleMediaPlayPause() {
                      this._handleEnter();
                  }
                  _handleEnter() {
                      VideoPlayer.seek(this._seekValue);
                      this._seekValue = 0;
                  }
                  _handleMediaFastForward() {
                      this._onFF();
                  }
                  _handleRight() {
                      this._onFF();
                  }
                  _handleMediaRewind() {
                      this._onRW();
                  }
                  _handleLeft() {
                      this._onRW();
                  }
                  _handleBack() {
                      this._setState('Hidden');
                  }
              },
              class Hidden extends this {
                  $enter() {
                      this.controls.setSmooth('y', 1080, { duration: this._focusAnimDuration });
                  }
                  $exit() {
                      this.controls.setSmooth('y', 0, { duration: this._focusAnimDuration });
                  }
                  _handleMediaPlayPause() {
                      this._handleEnter();
                  }
                  _handleEnter() {
                      this._setState(VideoPlayer.isPlaying ? 'Paused' : 'Playing');
                  }
                  _handleMediaFastForward() {
                      this._onFF();
                  }
                  _handleRight() {
                      this._onFF();
                  }
                  _handleMediaRewind() {
                      this._onRW();
                  }
                  _handleLeft() {
                      this._onRW();
                  }
              },
              class Buffering extends this {
                  $enter() {
                      this.controls.setSmooth('alpha', 0, { duration: 0.5 });
                      this.buffering.setSmooth('alpha', 1, { duration: 0.5 });
                  }
                  $exit() {
                      this.controls.setSmooth('alpha', 1, { duration: 0.5 });
                      this.buffering.setSmooth('alpha', 0, { duration: 0.5 });
                  }
              },
              class Loading extends this {
                  $enter() {
                      this.controls.patch({ alpha: 0 });
                      this.loading.patch({ alpha: 1 });
                  }
                  $exit() {
                      this.controls.setSmooth('alpha', 1, { duration: 0.5 });
                      this.loading.setSmooth('alpha', 0, { duration: 0.5 });
                  }
              },
          ];
      }
      //
      // component's events
      _init() {
          this._setState('Hidden');
          Events.on('$app.videoSelected', this.$videoSelected.bind(this));
          Events.on('$player.playerEvent', this.$playerEvent.bind(this));
      }
      _detach() {
          Events.off('$app.videoSelected', this.$videoSelected);
          Events.off('$player.playerEvent', this.$playerEvent);
      }
      _getFocused() {
          return this;
      }
      _focus() {
          if (this._hideTimer && (this.state === 'Playing' || this.state === 'Paused')) {
              this._hideTimer.start();
          }
      }
      _captureKey() {
          this.signal('screenKey');
          if (this._hideTimer && (this.state === 'Playing' || this.state === 'Paused')) {
              this._hideTimer.start();
          }
          return false;
      }
      $videoSelected(video) {
          this.loading.patch({ item: video });
          this._bumperFired = false;
          this._seekValue = 0;
      }
      $playerEvent({ type: eventType }) {
          if (!this.active) {
              return;
          }
          if (this.state === 'Hidden') {
              switch (eventType) {
                  case 'LoadStart':
                      this._setState('Loading');
                      return;
                  case 'TimeUpdate': {
                      this._checkIfBumperNeeded();
                      break;
                  }
                  case 'Waiting':
                      this._setState('Buffering');
                      break;
              }
          }
          else if (this.state === 'Loading') {
              switch (eventType) {
                  case 'Waiting':
                      this.loading.patch({ progress: 20 });
                      return;
                  case 'DurationChange':
                      this.loading.patch({ progress: 40 });
                      return;
                  case 'LoadedMetadata':
                      this.loading.patch({ progress: 60 });
                      return;
                  case 'LoadedData':
                      this.loading.patch({ progress: 80 });
                      return;
                  case 'CanPlay':
                      this.loading.patch({ progress: 100 });
                      return;
                  case 'Playing':
                      this._setState('Hidden');
                      return;
              }
          }
          else if (this.state === 'Buffering') {
              switch (eventType) {
                  case 'Playing':
                      this._setState('Hidden');
                      return;
              }
          }
          else if (this.state === 'Seeking') {
              switch (eventType) {
                  case 'Seeked':
                      this._setState('Playing');
                      return;
              }
          }
          else if (this.state === 'Playing' || this.state === 'Paused') {
              switch (eventType) {
                  case 'TimeUpdate': {
                      this._setProgressBarValue();
                      this._checkIfBumperNeeded();
                      break;
                  }
                  case 'Waiting':
                      this._setState('Buffering');
                      break;
              }
          }
      }
      _checkIfBumperNeeded() {
          if (!this._bumperFired) {
              const remainingTime = VideoPlayer.duration - VideoPlayer.currentTime;
              if (remainingTime <= SECONDS_TO_FIRE_BUMPER) {
                  this.bumper.patch({ item: Store$1.nextVideo });
                  this._bumperFired = true;
              }
          }
      }
      //
      // helpers
      _setProgressBarValue(currentTime = VideoPlayer.currentTime, duration = VideoPlayer.duration) {
          const durationScaled = clamp01(currentTime / Math.max(duration, 1));
          const progress = clamp(BAR_WIDTH * durationScaled, 10, BAR_WIDTH);
          const remainingTime = duration - currentTime;
          const currentTimeText = this._formatTime(Math.floor(currentTime));
          const remainingTimeText = this._formatTime(Math.floor(remainingTime));
          this.progressIndicator.patch({ w: progress });
          const currentTimeTextTag = this.currentTime.text;
          if (currentTimeTextTag) {
              currentTimeTextTag.text = currentTimeText;
          }
          const remainingTimeTextTag = this.remainingTime.text;
          if (remainingTimeTextTag) {
              remainingTimeTextTag.text = remainingTimeText;
          }
      }
      _seek(value) {
          this._setState('Seeking');
          this._setStateIcon(value > 0 ? 'SeekForward' : 'SeekBackward');
          this._seekValue = clamp(this._seekValue + value, 0, VideoPlayer.duration);
          this._setProgressBarValue(this._seekValue);
      }
      _setStateIcon(status) {
          switch (status) {
              case 'Play':
                  this.statusIcon.src = Utils.asset('images/player/play.png');
                  break;
              case 'Pause':
                  this.statusIcon.src = Utils.asset('images/player/pause.png');
                  break;
              case 'SeekForward':
                  this.statusIcon.src = Utils.asset('images/player/seek_forward.png');
                  break;
              case 'SeekBackward':
                  this.statusIcon.src = Utils.asset('images/player/seek_backward.png');
                  break;
          }
      }
      _formatTime(time) {
          const minutes = Math.floor(time / 60);
          const seconds = time - minutes * 60;
          const minutesText = minutes > 0 && minutes !== Infinity ? `${minutes}m` : '';
          const secondsText = seconds !== Infinity ? `${seconds}s` : '';
          return minutesText + secondsText;
      }
      _onFF() {
          this._seek(10);
      }
      _onRW() {
          this._seek(-10);
      }
      get controls() {
          return this.tag('Controls');
      }
      get buffering() {
          return this.tag('Buffering');
      }
      get loading() {
          return this.tag('Loading');
      }
      get bumper() {
          return this.tag('Bumper');
      }
      get statusIcon() {
          return this.tag('Controls').tag('StatusIcon');
      }
      get currentTime() {
          return this.tag('Controls')
              .tag('Time')
              .tag('Current');
      }
      get remainingTime() {
          return this.tag('Controls')
              .tag('Time')
              .tag('Remaining');
      }
      get progressIndicator() {
          return this.tag('Controls')
              .tag('ProgressBar')
              .tag('Progress');
      }
  }

  class Screensaver extends lightning.Component {
      static _template() {
          return {
              w: 1920,
              h: 1080,
              alpha: 0,
              Background: {
                  w: (w) => w,
                  h: (h) => h,
                  src: Utils.asset('images/splash_fhd.jpg'),
              },
              Label: {
                  w: (w) => w,
                  h: (h) => h,
                  y: 750,
                  text: {
                      text: 'Screensaver',
                      textAlign: 'center',
                      fontSize: 200,
                      highlight: false,
                  },
              },
          };
      }
      _focus() {
          this.setSmooth('alpha', 1);
      }
      _unfocus() {
          this.setSmooth('alpha', 0);
      }
  }

  class PlayerUI extends lightning.Component {
      constructor() {
          super(...arguments);
          this.minutesToShowScreenSaver = 15;
          this._screenSaverTimer = new Timer(this, this.minutesToShowScreenSaver * 60, () => this._setState('Screensaver'));
      }
      static _template() {
          return {
              PlayerControls: {
                  type: PlayerControls,
                  signals: {
                      playerState: true,
                      screenKey: true,
                  },
              },
              NowPlayingTray: {
                  type: NowPlayingTray,
                  signals: {
                      autohide: '$nowPlayingTrayAutohide',
                      screenKey: true,
                  },
              },
              Screensaver: {
                  type: Screensaver,
              },
          };
      }
      static _states() {
          return [
              class PlayerControlsFocused extends this {
                  _getFocused() {
                      return this.tag('PlayerControls');
                  }
                  _handleUp() {
                      this._setState('NowPlayingTrayFocused');
                  }
                  _handleDown() {
                      this._setState('NowPlayingTrayFocused');
                  }
              },
              class NowPlayingTrayFocused extends this {
                  _getFocused() {
                      return this.tag('NowPlayingTray');
                  }
                  _handleUp() {
                      this._setState('PlayerControlsFocused');
                  }
                  _handleDown() {
                      this._setState('PlayerControlsFocused');
                  }
                  _handleBack() {
                      this._setState('PlayerControlsFocused');
                  }
              },
              class Screensaver extends this {
                  _getFocused() {
                      return this.tag('Screensaver');
                  }
                  _captureKey() {
                      this._setState('PlayerControlsFocused');
                      this._resetTimer();
                  }
              },
          ];
      }
      _init() {
          this._setState('PlayerControlsFocused');
          Events.on('$app.cellSelected', this.$cellSelected.bind(this));
      }
      _resetTimer() {
          if (this.screensaver.visible) {
              this._screenSaverTimer.start();
          }
          else {
              this._screenSaverTimer.stop();
          }
      }
      async $cellSelected() {
          this._setState('PlayerControlsFocused');
      }
      $nowPlayingTrayAutohide() {
          this._setState('PlayerControlsFocused');
      }
      screenKey() {
          this._resetTimer();
      }
      playerState(state) {
          this.screensaver.visible = state === 'Paused' || state === 'Seeking';
          this._resetTimer();
      }
      get screensaver() {
          return this.tag('Screensaver');
      }
  }

  class HomePageTop extends lightning.Component {
      static _template() {
          const w = 1920;
          const h = 1080;
          return {
              w: w,
              h: h,
              Background: {
                  x: 0,
                  y: 0,
                  w: w,
                  h: h,
                  rect: true,
                  colorTop: 0x00000000,
                  colorBottom: 0xff000000,
              },
              Item: {},
          };
      }
      _init() {
          this._setState('ItemFocused');
      }
      _getFocused() {
          return this.item;
      }
      get item() {
          return this.tag('Item');
      }
      set item(value) {
          this.patch({ Item: undefined });
          this.patch({ Item: value });
          this.item.y = 930 - this.item.h;
      }
  }

  class PlayerMetrics {
      constructor() {
          this.started = false;
      }
      start() {
          if (!this.started) {
              this.started = true;
              Platform.appActionMetricsHandler('CONTENT_STATE_CHANGE', { contentState: 'STARTED' });
          }
      }
      stop() {
          if (this.started) {
              this.started = false;
              Platform.appActionMetricsHandler('CONTENT_STATE_CHANGE', {
                  contentState: 'STOPPED',
                  duration: VideoPlayer.currentTime,
              });
          }
      }
  }
  var PlayerMetrics$1 = new PlayerMetrics();

  class HomePage extends SplitPage {
      constructor() {
          super(...arguments);
          this.params = {
              hiddenOnLoad: false,
              contentFocusedOnLoad: false,
              skipAutoPlay: false,
              focusOnLastItem: false,
              navigateBack: false,
          };
          this._hideTimer = new Timer(this, 20, () => {
              if (this.active) {
                  this._setState('AllHidden');
              }
          });
          this._contentSettings = {
              enabled: true,
              yOffsetByState: {
                  landingFocused: 970,
                  contentFocused: 0,
                  allHidden: 1100,
              },
          };
          this._toasterFired = false;
          this._secondsToShowExitToast = 15;
      }
      static _template() {
          return {
              ...super._template(),
              landingComponent: {
                  type: HomePageTop,
              },
              contentComponent: {
                  y: 20,
                  itemSpacing: 69,
                  type: Column,
              },
              PlayerUI: {
                  type: PlayerUI,
              },
          };
      }
      static _states() {
          return [
              class LandingFocused extends this {
                  $enter() {
                      const row = CreateRow(Store$1.contentGrid.channels[0]);
                      this.landingComponent.patch({ item: row });
                      this.landingContainer.setSmooth('alpha', 1, this.animDuration);
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.landingFocused, this.animDuration);
                      this.tag('PlayerUI').setSmooth('alpha', 0);
                      this.widgets.tabmenu.show();
                  }
                  $exit() {
                      this.landingContainer.setSmooth('alpha', 0, this.animDuration);
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.allHidden, this.animDuration);
                      this.widgets.tabmenu.hide();
                  }
                  _getFocused() {
                      return this.landingComponent;
                  }
                  _handleUp() {
                      Router.focusWidget('TabMenu');
                  }
                  _handleDown() {
                      if (this._contentSettings.enabled) {
                          this._setState('ContentFocused');
                          return true;
                      }
                      return false;
                  }
                  _handleBack() {
                      Router.focusWidget('TabMenu');
                  }
                  async $cellSelected(payload) {
                      this._updateStore(payload);
                      super.$cellSelected(payload);
                  }
              },
              class ContentFocused extends this {
                  $enter() {
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.contentFocused, this.animDuration);
                      this.contentBackground.setSmooth('alpha', 1, this.animDuration);
                  }
                  $exit() {
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.allHidden, this.animDuration);
                      this.contentBackground.setSmooth('alpha', 0, this.animDuration);
                  }
                  _getFocused() {
                      return this.contentComponent;
                  }
                  _handleUp() {
                      this._setState('LandingFocused');
                  }
                  _handleBack() {
                      this._setState('LandingFocused');
                  }
                  async $cellSelected(payload) {
                      this._updateStore(payload);
                      super.$cellSelected(payload);
                  }
              },
              class AllHidden extends this {
                  $enter() {
                      this.tag('Containers').setSmooth('alpha', 0, this.animDuration);
                      this.tag('PlayerUI').setSmooth('alpha', 1);
                      this.widgets.tabmenu.hide();
                  }
                  $exit() {
                      this.tag('Containers').setSmooth('alpha', 1, this.animDuration);
                      this.tag('PlayerUI').setSmooth('alpha', 0);
                  }
                  _getFocused() {
                      return this.tag('PlayerUI');
                  }
                  _handleBack() {
                      if (Store$1.flags.playingDeeplinkedVideo)
                          return;
                      if (!this.params.navigateBack) {
                          const firstRowFocused = Store$1.contentGrid.position.y === 0;
                          this._setState(firstRowFocused ? 'LandingFocused' : 'ContentPeeking');
                      }
                      else {
                          Router.step(-1);
                      }
                  }
              },
              class ContentPeeking extends this {
                  $enter() {
                      const { x: selectedVideoIndex, y: selectedChannelIndex, } = Store$1.selectedGrid.position;
                      const row = {
                          ...CreateRow(Store$1.selectedChannel),
                          selectedIndex: selectedVideoIndex,
                      };
                      this.landingComponent.patch({ item: row });
                      this._focusCell({ x: 0, y: selectedChannelIndex + 1 }); // TODO: x: 0 is not exactly accurate with the roku app, but I think we need to revisit this idea of separating the grid into "peek" and "content" sections for making it work good
                      this.landingContainer.setSmooth('alpha', 1, this.animDuration);
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.landingFocused, this.animDuration);
                      this.tag('PlayerUI').setSmooth('alpha', 0);
                      this.widgets.tabmenu.show();
                  }
                  $exit() {
                      this.landingContainer.setSmooth('alpha', 0, this.animDuration);
                      this.contentContainer.setSmooth('y', this._contentSettings.yOffsetByState.allHidden, this.animDuration);
                      this.widgets.tabmenu.hide();
                  }
                  _getFocused() {
                      return this.landingComponent;
                  }
                  _handleUp() {
                      const { y: selectedChannelIndex } = Store$1.selectedGrid.position;
                      const peekRowOffset = 1;
                      const goingUpOffset = 1;
                      const newChannelIndex = Math.max(selectedChannelIndex - peekRowOffset - goingUpOffset, 0);
                      const backToTheTop = newChannelIndex === 0;
                      if (backToTheTop) {
                          this._focusCell({ y: 0 });
                          this._setState('LandingFocused');
                      }
                      else {
                          this._focusCell({ y: newChannelIndex });
                          this._setState('ContentFocused');
                      }
                  }
                  _handleDown() {
                      this._setState('ContentFocused');
                  }
                  _handleBack() {
                      this._setState('LandingFocused');
                  }
                  async $cellSelected(payload) {
                      super.$cellSelected(payload);
                      Store$1.selectedGrid.position.x = payload.row.selectedIndex;
                  }
              },
          ];
      }
      //
      // callbacks
      _init() {
          Events.on('$player.playerEvent', this.$playerEvent.bind(this));
          Events.on('$app.cellSelected', this.$cellSelected.bind(this));
      }
      _disable() {
          VideoPlayer.pause();
          PlayerMetrics$1.stop();
      }
      $playerEvent({ type: eventType }) {
          switch (eventType) {
              case 'Error':
              case 'Ended': {
                  if (Store$1.flags.playingDeeplinkedVideo) {
                      Store$1.flags.playingDeeplinkedVideo = false;
                  }
                  this._playNextVideo();
                  break;
              }
              case 'TimeUpdate': {
                  if (Store$1.flags.playingDeeplinkedVideo) {
                      this._checkIfExitToastNeeded();
                  }
                  break;
              }
          }
      }
      _checkIfExitToastNeeded() {
          const remainingTime = VideoPlayer.duration - VideoPlayer.currentTime;
          if (!this._toasterFired && remainingTime <= this._secondsToShowExitToast) {
              this._toasterFired = true;
              Platform.showToaster('ExitMessage.PressExit');
          }
      }
      _playFirstVideo() {
          const playlistChannels = Store$1.contentPlaylistChannels;
          const video = playlistChannels[0].videos[0];
          PlayerMetrics$1.stop();
          this._selectVideo(video);
          PlayerMetrics$1.start();
      }
      _playNextVideo() {
          Store$1.selectNextVideoOrChannel();
          const video = Store$1.selectedVideo;
          if (video) {
              this._selectVideo(video);
          }
      }
      _selectVideo(video) {
          Events.emit('$app.videoSelected', video);
      }
      _focus() {
          this._hideTimer.start();
      }
      _onDataProvided() {
          const channels = this.data.channels;
          const rows = channels.map((channel) => CreateRow(channel));
          const [firstRow, ...restOfRows] = rows;
          this.landingComponent.patch({ item: firstRow });
          this.contentComponent.patch({ items: restOfRows });
          if (Store$1.isReady) {
              Store$1.contentGrid.channels = channels;
          }
          else {
              Store$1.contentGrid = {
                  channels: channels,
                  position: { x: 0, y: 0 },
              };
          }
          if (this.params.hiddenOnLoad) {
              this._setState('AllHidden');
          }
          else if (this.params.contentFocusedOnLoad) {
              this._setState('ContentFocused');
          }
          else {
              this._setState('LandingFocused');
          }
          if (!this.params.skipAutoPlay) {
              this._playFirstVideo();
          }
          if (this.params.focusOnLastItem) {
              this._focusCell(Store$1.contentGrid.position);
          }
      }
      _focusCell({ x: rowIndex = this.contentRowIndex, y: columnIndex = this.contentColumnIndex, }) {
          if (columnIndex == 0) {
              const landingRow = this.landingComponent;
              landingRow.selectedIndex = rowIndex;
          }
          else {
              this.contentColumnIndex = clamp(columnIndex - 1, 0, this.column.items.length - 1);
              this.contentRowIndex = rowIndex;
          }
      }
      _updateStore(payload) {
          const newState = {
              channels: this.data.channels,
              position: {
                  x: payload.row.selectedIndex,
                  y: this.channelIndex,
              },
          };
          Store$1.contentGrid = newState;
          Store$1.selectedGrid = newState;
      }
      set contentColumnIndex(value) {
          this.column.selectedIndex = value;
      }
      get contentColumnIndex() {
          return this.column.selectedIndex;
      }
      get contentRowIndex() {
          return this.column.selected.row.selectedIndex;
      }
      set contentRowIndex(value) {
          this.column.selected.row.selectedIndex = value;
      }
      get channelIndex() {
          return this._getState() == 'LandingFocused' ? 0 : this.column.selectedIndex + 1;
      }
      //
      // events
      async $cellSelected(payload) {
          Log.info('HomePage $cellSelected >', payload);
          const cellData = payload.cell.data;
          if ('videoUrl' in cellData) {
              PlayerMetrics$1.stop();
              const video = cellData;
              this._selectVideo(video);
              PlayerMetrics$1.start();
          }
          else if ('title' in cellData) {
              const uri = encodeURIComponent(cellData.id);
              if (payload.cell instanceof PagesCell) {
                  Router.navigate('show/' + uri);
              }
              else if (payload.cell instanceof PlaylistsCell) {
                  Router.navigate('playlist/' + uri);
              }
          }
          this._setState('AllHidden');
          Log.info('< $cellSelected');
      }
      //
      // properties
      get column() {
          return this.contentComponent;
      }
      //
      // input
      _handleBack() {
          // prevent the router from consuming this event
      }
      _captureKey() {
          this._hideTimer.start();
          return false;
      }
  }

  class InputField extends lightning.Component {
      constructor() {
          super(...arguments);
          this.maxLength = 0;
          this._value = '';
          this._cursorPosition = 0;
      }
      static _template() {
          return {
              Field: {
                  text: { text: '', textColor: 0xeeffffff },
              },
              Cursor: {
                  rect: true,
                  color: 0x7fffffff,
                  h: 40,
                  w: 2,
                  y: 7,
              },
              /**
               * Hidden value is used for measuring where the cursor should
               * be positioned when a user changes the cursor position. Since
               * the text is one texture we don't know the exact position of each
               * individual character, so we render a substring version of the text
               * to determine the renderwidth and position the cursor based on that number
               */
              HiddenValue: {
                  alpha: 0.00001,
                  text: { text: '', textColor: 0xeeffffff },
              },
          };
      }
      _init() {
          this._blinkAnimation = this.cursor.animation({
              duration: 1,
              repeat: -1,
              actions: [{ p: 'alpha', v: { 0: 1, 0.5: 0, 1: 1 } }],
          });
      }
      _active() {
          if (this._blinkAnimation) {
              this._blinkAnimation.start();
          }
      }
      _inactive() {
          if (this._blinkAnimation) {
              this._blinkAnimation.stop();
          }
      }
      _focus() {
          this.patch({
              Cursor: { smooth: { w: 3 } },
          });
      }
      _unfocus() {
          this.patch({
              Cursor: { smooth: { w: 4 } },
          });
      }
      _calculatePositionByIndex(str, index) {
          const value = str.substring(0, index);
          // update hidden value and calc width
          const hiddenValue = this.tag('HiddenValue');
          if (hiddenValue.text) {
              hiddenValue.text.text = value;
          }
          hiddenValue.loadTexture();
          return this.tag('HiddenValue').renderWidth;
      }
      _applyMask(value) {
          if (this._mask) {
              return this._mask(value);
          }
          else {
              return value;
          }
      }
      _truncateText(value) {
          let text = value;
          if (this.maxLength > 0) {
              if (text.length > this.maxLength) {
                  text = text.substring(0, this.maxLength) + '...';
              }
          }
          return text;
      }
      _change(value, del = false, addition = '') {
          const position = this._cursorPosition;
          const currentValue = this._value;
          const field = this.tag('Field');
          let text = value;
          text = this._applyMask(text);
          text = this._truncateText(text);
          field.patch({ text: text });
          field.loadTexture();
          if (value.length === 0) {
              this._cursorPosition = 0;
              this.cursor.setSmooth('x', 0);
          }
          else {
              // if we invoke text on custom position
              if (position < currentValue.length) {
                  const newIndex = del ? position - 1 : position + addition.length;
                  const newPosition = this._calculatePositionByIndex(value, newIndex);
                  this.cursor.setSmooth('x', newPosition);
                  this._cursorPosition = newIndex;
              }
              else {
                  this.cursor.setSmooth('x', field.renderWidth + 4);
                  this._cursorPosition = value.length;
              }
          }
          this._value = value;
          this.signal('onValueChanged', value);
          return value;
      }
      insert(str) {
          let value = this._value;
          const position = this._cursorPosition;
          if (position < value.length) {
              const start = value.substring(0, position);
              const end = value.substring(position, value.length);
              value = `${start}${str}${end}`;
          }
          else {
              value += `${str}`;
          }
          return this._change(value);
      }
      delete() {
          let value = this._value;
          const position = this._cursorPosition;
          if (position < value.length) {
              const start = value.substring(0, position - 1);
              const end = value.substring(position, value.length);
              value = `${start}${end}`;
              return this._change(value, true);
          }
          else {
              return this._change(value.substring(0, value.length - 1));
          }
      }
      clear() {
          this._change('', true);
      }
      get cursor() {
          return this.tag('Cursor');
      }
      get value() {
          return this._value;
      }
      set mask(value) {
          this._mask = value;
      }
      set resetValue(value) {
          this._change(value, true);
      }
      set textStyle(value) {
          this.tag('Field').patch({ text: value });
      }
      _handleLeft() {
          const pos = this._cursorPosition;
          if (pos > 0) {
              const position = this._calculatePositionByIndex(this._value, pos - 1);
              this.cursor.setSmooth('x', position);
              --this._cursorPosition;
          }
      }
      _handleRight() {
          const pos = this._cursorPosition;
          if (pos < this._value.length) {
              const position = this._calculatePositionByIndex(this._value, pos + 1);
              this.cursor.setSmooth('x', position);
              ++this._cursorPosition;
          }
      }
  }

  class Layouts {
  }
  Layouts.search = {
      label: 'abc',
      characters: 'abcdefghijklmnopqrstuvwxyz1234567890'.split(''),
  };
  Layouts.lowercaseLetters = {
      label: 'abc',
      characters: '1234567890qwertyuiopasdfghjkl@zxcvbnm,.-'.split(''),
  };
  Layouts.uppercaseLetters = {
      label: 'ABC',
      characters: '!@#$%^&*()QWERTYUIOPASDFGHJKL@ZXCVBNM,.-'.split(''),
  };
  Layouts.lowercaseAccents = {
      label: 'àèü',
      characters: 'äëïöüÿàèìòùáéíóúýâêîôûãñ'.split(''),
  };
  Layouts.uppercaseAccents = {
      label: 'ÀÈÜ',
      characters: 'ÄËÏÖÜŸÀÈÌÒÙÁÉÍÓÚÝÂÊÎÔÛÃÑ'.split(''),
  };
  Layouts.numbers = {
      label: '123',
      characters: '1234567890'.split(''),
  };
  Layouts.special = {
      label: '!?#&',
      characters: '!@#$%^&*(){}[];"\'|\\/<>?±`~'.split(''),
  };

  class Key extends lightning.Component {
      static _template() {
          return {
              Background: {
                  w: (w) => w,
                  h: (h) => h,
                  rect: true,
              },
              Label: {
                  x: (x) => x / 2,
                  y: (y) => y / 2,
                  zIndex: 1,
                  mount: 0.5,
                  text: {
                      fontSize: 30,
                  },
              },
          };
      }
      _init() {
          this.focused = false;
      }
      _focus() {
          this.focused = true;
      }
      _unfocus() {
          this.focused = false;
      }
      set focused(value) {
          this.patch({
              Background: {
                  smooth: { alpha: value ? 1 : 0.5 },
              },
              Label: {
                  smooth: {
                      color: value ? 0xff000000 : 0xffffffff,
                  },
              },
          });
      }
      get labelComponent() {
          return this.tag('Label');
      }
      set label(value) {
          if (this.labelComponent.text) {
              this.labelComponent.text.text = value;
          }
      }
      get label() {
          return this.labelComponent.text ? this.labelComponent.text.text : '';
      }
      set backgroundColor(value) {
          this.tag('Background').patch({ color: value });
      }
  }

  class FunctionKey extends Key {
      static _template() {
          return {
              ...super._template(),
              Icon: {
                  x: (x) => x / 2,
                  y: (y) => y / 2,
                  zIndex: 1,
                  mount: 0.5,
                  visible: false,
              },
          };
      }
      set data(value) {
          this._data = value;
          this.label = value.label;
          if (value.src) {
              this.patch({
                  Label: {
                      visible: false,
                  },
                  Icon: {
                      src: value.src,
                      visible: true,
                  },
              });
          }
      }
      set focused(value) {
          this.patch({
              Background: {
                  smooth: { alpha: value ? 1 : 0.5 },
              },
              Label: {
                  smooth: {
                      color: value ? 0xff000000 : 0xffffffff,
                  },
              },
              Icon: {
                  smooth: {
                      color: value ? 0xff000000 : 0xffffffff,
                  },
              },
          });
      }
      _handleEnter() {
          if (this._data) {
              this.signal('onFunctionKeyPressed', this._data.eventName);
          }
      }
  }

  class KeyGroup extends lightning.Component {
      constructor() {
          super(...arguments);
          this._index = 0;
          this.keyWidth = 90;
          this.keyHeight = 90;
          this.keySpacing = 0;
          this.keyBackgroundColor = 0x00ffffff;
      }
      _getFocused() {
          return this.activeKey;
      }
      _setIndex(index) {
          if (index < 0 || index > this.keys.length - 1) {
              return false;
          }
          else {
              this._index = clamp(index, 0, this.keys.length - 1);
              this.signal('onIndexChanged', this._index);
              return true;
          }
      }
      get keys() {
          return this.children;
      }
      get activeKey() {
          return this.keys[this.index];
      }
      get index() {
          return this._index;
      }
      set index(value) {
          this._setIndex(value);
      }
      _handleLeft() {
          return this._setIndex(this.index - 1);
      }
      _handleRight() {
          return this._setIndex(this.index + 1);
      }
  }

  class CharacterKeyGroup extends KeyGroup {
      constructor() {
          super(...arguments);
          this.columnCount = 10;
      }
      get activeKey() {
          return super.activeKey;
      }
      set layout(value) {
          if (this._layout == value) {
              return;
          }
          this._layout = value;
          const chars = value.characters.map((label, i) => {
              return {
                  type: Key,
                  label: label,
                  x: (i % this.columnCount) * this.keyWidth,
                  y: Math.floor(i / this.columnCount) * this.keyHeight,
                  w: this.keyWidth - this.keySpacing * 2,
                  h: this.keyHeight - this.keySpacing * 2,
                  backgroundColor: this.keyBackgroundColor,
              };
          });
          this.patch({ children: undefined });
          this.patch({ children: chars });
          this.index = 0;
          this.signal('onReady');
      }
      _handleRight() {
          const realIndex = this._index;
          const rowIndex = realIndex % this.columnCount;
          if (rowIndex < this.columnCount - 1 && realIndex < this.keys.length - 1) {
              this.index = realIndex + 1;
              return true;
          }
          else {
              return false;
          }
      }
      _handleLeft() {
          const realIndex = this._index;
          const rowIndex = realIndex % this.columnCount;
          if (rowIndex > 0) {
              this.index = realIndex - 1;
              return true;
          }
          else {
              return false;
          }
      }
      _handleUp() {
          const realIndex = this._index;
          const newIndex = realIndex - this.columnCount;
          if (newIndex >= 0) {
              this.index = newIndex;
              return true;
          }
          else {
              return false;
          }
      }
      _handleDown() {
          const realIndex = this._index;
          const newIndex = realIndex + this.columnCount;
          if (newIndex < this.keys.length) {
              this.index = newIndex;
              return true;
          }
          else {
              return false;
          }
      }
      _handleEnter() {
          this.signal('onCharacterKeyPressed', this.activeKey.label);
      }
  }

  class FunctionKeyGroup extends KeyGroup {
      constructor() {
          super(...arguments);
          this.keyWidth = 270;
      }
      set functions(values) {
          const children = values.map((data, i) => {
              return {
                  x: this.keyWidth * i,
                  w: this.keyWidth - this.keySpacing * 2,
                  h: this.keyHeight - this.keySpacing * 2,
                  type: FunctionKey,
                  data: data,
                  backgroundColor: this.keyBackgroundColor,
                  passSignals: {
                      onFunctionKeyPressed: true,
                  },
              };
          });
          this.patch({ children });
      }
  }

  const charKeySize = 90;
  const charGroupRowCount = 6;
  const charGroupColumnCount = 6;
  const charKeyCount = charGroupRowCount * charGroupColumnCount;
  const charGroupHeight = charKeySize * charGroupRowCount;
  const functionKeyHeight = charKeySize;
  const functionKeyWidth = charKeySize * 2;
  const functionGroupRowCount = 1;
  const functionGroupHeight = charKeySize * functionGroupRowCount;
  const inputFieldTextPadding = 32;
  const inputFieldHeight = 68;
  const inputFieldAndKeyboardGap = 28;
  const keyboardHeight = charGroupHeight + functionGroupHeight;
  const width = charKeySize * charGroupRowCount;
  const height = inputFieldHeight + inputFieldAndKeyboardGap + keyboardHeight;
  const focusedKeyScale = 1.4;
  const roundedRectangleShader = {
      type: lightning.shaders.RoundedRectangle,
      radius: 10,
      stroke: 2,
      strokeColor: 0x77000000,
  };
  const background = {
      w: (w) => w,
      h: (h) => h,
      rect: true,
      color: 0x33c4c4c4,
      //shader: roundedRectangleShader,
  };
  class Keyboard extends lightning.Component {
      static _template() {
          return {
              w: width,
              h: height,
              InputField: {
                  w: (w) => w,
                  h: inputFieldHeight,
                  Background: background,
                  Field: {
                      x: inputFieldTextPadding,
                      y: 6,
                      type: InputField,
                      maxLength: 15,
                      passSignals: {
                          onValueChanged: true,
                      },
                      textStyle: {
                          fontSize: 44,
                          textColor: 0xffffffff,
                          fontFace: 'FoundersGroteskMono-Regular',
                      },
                  },
              },
              Keyboard: {
                  w: (w) => w,
                  h: keyboardHeight,
                  y: inputFieldHeight + inputFieldAndKeyboardGap,
                  Background: background,
                  CharacterKeyGroup: {
                      w: (w) => w,
                      h: charGroupHeight,
                      type: CharacterKeyGroup,
                      columnCount: charGroupColumnCount,
                      keyWidth: charKeySize,
                      keyHeight: charKeySize,
                      signals: {
                          onCharacterKeyPressed: true,
                          onIndexChanged: true,
                      },
                  },
                  FunctionKeyGroup: {
                      w: (w) => w,
                      h: charKeySize,
                      y: charGroupHeight,
                      type: FunctionKeyGroup,
                      keyWidth: functionKeyWidth,
                      keyHeight: functionKeyHeight,
                      functions: [
                          {
                              label: 'Clear',
                              eventName: 'onClear',
                              src: Utils.asset('images/keyboard/clear.png'),
                          },
                          {
                              label: 'Space',
                              eventName: 'onSpace',
                              src: Utils.asset('images/keyboard/space.png'),
                          },
                          {
                              label: 'Delete',
                              eventName: 'onDelete',
                              src: Utils.asset('images/keyboard/delete.png'),
                          },
                      ],
                      signals: {
                          onFunctionKeyPressed: true,
                          onIndexChanged: true,
                      },
                  },
                  FocusedKeyIndicator: {
                      x: charKeySize / 2,
                      y: charKeySize / 2,
                      w: charKeySize * focusedKeyScale,
                      h: charKeySize * focusedKeyScale,
                      mount: 0.5,
                      rect: true,
                      colorTop: 0xffd0cfd1,
                      colorBottom: 0xffafafb1,
                      //shader: roundedRectangleShader,
                  },
              },
          };
      }
      static _states() {
          return [
              class CharacterKeyGroupFocused extends this {
                  $enter() {
                      this._updateFocusedKeyIndicator();
                  }
                  _getFocused() {
                      return this.characterKeyGroup;
                  }
                  _handleDown() {
                      const charGroupLastRowFirstKeyIndex = charKeyCount - charGroupRowCount;
                      const functionGroupNewIndex = Math.floor((this.characterKeyGroup.index - charGroupLastRowFirstKeyIndex) / 2);
                      this.functionKeyGroup.index = functionGroupNewIndex;
                      this._setState('FunctionKeyGroupFocused');
                  }
                  onCharacterKeyPressed(char) {
                      this.inputField.insert(char);
                  }
              },
              class FunctionKeyGroupFocused extends this {
                  $enter() {
                      this._updateFocusedKeyIndicator();
                  }
                  _getFocused() {
                      return this.tag('Keyboard.FunctionKeyGroup');
                  }
                  _handleUp() {
                      const charGroupLastRowFirstKeyIndex = charKeyCount - charGroupRowCount;
                      const charGroupNewIndex = charGroupLastRowFirstKeyIndex + this.functionKeyGroup.index * 2;
                      this.characterKeyGroup.index = charGroupNewIndex;
                      this._setState('CharacterKeyGroupFocused');
                  }
                  onFunctionKeyPressed(eventName) {
                      switch (eventName) {
                          case 'onClear':
                              this.inputField.clear();
                              break;
                          case 'onSpace':
                              this.inputField.insert(' ');
                              break;
                          case 'onDelete':
                              this.inputField.delete();
                              break;
                      }
                  }
              },
          ];
      }
      _init() {
          this.characterKeyGroup.layout = Layouts.search;
          this._setState('CharacterKeyGroupFocused');
          this._updateFocusedKeyIndicator();
      }
      _focus() {
          this.focusedKeyIndicator.setSmooth('alpha', 1);
      }
      _unfocus() {
          this.focusedKeyIndicator.setSmooth('alpha', 0);
      }
      onIndexChanged() {
          this._updateFocusedKeyIndicator();
      }
      _updateFocusedKeyIndicator() {
          const x = this.activeKey.x;
          const y = this.activeKeyGroup.y + this.activeKey.y;
          this.focusedKeyIndicator.patch({
              smooth: {
                  w: this.activeKey.w * focusedKeyScale,
                  h: this.activeKey.h * focusedKeyScale,
                  x: x + this.activeKey.w / 2,
                  y: y + this.activeKey.h / 2,
              },
          });
      }
      get inputField() {
          return this.tag('InputField.Field');
      }
      get characterKeyGroup() {
          return this.tag('Keyboard.CharacterKeyGroup');
      }
      get functionKeyGroup() {
          return this.tag('Keyboard.FunctionKeyGroup');
      }
      get focusedKeyIndicator() {
          return this.tag('FocusedKeyIndicator');
      }
      get activeKeyGroup() {
          return this._getState() == 'CharacterKeyGroupFocused'
              ? this.characterKeyGroup
              : this.functionKeyGroup;
      }
      get activeKey() {
          return this.activeKeyGroup.activeKey;
      }
      set value(value) {
          this.inputField.resetValue = value;
      }
  }

  class SearchPageContent extends lightning.Component {
      static _template() {
          const offset = 22;
          return {
              alpha: 0,
              clipping: true,
              Column: {
                  w: (w) => w,
                  h: (h) => h,
                  x: offset,
                  y: offset,
                  type: Column,
                  itemSpacing: SearchPageContent.gridSpacing,
              },
              HiddenRow: {},
          };
      }
      _getFocused() {
          return this.selectedCell;
      }
      _setRowIndex(columnIndex, rowIndex) {
          columnIndex = clamp(columnIndex, 0, this.column.items.length - 1);
          const row = this.column.items[columnIndex];
          row.selectedIndex = clamp(rowIndex, 0, row.items.length - 1);
      }
      get column() {
          return this.tag('Column');
      }
      get selectedRow() {
          return this.column.items[this.column.selectedIndex];
      }
      get selectedCell() {
          return this.selectedRow.selected;
      }
      get channel() {
          return this._channel;
      }
      set channel(channel) {
          this._channel = channel;
          if (!channel) {
              this.setSmooth('alpha', 0);
              return;
          }
          const cells = channel.videos.map((video) => {
              return {
                  type: PlaylistCell,
                  data: video,
              };
          });
          const rows = [];
          for (let i = 0; i < cells.length; i += 2) {
              rows.push({
                  type: Row,
                  itemSpacing: SearchPageContent.gridSpacing,
                  items: i + 1 < cells.length ? [cells[i], cells[i + 1]] : [cells[i]],
              });
          }
          this.column.items = rows;
          this.setSmooth('alpha', 1);
          this.patch({ HiddenRow: undefined });
          this.patch({ HiddenRow: { ...CreateRow(channel), alpha: 0 } });
      }
      _captureUp() {
          this._setRowIndex(this.column.selectedIndex - 1, this.selectedRow.selectedIndex);
          return this.column.selectPrevious();
      }
      _captureDown() {
          this._setRowIndex(this.column.selectedIndex + 1, this.selectedRow.selectedIndex);
          return this.column.selectNext();
      }
      _handleEnter() {
          const hiddenRow = this.tag('HiddenRow');
          hiddenRow.selectedIndex = this.column.selectedIndex * 2 + this.selectedRow.selectedIndex;
          Events.emit('$app.cellSelected', new CellSelectedPayload(hiddenRow, this.selectedCell));
      }
  }
  SearchPageContent.gridSpacing = 69;

  class SearchPage extends BasePage {
      constructor() {
          super(...arguments);
          this.params = {
              query: '',
          };
      }
      static _template() {
          const width = 1920;
          const height = 1080;
          const keyboardColumnWidth = 853;
          const divY = 237;
          const underlineY = 65;
          const underlineHeight = 9;
          const underlineContentGap = 29;
          const contentX = keyboardColumnWidth + 105;
          const contentY = underlineY + underlineHeight + underlineContentGap;
          return {
              w: width,
              h: height,
              Background: {
                  w: (w) => w,
                  h: (h) => h,
                  src: Utils.asset('images/search-page-background.png'),
              },
              Div: {
                  w: (w) => w,
                  h: (h) => h - divY,
                  y: divY,
                  Keyboard: {
                      x: keyboardColumnWidth / 2,
                      mountX: 0.5,
                      type: Keyboard,
                      signals: {
                          onDone: true,
                          onValueChanged: true,
                      },
                  },
                  Header: {
                      x: keyboardColumnWidth + 126,
                      text: {
                          text: 'SEARCH',
                          cutSy: 21,
                          fontSize: 60,
                          fontFace: 'FoundersGroteskCondensed-Semibold',
                      },
                      Underline: {
                          w: 111,
                          h: underlineHeight,
                          y: underlineY,
                          rect: true,
                          color: 0xffffffff,
                      },
                  },
                  Content: {
                      w: (w) => w - contentX,
                      h: (h) => h - contentY,
                      x: contentX,
                      y: contentY,
                      type: SearchPageContent,
                  },
                  Logo: {
                      x: contentX + (width - contentX) / 2,
                      y: (height - divY) / 2,
                      mount: 0.5,
                      alpha: 0,
                      src: Utils.asset('images/search-page-logo-placeholder.png'),
                  },
              },
          };
      }
      static _states() {
          return [
              class KeyboardFocused extends this {
                  _getFocused() {
                      return this.keyboard;
                  }
                  _handleBack() {
                      Router.focusWidget('TabMenu');
                  }
                  _handleUp() {
                      Router.focusWidget('TabMenu');
                  }
                  _handleRight() {
                      if (this.content.channel) {
                          this._setState('ContentFocused');
                          return true;
                      }
                      return false;
                  }
              },
              class ContentFocused extends this {
                  _getFocused() {
                      return this.content;
                  }
                  _handleUp() {
                      Router.focusWidget('TabMenu');
                  }
                  _handleLeft() {
                      this._setState('KeyboardFocused');
                  }
              },
          ];
      }
      _init() {
          this._setState('KeyboardFocused');
          Events.on('$app.cellSelected', this.$cellSelected.bind(this));
      }
      _firstEnable() {
          const urlDeeplinkQuery = Store$1.qs.query;
          if (urlDeeplinkQuery) {
              this.keyboard.value = urlDeeplinkQuery;
          }
      }
      _onDataProvided() {
          const launchpointDeeplinkQuery = this.params.query;
          if (launchpointDeeplinkQuery) {
              this.keyboard.value = launchpointDeeplinkQuery;
          }
      }
      _backToHome() {
          const path = 'brand/' + BrandName.nbcnews;
          Router.navigate(path, {
              hiddenOnLoad: true,
              skipAutoPlay: true,
              focusOnLastItem: true,
              navigateBack: true,
          });
      }
      async $cellSelected(payload) {
          if (this.active && this.content.channel) {
              Log.info('SearchPage $cellSelected >', payload);
              const videoIndex = payload.row.selectedIndex;
              Store$1.selectedGrid = {
                  channels: [this.content.channel],
                  position: {
                      x: videoIndex,
                      y: 0,
                  },
              };
              this._backToHome();
          }
      }
      async onValueChanged(value) {
          if (value.length == 0) {
              this.content.channel = undefined;
              this.headerText = 'SEARCH';
              return;
          }
          if (value.length < 3 || !this.fetchSearchQuery) {
              return;
          }
          this.content.channel = undefined;
          this.headerText = 'SEARCHING...';
          this.logo.setSmooth('alpha', 1);
          const videos = await this.fetchSearchQuery(value);
          this.logo.setSmooth('alpha', 0);
          if (videos.length > 0) {
              this.content.channel = {
                  type: 'playlist',
                  title: `RESULTS FOR "${value}"`,
                  videos: videos,
              };
              this.headerText = `${videos.length} ITEMS FOUND`;
          }
          else {
              this.headerText = 'NO ITEMS FOUND';
          }
      }
      get keyboard() {
          return this.tag('Div.Keyboard');
      }
      get content() {
          return this.tag('Div.Content');
      }
      get logo() {
          return this.tag('Div.Logo');
      }
      set headerText(value) {
          this.tag('Div.Header').patch({ text: value });
      }
  }

  class Section extends lightning.Component {
  }

  class QRSection extends Section {
      static _template() {
          const menuWidth = 400;
          const titleMargin = 120;
          const infoTextFontSize = 34;
          const infoColor = 0x66ffffff;
          return {
              Title: {
                  x: menuWidth - titleMargin,
                  h: 45,
                  mountX: 1,
                  text: {
                      text: '',
                      fontSize: 30,
                      textAlign: 'right',
                      fontFace: 'FoundersGroteskCondensed-Regular',
                  },
              },
              Content: {
                  x: menuWidth,
                  alpha: 0,
                  Image: {
                      x: 156,
                      y: 383,
                  },
                  Texts: {
                      x: 451,
                      y: 447,
                      Info: {
                          text: {
                              text: '',
                              fontSize: infoTextFontSize,
                              textColor: infoColor,
                              fontFace: 'FoundersGroteskCondensed-Regular',
                          },
                      },
                      Link: {
                          y: 97,
                          mountY: 0.5,
                          text: {
                              text: '',
                              fontSize: 60,
                              textColor: 0xffffffff,
                              fontFace: 'FoundersGroteskCondensed-Semibold',
                          },
                      },
                      SubInfo: {
                          y: 163,
                          text: {
                              text: '',
                              fontSize: infoTextFontSize,
                              textColor: infoColor,
                              fontFace: 'FoundersGroteskCondensed-Regular',
                          },
                      },
                  },
              },
          };
      }
      set focused(value) {
          this.patch({
              Title: {
                  smooth: { alpha: value ? 1 : 0.4 },
              },
              Content: {
                  smooth: { alpha: value ? 1 : 0 },
              },
          });
      }
      get title() {
          return this.tag('Title');
      }
      set title(value) {
          this.title.patch({ text: value });
      }
      set image(src) {
          this.tag('Content.Image').src = src;
      }
      set info(text) {
          this.tag('Content.Texts.Info').patch({ text: text });
      }
      set link(text) {
          this.tag('Content.Texts.Link').patch({ text: text });
      }
      set subinfo(text) {
          this.tag('Content.Texts.SubInfo').patch({ text: text });
      }
  }

  class SettingsPage extends RouterPage {
      constructor() {
          super(...arguments);
          this._index = 0;
      }
      static _template() {
          const width = 1920;
          const height = 1080;
          const inDevMode = Settings.get('app', 'debug', false);
          const appVersion = Settings.get('app', 'version', '0.0.0');
          const X1device = new X1();
          const debugTextHeight = 58;
          const debugTextStyle = {
              fontSize: 25,
              textAlign: 'right',
              textColor: 0x4dffffff,
              fontFace: 'FoundersGroteskCondensed-Regular',
          };
          return {
              w: width,
              h: height,
              Background: {
                  w: (w) => w,
                  h: (h) => h,
                  src: Utils.asset('images/settings-page/settings-background.png'),
              },
              Sections: {
                  Privacy: {
                      type: QRSection,
                      title: 'PRIVACY',
                      image: Utils.asset('images/settings-page/qr-codes/qr-code-privacy.png'),
                      info: 'To view the NBCUniversal Privacy Policy please visit',
                      link: 'nbcuniversal.com/privacy',
                  },
                  Terms: {
                      type: QRSection,
                      title: 'TERMS',
                      image: Utils.asset('images/settings-page/qr-codes/qr-code-terms.png'),
                      info: 'To view our Terms of Service please visit',
                      link: 'nbcnews.com/pages/terms-of-service',
                  },
                  Info: {
                      type: QRSection,
                      title: 'DO NOT SELL MY INFO',
                      image: Utils.asset('images/settings-page/qr-codes/qr-code-do-not-sell-my-info.png'),
                      info: 'For more information please visit',
                      link: 'nbcuniversal.com/privacy/notrtoo',
                  },
                  Notice: {
                      type: QRSection,
                      title: 'CA NOTICE',
                      image: Utils.asset('images/settings-page/qr-codes/qr-code-ccpa.png'),
                      info: 'For more information please visit',
                      link: {
                          fontSize: 40,
                          text: 'nbcuniversal.com/privacy/california-consumer-privacy-act',
                      },
                  },
                  Feedback: {
                      type: QRSection,
                      title: 'FEEDBACK',
                      image: Utils.asset('images/settings-page/qr-codes/qr-code-feedback.png'),
                      info: 'We are here to help with any issue or question you might have. Email us at:',
                      subinfo: `Include in email:   Device:  ${X1device.deviceType}    App:  v${appVersion}`,
                      link: 'tvapp.support@nbcnews.com',
                  },
              },
              FocusIndicator: {
                  x: 399,
                  w: 14,
                  h: 37,
                  mountX: 1,
                  rect: true,
                  color: 0xffffffff,
              },
              AppDebugInfo: {
                  x: 58,
                  Version: {
                      y: height - debugTextHeight,
                      text: {
                          ...debugTextStyle,
                          text: `Version: v${appVersion}`,
                      },
                  },
                  DebugMode: {
                      y: height - debugTextHeight * 2,
                      text: {
                          ...debugTextStyle,
                          text: inDevMode ? 'Debug Mode' : '',
                      },
                  },
              },
          };
      }
      _init() {
          const titlesYPosition = 462;
          const titlesSpacing = 25;
          this.sections.forEach((section, i) => {
              section.title.y = titlesYPosition + (section.title.h + titlesSpacing) * i;
          });
          this.focusIndicator.y = this.selectedSection.title.y;
          this._setIndex(0);
      }
      _getFocused() {
          return this;
      }
      _setIndex(newIndex) {
          newIndex = clamp(newIndex, 0, this.sections.length - 1);
          const indexChanged = this._index != newIndex;
          this._index = newIndex;
          this.sections.forEach((section, i) => {
              section.focused = newIndex == i;
          });
          this.focusIndicator.setSmooth('y', this.selectedSection.title.y);
          return indexChanged;
      }
      get sections() {
          return this.tag('Sections').children;
      }
      get focusIndicator() {
          return this.tag('FocusIndicator');
      }
      get selectedSection() {
          return this.sections[this._index];
      }
      _handleUp() {
          const changedIndex = this._setIndex(this._index - 1);
          if (!changedIndex) {
              Router.focusWidget('TabMenu');
          }
      }
      _handleDown() {
          return this._setIndex(this._index + 1);
      }
      _handleBack() {
          Router.focusWidget('TabMenu');
      }
  }

  class ErrorPage extends lightning.Component {
      static _template() {
          return {
              Background: {
                  w: 1920,
                  h: 1080,
                  src: Utils.asset('images/background.png'),
              },
              Label: {
                  w: 1920,
                  y: 1080 / 2,
                  mountY: 0.5,
                  text: {
                      text: 'Error',
                      textAlign: 'center',
                      fontSize: 200,
                      highlight: false,
                  },
              },
          };
      }
      set params({ request }) {
          const error = request && request.error;
          if (error) {
              sharedInstance.error(error);
          }
          else {
              sharedInstance.error('Unhandled Exception');
          }
      }
  }

  class Splash extends BasePage {
      static _template() {
          return {
              Image: {
                  w: 1920,
                  h: 1080,
                  src: Utils.asset('images/splash_fhd.jpg'),
              },
          };
      }
      _onDataProvided() {
          console.log('_onDataProvided')
          const params = Store$1.qs;
          const usPrivacy = params.us_privacy;
          if (usPrivacy) {
              this.handlePrivacy(usPrivacy);
          }
          const lmt = params.lmt;
          if (lmt) {
              this.handleLimitedAdTracking(lmt);
          }
          const launchpoint = params.launchpoint;
          if (launchpoint) {
              this.handleLaunchpoint(launchpoint, params);
          }
          else {
              this._goToHome();
          }
      }
      _goToHome() {
          // TODO: Get brand by some other parameter?
          console.log('_goHome')
          Router.navigate('brand/' + BrandName.nbcnews);
      }
      async handleLaunchpoint(launchpoint, params) {
          Log.info('Deeplink: Handling launchpoint params', launchpoint, params);
          switch (launchpoint) {
              case 'home': {
                  this._goToHome();
                  return;
              }
              case 'detail': {
                  const entityId = params.entityId;
                  if (entityId) {
                      this.handleEntityId(entityId);
                  }
                  return;
              }
              case 'playback': {
                  const assetId = params.assetId;
                  if (assetId) {
                      Router.navigate(`video/${encodeURIComponent(assetId)}`);
                  }
                  return;
              }
              case 'search': {
                  const query = params.query;
                  if (query) {
                      Router.navigate('search', { query: query });
                  }
                  return;
              }
              case 'section': {
                  const sectionName = params.sectionName;
                  if (sectionName) {
                      this.handleSection(sectionName);
                  }
                  return;
              }
              default: {
                  this._goToHome();
                  return;
              }
          }
      }
      handlePrivacy(privacySetting) {
          Log.info('Deeplink: Handling privacy setting', privacySetting);
          // TODO
          return;
      }
      handleLimitedAdTracking(iabSetting) {
          Log.info('Deeplink: Handling limited ad tracking setting', iabSetting);
          // TODO
          return;
      }
      async handleEntityId(entityId) {
          const resource = await this.data.fetchResource(entityId);
          if ('type' in resource && resource.type === 'show') {
              Router.navigate(`show/${encodeURIComponent(entityId)}`);
          }
          else {
              Router.navigate(`playlist/${encodeURIComponent(entityId)}`);
          }
      }
      handleSection(section) {
          // TODO: Support more sections like Shows, Watch
          switch (section) {
              case 'settings':
                  Router.navigate('settings');
                  return;
              case 'search':
                  Router.navigate('search');
                  return;
              default:
                  return;
          }
      }
  }

  class VideoPage extends BasePage {
      static _template() {
          // Displays the loading + metadata on app load
          return {
              PlayerUI: {
                  type: PlayerUI,
              },
          };
      }
      _onDataProvided() {
          Store$1.flags.playingDeeplinkedVideo = true;
          const params = Store$1.qs;
          const resumeTime = params.resumeTime ? Number(params.resumeTime) : 0;
          Events.emit('$app.videoSelected', this.data, resumeTime);
          PlayerMetrics$1.start();
          Router.navigate('brand/' + this.data.brand, {
              hiddenOnLoad: true,
              skipAutoPlay: true,
          });
      }
      _getFocused() {
          return this.tag('PlayerUI');
      }
  }

  let AppData;
  // Needed for now when deeplinking to launchpoint with the naked url + params
  // eg. "lightning.nbcnews.com?launchpoint=section&sectionName=settings"
  function getQsFromURL() {
      if (window.location.search) {
          const urlParams = new URLSearchParams(window.location.search);
          return Array.from(urlParams).reduce((o, i) => ({ ...o, [i[0]]: i[1] }), {});
      }
      else {
          return {};
      }
  }
  function getCuratorEnv(qs) {
      if (Settings.get('app', 'debug')) {
          return qs.curator || 'dev';
      }
      else {
          return 'prod';
      }
  }
  var Routes = {
      root: 'splash',
      boot: async (_qs) => {
          console.log('boot')
          const qs = _qs || getQsFromURL();
          Store$1.qs = qs;
          const config = new Config(getCuratorEnv(qs));
          await config.fetch();
          await Platform.init();
          AppData = new Data(config);
          Platform.dismissLoadingScreen();
      },
      // TODO: A future version of lng will let us grab the hash inside the TabMenu widget
      // with `_onActivated(page), page.hash`. With that, we can remove this hook,
      // as well as the `$app.firstRoute` event
      beforeEachRoute: async (from, to) => {
          if (from === undefined) {
              Events.emit('$app.firstRoute', to.hash);
          }
          return true;
      },
      routes: [
          {
              path: 'splash',
              component: Splash,
              before: async (page) => {
                  console.log('before splash')
                  page.data = AppData;
              },
              options: {
                  preventStorage: true,
              },
          },
          {
              path: 'brand/:brand',
              component: HomePage,
              widgets: ['TabMenu', 'ExitModal'],
              before: async (page, { brand }) => {
                  console.log('before home')
                  const data = await AppData.fetchBrandData({ for: brand });
                  // TODO: Put behind feature flag
                  // data.channels = data.channels.map(ch => {
                  //     if (ch.type === 'playmakerLive') {
                  //         ch.videos = ch.videos.filter(vid => !vid.isAuth)
                  //     }
                  //     return ch
                  // })
                  data.channels = data.channels.filter(ch => ch.type !== 'playmakerLive');
                  page.data = data;
              },
          },
          {
              path: 'search',
              component: SearchPage,
              widgets: ['TabMenu', 'ExitModal'],
              before: async (page) => {
                  page.fetchSearchQuery = async (query) => await AppData.fetchSearchQuery(query);
              },
          },
          {
              path: 'settings',
              component: SettingsPage,
              widgets: ['TabMenu', 'ExitModal'],
          },
          {
              path: 'show/:cardId',
              component: CardPage,
              before: async (page, { cardId }) => {
                  const data = await AppData.fetchShowFromCard(decodeURIComponent(cardId));
                  const rows = [];
                  if (data.episodes && data.episodes.type !== 'tveEpisodes') {
                      rows.push(data.episodes);
                  }
                  rows.push(data.highlights);
                  if (data.segments) {
                      rows.push(...data.segments);
                  }
                  page.data = {
                      cardId: cardId,
                      title: data.title,
                      subtitle: data.available,
                      backgroundUrl: data.thumb,
                      activeBrand: AppData.current ? AppData.current.brand : undefined,
                      rows: rows,
                  };
              },
          },
          {
              path: 'playlist/:cardId',
              component: CardPage,
              before: async (page, { cardId }) => {
                  const data = await AppData.fetchPlaylistFromCard(decodeURIComponent(cardId));
                  page.data = {
                      cardId: cardId,
                      title: data.title,
                      backgroundUrl: data.image,
                      activeBrand: AppData.current ? AppData.current.brand : undefined,
                      rows: [data],
                  };
              },
          },
          {
              path: 'video/:videoId',
              component: VideoPage,
              before: async (page, { videoId }) => {
                  page.data = await AppData.fetchVideoFromId(decodeURIComponent(videoId));
              },
              options: {
                  preventStorage: true,
              },
          },
          {
              path: 'tab/:tabId',
              beforeNavigate: async (from, to) => {
                  switch (to.hash) {
                      case 'tab/settings':
                          return 'settings';
                      case 'tab/search':
                          return 'search';
                      default:
                          return 'brand/' + BrandName.nbcnews;
                  }
              },
              options: {
                  preventStorage: true,
              },
          },
          {
              path: '!',
              component: ErrorPage,
          },
      ],
  };

  class TabMenuItem extends lightning.Component {
      constructor() {
          super(...arguments);
          this._useActiveColor = false;
          //
          // override
          this.onSelected = () => {
              throw new TabMenuItemError();
          };
      }
      static _template() {
          return {
              Background: {
                  visible: false,
              },
              Image: {
                  mount: 0.5,
                  color: TabMenuItem.unfocusColor,
              },
          };
      }
      //
      // callbacks
      _focus() {
          this.patch({
              Image: {
                  color: TabMenuItem.focusColor,
              },
              Background: {
                  visible: true,
              },
          });
      }
      _unfocus() {
          this._updateImageColor();
          this.patch({
              Background: {
                  visible: false,
              },
          });
      }
      //
      // helpers
      _updateImageColor() {
          if (this.hasFocus()) {
              return;
          }
          this.patch({
              Image: {
                  color: this.useActiveColor ? TabMenuItem.activeColor : TabMenuItem.unfocusColor,
              },
          });
      }
      //
      // properties
      set image(value) {
          this.patch({
              Image: {
                  src: value,
                  x: this.w / 2,
                  y: this.h / 2,
              },
          });
      }
      get useActiveColor() {
          return this._useActiveColor;
      }
      set useActiveColor(value) {
          this._useActiveColor = value;
          this._updateImageColor();
      }
  }
  TabMenuItem.focusColor = 0xff000000;
  TabMenuItem.unfocusColor = 0xffc1c1c1;
  TabMenuItem.activeColor = 0xffffffff;

  class TabMenu extends lightning.Component {
      constructor() {
          super(...arguments);
          this._index = 0;
      }
      static _template() {
          const barHeight = 72;
          const padding = 28 * 2;
          const widths = {
              news: 146 + padding,
              msnbc: 163 + padding,
              today: 161 + padding,
              settings: 24 + padding,
              search: 24 + padding,
          };
          const roundedRectangleShader = {
              type: lightning.shaders.RoundedRectangle,
              radius: 10,
          };
          return {
              x: 1920 / 2,
              y: 46,
              mountX: 0.5,
              h: barHeight,
              Background: {
                  w: (w) => w,
                  h: (h) => h,
                  rect: true,
                  color: 0xc2000000,
                  //shader: roundedRectangleShader,
              },
              FocusedIndicator: {
                  h: (h) => h,
                  x: 0,
                  alpha: 0,
                  rect: true,
                  color: 0xffffffff,
                  //shader: roundedRectangleShader,
              },
              Items: {
                  News: {
                      w: widths.news,
                      h: barHeight,
                      type: TabMenuItem,
                      image: Utils.asset('images/top-bar/tab_news_light.png'),
                      onSelected: () => Router.navigate('brand/' + BrandName.nbcnews),
                  },
                  Msnbc: {
                      w: widths.msnbc,
                      h: barHeight,
                      type: TabMenuItem,
                      image: Utils.asset('images/top-bar/tab_msnbc_light.png'),
                      onSelected: () => Router.navigate('brand/' + BrandName.msnbc),
                  },
                  Today: {
                      w: widths.today,
                      h: barHeight,
                      type: TabMenuItem,
                      image: Utils.asset('images/top-bar/tab_today_light.png'),
                      onSelected: () => Router.navigate('brand/' + BrandName.today),
                  },
                  Search: {
                      w: widths.search,
                      h: barHeight,
                      type: TabMenuItem,
                      image: Utils.asset('images/top-bar/tab_search_light.png'),
                      onSelected: () => Router.navigate('search'),
                  },
                  Settings: {
                      w: widths.settings,
                      h: barHeight,
                      type: TabMenuItem,
                      image: Utils.asset('images/top-bar/tab_settings_light.png'),
                      onSelected: () => Router.navigate('settings'),
                  },
              },
          };
      }
      //
      // component's events
      _init() {
          this._initWidth();
          Events.on('$app.firstRoute', this._setActiveItemFromHash.bind(this));
      }
      _focus() {
          this.focusedIndicator.setSmooth('alpha', 1);
          this._updateFocusedIndicator(false);
      }
      _unfocus() {
          this.focusedIndicator.setSmooth('alpha', 0);
      }
      _getFocused() {
          return this.selected;
      }
      _handleRight() {
          this.index++;
      }
      _handleLeft() {
          this.index--;
      }
      _handleEnter() {
          this.selected.onSelected();
          this._updateActiveItemColor();
      }
      _handleDown() {
          Router.focusPage();
      }
      _handleUp() {
          // This prevents a bug where focus goes out of the widget on Up
          return true;
      }
      _handleBack() {
          Router.focusWidget('ExitModal');
      }
      show() {
          this.setSmooth('alpha', 1);
      }
      hide() {
          this.setSmooth('alpha', 0);
      }
      _updateActiveItemColor() {
          this.items.forEach((item, i) => {
              item.useActiveColor = i === this.index;
          });
      }
      _setActiveItemFromHash(hash) {
          const tabItems = [
              `brand/${BrandName.nbcnews}`,
              `brand/${BrandName.msnbc}`,
              `brand/${BrandName.today}`,
              'search',
              'settings',
          ];
          const index = tabItems.indexOf(hash);
          if (index > -1) {
              this.index = index;
              this._updateActiveItemColor();
          }
      }
      _initWidth() {
          let width = 0;
          this.items.forEach(item => {
              item.x = width;
              width += item.w;
          });
          this.w = width;
      }
      _updateFocusedIndicator(smooth = true) {
          const values = {
              w: this.selected.w,
              x: this.selected.x,
          };
          const patch = smooth ? { smooth: values } : { ...values };
          this.focusedIndicator.patch(patch);
      }
      //
      // properties
      get focusedIndicator() {
          return this.tag('FocusedIndicator');
      }
      get items() {
          return this.tag('Items').children;
      }
      get selected() {
          return this.items[this.index];
      }
      get index() {
          return this._index;
      }
      set index(value) {
          this._index = clamp(value, 0, this.items.length - 1);
          this._updateFocusedIndicator();
      }
  }

  class KeyDebug extends lightning.Component {
      constructor() {
          super(...arguments);
          this.keyDebugFeatureFlag = KeyDebug.getKeyDebugFeatureFlag();
          this.lastKeyCode = '';
          this.consecutiveKeyPresses = 0;
      }
      static _template() {
          return {
              x: 150,
              y: 20,
              w: 300,
              h: 80,
              alpha: 0,
              Background: {
                  w: (w) => w,
                  h: (h) => h,
                  color: 0xff05b34a,
                  rect: true,
//                  shader: {
//                      type: lightning.shaders.RoundedRectangle,
//                      radius: 15,
//                  },
              },
              KeyText: {
                  x: 20,
                  y: 15,
                  text: {
                      fontFace: 'Regular',
                      fontSize: 35,
                  },
              },
          };
      }
      captureKeyEvent(keyCode) {
          if (!this.keyDebugFeatureFlag) {
              return false;
          }
          if (this.keyDebugDisplayTimeout) {
              Registry.clearTimeout(this.keyDebugDisplayTimeout);
          }
          this.consecutiveKeyPresses =
              this.lastKeyCode === keyCode ? this.consecutiveKeyPresses + 1 : 0;
          const keyCodeText = this.consecutiveKeyPresses
              ? keyCode + ' ' + (this.consecutiveKeyPresses + 1) + 'x'
              : keyCode;
          this.patch({
              alpha: 1,
              KeyText: {
                  text: {
                      text: keyCodeText,
                  },
              },
          });
          const textWidth = 40 + getElementRenderWidth(this.tag('KeyText'));
          this.patch({ w: textWidth });
          this.keyDebugDisplayTimeout = Registry.setTimeout(() => {
              this.patch({ alpha: 0 });
              this.consecutiveKeyPresses = 0;
              this.lastKeyCode = '';
          }, 1000);
          this.lastKeyCode = keyCode;
          return false;
      }
      static getKeyDebugFeatureFlag() {
          // using regex to get param, because window.location.search is empty string when param is added manually
          // get params from URL
          const rx1 = new RegExp('[?&](([^&=]+)=([^&=#]*))');
          const rx1match = window.location.href.match(rx1);
          if (rx1match && rx1match.length) {
              // get debug param from params
              const paramName = 'displayKeys';
              const rx2 = new RegExp('[?&]' + paramName + '=([^&]+).*$');
              const rx2match = rx1match[0].match(rx2);
              if (rx2match && rx2match.length >= 2)
                  return rx2match[1].toLowerCase() === 'true';
              else
                  return false;
          }
          else
              return false;
      }
  }

  const PLAYER_EVENTS_MAPPING = new Map([
      ['abort', 'Abort'],
      ['canplay', 'CanPlay'],
      ['canplaythrough', 'CanPlayThrough'],
      ['durationchange', 'DurationChange'],
      ['emptied', 'Emptied'],
      ['encrypted', 'Encrypted'],
      ['ended', 'Ended'],
      ['error', 'Error'],
      ['interruptbegin', 'InterruptBegin'],
      ['interruptend', 'InterruptEnd'],
      ['loadeddata', 'LoadedData'],
      ['loadedmetadata', 'LoadedMetadata'],
      ['loadstart', 'LoadStart'],
      ['pause', 'Pause'],
      ['play', 'Play'],
      ['playing', 'Playing'],
      ['progress', 'Progress'],
      ['ratechange', 'Ratechange'],
      ['seeked', 'Seeked'],
      ['seeking', 'Seeking'],
      ['stalled', 'Stalled'],
      ['suspend', 'Suspend'],
      ['timeupdate', 'TimeUpdate'],
      ['volumechange', 'VolumeChange'],
      ['waiting', 'Waiting'],
  ]);

  function setVideoProtocol(url) {
      if (document.location.protocol == 'https:')
          return url.replace('http:', 'https:');
      return url;
  }
  class HLSPlayer {
      constructor(config, onPlayerEvent) {
          this.video = VideoPlayer._videoEl;
          this.pid = null;
          this.monitorTimer = null;
          this.onPlayerEvent = onPlayerEvent;
          this.config = {
              ...config,
              // TD: get from appconfig
              pidNotificationsUrl: 'http://stream.nbcsports.com/data/lowttl/notifications_{PID}.json',
              pidNotificationsPollingInterval: 20000,
          };
          this.registerEventListeners(this.video);
          VideoPlayer.isPlaying = false;
      }
      registerEventListeners(videoEl) {
          for (const event of PLAYER_EVENTS_MAPPING) {
              Registry.addEventListener(videoEl, event[0], this);
          }
      }
      handleEvent(event) {
          const mappedEvent = PLAYER_EVENTS_MAPPING.get(event.type);
          if (mappedEvent) {
              this.onPlayerEvent({
                  type: mappedEvent,
                  timestamp: event.timeStamp,
              });
              // Needed as we can't rely on VideoPlayer's internal state,
              // since the lng's listeners don't get attached if we use hls.js
              switch (mappedEvent) {
                  case 'Play':
                  case 'Playing':
                      VideoPlayer.isPlaying = true;
                      break;
                  case 'Pause':
                  case 'LoadStart':
                  case 'Ended':
                  case 'Error':
                  case 'Abort':
                      VideoPlayer.isPlaying = false;
                      break;
              }
          }
      }
      deregisterEventListeners(videoEl) {
          for (const event of PLAYER_EVENTS_MAPPING) {
              Registry.removeEventListener(videoEl, event[0], this);
          }
      }
      async playWithPid(pid, startPosition) {
          Log.info('play pid:', pid);
          this.stopPidMonitor();
          const result = await fetch(`https://api.leap.nbcsports.com/pid/NBCNews/${pid}/v4/roku`, {
              method: 'GET',
              headers: {
                  Accept: 'application/json',
              },
          });
          if (result.ok) {
              const root = await result.json();
              let url = root.videoSources[0].cdnSources.primary[0].sourceUrl;
              const auth = root.auth;
              if (auth.cdnToken && auth.authenticationType == 'unauth') {
                  url = await this.fetchUnauthToken(url, pid);
              }
              this.playWithUrl(url, startPosition);
              this.startPidMonitor(pid);
          }
      }
      playWithUrl(url, startPosition) {
          Log.info('playWithUrl >', url);
          VideoPlayer.open(setVideoProtocol(url), { startPosition });
          Log.info('< playWithUrl');
      }
      // get unauth token
      async fetchUnauthToken(url, pid) {
          const json = {
              authenticationType: 'unauth',
              application: this.config.application,
              cdn: 'akamai',
              pid: pid,
              platform: this.config.platform,
              requestorId: this.config.requestorId,
              resourceId: '',
              token: '',
              url: url,
              version: 'v1',
          };
          const result = await fetch('https://tokens.playmakerservices.com/cdn', {
              method: 'POST',
              headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json',
              },
              body: JSON.stringify(json),
          });
          //Log.info("token", r)
          if (result.ok) {
              const root = await result.json();
              return root.akamai[0].tokenizedUrl;
          }
          // TD: throw error
          return null;
      }
      startPidMonitor(pid) {
          this.pid = pid;
          this.monitorTimer = Registry.setInterval(async () => {
              const result = await fetch(this.config.pidNotificationsUrl.replace('{pid}', pid), {
                  method: 'GET',
                  headers: {
                      Accept: 'application/json',
                  },
              });
              if (result.ok) {
                  const root = await result.json();
                  if (root.notifications != null && root.notifications[0] != null) {
                      const redirectPid = this.pidFromNotification(root.notifications[0]);
                      if (redirectPid != null && redirectPid != this.pid) {
                          this.playWithPid(redirectPid);
                      }
                  }
              }
          }, this.config.pidNotificationsPollingInterval);
      }
      pidFromNotification(notification) {
          if (notification.action == '3') {
              return notification.pid;
          }
          return null;
      }
      stopPidMonitor() {
          if (this.monitorTimer) {
              clearInterval(this.monitorTimer);
              this.monitorTimer = null;
              this.pid = null;
          }
      }
      _detach() {
          this.deregisterEventListeners(this.video);
      }
      seek(value) {
          VideoPlayer.seek(value);
      }
      set ccEnabled(enabled) {
          if (this.video.textTracks[0]) {
              this.video.textTracks[0].mode = enabled ? 'showing' : 'disabled';
          }
      }
      get ccEnabled() {
          return this.video.textTracks[0] && this.video.textTracks[0].mode === 'showing';
      }
  }

  class Player extends lightning.Component {
      constructor() {
          super(...arguments);
          this._player = new HLSPlayer({
              application: 'nbcnews',
              platform: 'roku',
              requestorId: 'nbcnews',
          }, this.$playerEvent.bind(this));
      }
      async _checkHdmiConnectionStatus() {
          const connected = await Platform.getHDMIConnectedStatus();
          if (!connected && VideoPlayer.isPlaying) {
              VideoPlayer.pause();
          }
      }
      _init() {
          Events.on('$app.videoSelected', this.$videoSelected.bind(this));
          Registry.setInterval(this._checkHdmiConnectionStatus, Platform.hdmiConnectionRefreshInterval);
      }
      $playerEvent(ev) {
          Events.emit('$player.playerEvent', ev);
      }
      $videoSelected(video, resumeTime) {
          if (video.videoType === 'liveshow' && video.guid) {
              this._player.playWithPid(video.guid, resumeTime);
          }
          else if (video.videoUrl) {
              this._player.playWithUrl(video.videoUrl, resumeTime);
          }
      }
  }

  class Button$1 extends lightning.Component {
      static _template() {
          const fontSize = 25;
          return {
              w: Button$1.buttonWidth,
              h: Button$1.buttonHeight,
              texture: lightning.Tools.getRoundRect(Button$1.buttonWidth, Button$1.buttonHeight, 0, 2, 0xffffffff, false, 0xe6000000),
              Text: {
                  w: Button$1.buttonWidth,
                  y: 12,
                  text: {
                      text: '',
                      textAlign: 'center',
                      fontSize: fontSize,
                      textColor: 0xffffffff,
                      fontFace: 'FoundersGroteskCondensed-Semibold',
                  },
              },
          };
      }
      set buttonText(value) {
          this.patch({ Text: { text: value } });
      }
      _focus() {
          this.patch({
              texture: lightning.Tools.getRoundRect(Button$1.buttonWidth, Button$1.buttonHeight, 0, 2, 0xffffffff, true, 0xffffffff),
              Text: { text: { textColor: 0xe6000000 } },
          });
      }
      _unfocus() {
          this.patch({
              texture: lightning.Tools.getRoundRect(Button$1.buttonWidth, Button$1.buttonHeight, 0, 2, 0xffffffff, false, 0xe6000000),
              Text: { text: { textColor: 0xffffffff } },
          });
      }
  }
  Button$1.buttonWidth = 174;
  Button$1.buttonHeight = 61;

  class ExitModal extends lightning.Component {
      static _template() {
          const width = 1920;
          const height = 1080;
          const boxWidth = 580;
          const boxHeight = 120;
          const buttonWidth = 174;
          const buttonHeight = 61;
          return {
              alpha: 0,
              Overlay: {
                  w: width,
                  h: height,
                  rect: true,
                  color: 0xe0000000,
              },
              Box: {
                  x: width / 2 - boxWidth / 2,
                  y: height / 2 - boxHeight / 2,
                  w: boxWidth,
                  h: boxHeight,
                  texture: lightning.Tools.getRoundRect(boxWidth, boxHeight, 10, 2, 0xffffffff, true, 0xe6000000),
                  Continue: {
                      x: 80,
                      y: boxHeight / 2 - buttonHeight / 2,
                      type: Button$1,
                      buttonText: 'Continue',
                  },
                  Quit: {
                      x: buttonWidth + 140,
                      y: boxHeight / 2 - buttonHeight / 2,
                      type: Button$1,
                      buttonText: 'Quit App',
                  },
              },
          };
      }
      static _states() {
          return [
              class ContinueFocused extends this {
                  _getFocused() {
                      return this.tag('Continue');
                  }
                  _handleEnter() {
                      Router.focusPage();
                  }
                  _handleRight() {
                      this._setState('QuitFocused');
                  }
                  _handleLeft() {
                      return true;
                  }
                  _handleBack() {
                      Router.focusPage();
                  }
              },
              class QuitFocused extends this {
                  _getFocused() {
                      return this.tag('Quit');
                  }
                  _handleRight() {
                      return true;
                  }
                  _handleLeft() {
                      this._setState('ContinueFocused');
                  }
                  _handleBack() {
                      Router.focusPage();
                  }
                  _handleEnter() {
                      Platform.shutdown();
                      this.application.closeApp();
                  }
              },
          ];
      }
      _focus() {
          // this.patch({ alpha: 1 })
          this.setSmooth('alpha', 1);
          this._setState('ContinueFocused');
      }
      _unfocus() {
          // this.patch({ alpha: 0 })
          this.setSmooth('alpha', 0);
      }
  }

  class App extends Router.App {
      static getFonts() {
          return [
              {
                  family: 'Regular',
                  url: Utils.asset('fonts/Roboto-Regular.ttf'),
              },
              {
                  family: 'FoundersGroteskCondensed-Bold',
                  url: Utils.asset('fonts/FoundersGroteskCondensed-Bold.otf'),
              },
              {
                  family: 'FoundersGroteskCondensed-Semibold',
                  url: Utils.asset('fonts/FoundersGroteskCondensed-Semibold.otf'),
              },
              {
                  family: 'FoundersGroteskCondensed-Regular',
                  url: Utils.asset('fonts/FoundersGroteskCondensed-Regular.otf'),
              },
              {
                  family: 'FoundersGroteskCondensed-Light',
                  url: Utils.asset('fonts/FoundersGroteskCondensed-Lite.otf'),
              },
              {
                  family: 'FoundersGroteskMono-Regular',
                  url: Utils.asset('fonts/FoundersGroteskMono-Regular.otf'),
              },
              {
                  family: 'FoundersGroteskMono-Semibold',
                  url: Utils.asset('fonts/FoundersGroteskMono-Semibold.otf'),
              },
          ];
      }
      static _template() {
          return {
              ...super._template(),
              Widgets: {
                  // this hosts all the widgets
                  TabMenu: {
                      type: TabMenu,
                  },
                  ExitModal: {
                      type: ExitModal,
                  },
              },
              Player: {
                  type: Player,
              },
              KeyDebug: {
                  type: KeyDebug,
              },
          };
      }
      _setup() {
          Router.startRouter(Routes, this);
          sharedInstance.init();
          sharedInstance.appLaunch();
      }
      _getFocused() {
          return Router.getActivePage();
      }
      _captureKey(event) {
          return this.keyDebug.captureKeyEvent(event.key);
      }
      get keyDebug() {
          return this.tag('KeyDebug');
      }
  }

  function index(appSettings, platformSettings, appData) {
      if (window.innerHeight === 720) {
          // TODO: Detect window size with platform-specific method?
          appSettings.stage.w = 1280;
          appSettings.stage.h = 720;
          appSettings.stage.precision = 2 / 3;
      }
      appSettings.keys = Platform.keyMapping;
      if (Platform.deviceType === 'X1') {
          // Workaround for a bug in Xi6 and Xi3 devices where the "Back" button
          // on the remote triggers a `hashchanged` event when it should not,
          // and the router navigates to any route defined that has an url
          // without params, eg. `search` or `settings`.
          // Metro and Comcast are aware of this bug
          if (!platformSettings.router) platformSettings.router = {};
          platformSettings.router.updateHash = false;
      }
      return Launch(App, appSettings, platformSettings, appData)
  }

  return index;

}());
//# sourceMappingURL=appBundle.js.map
